tl;dr: We’ve opened applications for our winter 2013 batch. This will be our sixth batch, and it will run from February 11 to May 2.

The deadline for applications is Tuesday, January 1st at 11:59pm ET. We’ll begin sending out invitations for interviews then, and we’ll schedule Skype interviews for the first two weeks of January. We’ll consider applications submitted after the deadline, but your odds will be lower.

If you’re like me, you read a lot of blog posts about self-improvement: Posts about how you can be more productive, or understand hard concepts, or become a better programmer.

The internet is full of amazing information. In fact, there’s already more technical knowledge freely available online than any single person could possibly learn in a lifetime.

The real answer for how to get better is to sit down and work at it. It takes time, concentration, and effort.

It also requires breaking out of our routines and bad habits. Simply resolving to try harder this year isn’t going to do much in the long-run. Trying the same thing repeatedly and expecting different results is the very definition of insanity.

That’s why we started Hacker School. We wanted to become better programmers, and we knew that meant time, concentration and hard work. And it meant breaking our old bad habits of reading Hacker News and blog posts about how other people were becoming better programmers.

Hacker School isn’t a shortcut. You won’t become exceptional overnight. But the truth is nobody becomes exceptional overnight. And nobody becomes exceptional reading blog posts on maximizing their efficiency. All the shortcuts you read online are really detours; they just run out the clock on your life without getting you any closer to where you want to be.

Doing Hacker School structures your life such that the default expectation is for you to spend the majority of your time programming. That’s it. The group sits in a room together eight hours a day, four days a week for twelve weeks. We check-in with each other about what we’ve built and learned, what we’re doing next, and where we’re stuck. We explain the things we understand to others in the group who don’t yet understand them, and they explain the things they understand to us.

We do this without judgement or snide remarks. We do this because people’s fear of appearing stupid is a serious impediment to becoming better, and the goal of Hacker School is to remove as many obstacles in the way of growth as possible.

Hacker School is not a magic elixir that will automatically make you an exceptional programmer. But it does remove distractions, and give you dedicated time to focus. And apply mild social pressure. And surround you with supportive, friendly people working towards similar goals. And give you direct access to people with more experience and knowledge.

Reading blog posts will no sooner make you a better programmer than reading fitness magazines will give you great abs. If you want to be buff you have to go to the gym. If you want to be a great programmer you have to write code.

Come to Hacker School.

We’ll have more to announce soon, but we wanted to give people as much time as possible to apply. If you have any questions, please check our FAQ. If they’re not answered there, please email admissions@hackerschool.com.


Last year we hosted two open houses at our space in New York City, and were grateful to get the chance to share what the Recurse Center is like with so many new folks. We’d like to do the same for programmers who live in San Francisco and couldn’t make it out to New York City for our past events.

On Friday, February 19th from 2:30 pm - 4:30 pm we’ll be hosting an info session at Stripe’s offices in San Francisco for folks on the west coast who would like to learn more about RC. While you won’t be able to visit the RC space, you’ll have the chance to meet alumni, see some projects they worked on during their batches, and ask us lots of questions.

The session will begin with a short welcome talk, followed by presentations from current and past Recursers about what they’ve been working on, and a Q&A session. Food and drinks will be served. 

Once you RSVP, we’ll send you more details about the timing of the event and the location. Special thanks to Stripe for hosting us and for providing lunch.

We’re hoping the open house gets you excited to apply for a batch, whether you’ve never considered applying before or if you have been thinking about it for years.

If you’d like to attend, RSVP no later than Monday, February 15th. Please note that space is limited, and we may need to close RSVPs.


Starting today, you can now come to RC Retreat for a six-week-long half-batch.

As RC has grown, it has become more apparent that one of the best parts of RC is the alumni community. One alum even described RC as “the world’s best programming community with a three-month onboarding process in New York.” The RC community gets better as it grows, and we want to make sure that our community is open to as many smart, curious programmers as possible. One way to do this is to lower the time commitment required to join the RC community.

For the past four and a half years RC batches have been three months long. We think there are people who would make awesome additions to the RC community who can’t commit to spending three months in New York, and we hope six-week half-batches will allow at least some of them to join us.

While three-month batches have worked well, we don’t think there’s anything special about three months. We want to experiment with allowing people to come to RC for both shorter and longer amounts of time. Half-batches are a good place to start because it easily fits in with how RC is currently scheduled.

Like much of what we do at RC, half-batches are an experiment, and we do not know how well they will work. RC’s radically self-directed environment can sometimes be hard for people to get used to, and having half as much time as normal may make things more difficult. If you come to RC for a half-batch, we think it’s especially important to be focused and intentional about what your goals are and how you spend your time.

On the other hand, it’s possible that being at RC for six weeks will actually be a better experience for some people. Constraints are often productive, and the urgency of being at RC for a shorter time may help some Recursers find their path faster.

To apply, select “Half batch (six weeks)” under “Duration” on our apply page. You will go through the same admissions process as if you were applying for a full batch. If you are admitted, you will attend the first six weeks of whatever batch you select. You can switch from a half-batch to a full-batch at any time, space permitting. All you have to do is tell us.

RC offers need-based grants for women and people from racial and ethnic groups traditionally underrepresented in programming. Since RC Retreat is free to attend, the grants are intended to be used for cost of living expenses. Grants for a half-batch of RC are between $500 and $3,500.

If you are relatively new to programming, have not programmed professionally before, and would like to get a programming job after RC, you should consider either doing RC Start or a full batch of RC Retreat.

The most important thing you can do as a new programmer is give yourself enough time to learn. While you can make a lot of progress in six weeks, it’s probably not enough to go from relatively inexperienced to being ready to program professionally. Even twelve weeks is not a lot of time when you’re starting out. Forcing yourself to go through the stress of a premature job search makes it harder to focus on becoming a better programmer, right when that’s what you need most to get a job.

Joining the RC community is a great way to get help becoming a professional programmer: we have an active, friendly community of over 700 alumni who can give advice, code review, and help you get unstuck. Our goal with half-batches is to lower the commitment required to join the RC community, not to help people become professional programmers in six weeks.

RC Retreat is a free, self-directed, educational retreat in New York City for people who want to get better at programming. People come to RC from all over the world to become better programmers, whether they’ve been programming professionally for 30 years or just started programming six months ago. Between RC Start and RC Retreat, there’s a place for you in the RC community no matter how long you’ve been programming.

RC has lightweight social rules that help everyone focus on programming, an integrated research lab trying to discover better ways of computing, and a residents program where especially accomplished programmers with deep expertise spend one or two weeks at RC working with Recursers.

If this post hasn’t convinced you to apply, check out our about page, our FAQ, and our User’s Manual, and email us if you have any questions.


Back in 2013, RC alum Sasha Laundy built Blaggregator, a blog aggregator for the RC community. Many Recursers use Blaggregator to automatically push posts from their blogs to the blogging stream on Zulip, our internal chat system, and lots of great discussions between alumni, residents, and current Recursers have cropped up as a result.

Thanks to those discussions, we’ve noticed certain trends in the things Recursers blog about. Several alumni recently made a page on our wiki that lists all of the “return statements,” or end-of-batch reflection posts, Recursers have written.

We think these posts will be helpful for anyone working on becoming a better programmer, and that they also do a good job explaining what happens at RC. This is not an exhaustive list of all the end-of-batch posts Recursers have written, but it’s a good sample.

Retrospective – Mindy Preston, Winter 2014 


The Recurse Center wasn’t my first rodeo; I have an undergraduate degree in computer science and have worked through some pretty punishing crunch times as a professional maker of software. The thirst for knowledge and accomplishment I felt from my fellow batchlings at RC, and the urgency it fostered in me, was something entirely new to me. I came into the space fighting a lot of negative feelings about the work it was possible to do in the world as someone who makes software. Many (although by no means all) RCers are early in their careers, and it was hugely restorative for me to be around, and share in, their enthusiasm and love for discovery. I wanted to write code again, and I wanted badly for it to be good, not just good enough.  

A summary of my time at RC – Lin Taylor, Fall 2, 2015 


This post is a reflection of the things that I learned [at RC], as well as my highlights and lowlights of the past 3 months. tl;dr: had a great time, learned a lot. If you want to get better at programming and also meet a whole lot of smart, passionate people who will help you do it, RC is the place. 

RC Spring 2, 2015 Return Statement – Nat Welch, Spring 2, 2015 


I’m not entirely sure what happened, but I somehow wrote something every day for one hundred consecutive days. I lived at a level of transparency I wish I had been doing for years (and I kind of wish all of humanity could do every day). The place that inspired me to do this was the Recurse Center. 

The blog that should have been – Margo Smith, Fall 2, 2014 


After 16 years of school and 2 years working, it took this unstructured 3-month program for me to finally learn that I don’t need institutional incentives to keep learning. All I need is a supportive environment and the freedom to work on whatever I want. This means (I hope) that [RC] wasn’t just a 3-month program, but rather a starting point for a lifetime of continued learning.  

Reflections on the Recurse Center – John Loeber, Fall 2, 2014 


What’s interesting about having all traditional external obstacles removed is that it exposes the internal ones. While there sometimes are genuine external obstacles to success, I think that internal ones (like a lack of focus or using one’s time poorly) can be more persistent or more stifling. An external obstacle may block you for a few days, weeks, or maybe even years, but the nature of an external obstacle is often clear, as is a path to eventually overcoming it. An internal obstacle may block you for life if undetected, and some of them are very subtle…The Recurse Center was extremely useful in that it facilitated the detection of these internal obstacles.  

Advice for new Hacker Schoolers Recursers – Pablo Torres, Winter 2014 


One advantage of getting to know your fellow batchlings early on is that you get a sense of who to ask what questions to from the beginning. During the first few weeks of my batch, I could always point people to whoever was most likely to help them. “I think I’m gonna write a recommendation system,” they would say, and “Oh! Rad Person is writing their masters thesis on exactly that! You should talk to them!” I would answer. I got that part right.  

Recurse Center: The return statement – Pam Selle, Spring 1, 2015 


I went to RC intending for it to stand as my “instead of grad school” experience (at least for now), thinking I would study formal theory. I thought I needed these things to have the knowledge I wanted, but I realized that formal theory will always be there for me, and wandering into project-based learning and working with others on their projects led me to finding the theory I needed, and not learning it for the sake of an ephemeral checkbox.  

The Recurse Center and the joy of learning – Martin Kleppmann, Fall 1 and 2 2015 resident 


After working with a few members of the batch, I realised why the varying levels of experience are not a problem for RC: everyone is a beginner at the thing they are exploring at RC. If you are an experienced software developer, you don’t go to RC in order to keep doing the same things as you did at your last job, using the same languages to build the same kind of application. No, you probably join RC because you want to learn something completely different. Your time at RC is an opportunity to “level up” your craft. If you’re an experienced web developer, how about learning a functional language like Haskell or Idris? If you’re a veteran C++ hacker, maybe you want to learn about formal methods like Coq or TLA+? Even if you’ve been writing software for 20 years, you’re a complete newbie when you move so far out of your comfort zone – so you’re actually not that different from someone who is trying to get their first small piece of Python code to work. You’re a beginner too.  

I’ve left the Recurse Center – Mary Rose Cook, facilitator emerita 


I did the best work of my life at RC. And I had the best time of my life at RC. I’m sad not to be able to program every day with Recursers. I’m sad not to be able to work on making RC the best place in the world to learn to program. And I’m sad to be parting from some dear friends. I’ve learnt most of what I know about programming from Recursers. They helped me get better at code review, get better at explaining things and get better at pairing. They taught me both how and why to dive deep and how and why to be rigorous. They helped me try things that seemed too hard and helped me discover that they were hard but doable.  


The first piece from the sixth issue of Code Words, our quarterly publication about programming, is now online!

As with our fourth and fifth issues, we’re publishing Issue Six piece-by-piece. You can read more about the reasons why in our Issue Four announcement blog post from October. We’ll be publishing the rest of the pieces from the issue throughout the month of March, so make sure to check back regularly!

The first piece is an exploration of the sometimes frightening realities of applying functional programming principles in JavaScript by Sal Becker.

Update on March 10th, 2016: the second piece from Issue Six, Image Processing 101 by Sher Minn Chong, is now live! The remaining five pieces will be published over the next three weeks.

Update on March 16th, 2016: the third piece from Issue Six, Telling stories with data using the grammar of graphics by Liz Sander, is now live! The remaining four pieces will be published over the next two weeks.

Update on March 29th, 2016: the fourth piece from Issue Six, Immutability is not enough by Patrick Dubroy, is now live!

Update on March 31st, 2016: the fifth piece from Issue Six, Promoting reliability in web software companies by Nat Welch, is now live!
We unfortunately weren’t able to finish two of the seven articles submitted to Issue Six in time for publication — look out for them in future issues of Code Words!

With seven articles, Issue Six will be the biggest issue of Code Words yet, featuring writing from Sal Becker (RC Fall 2, 2015), Miles Blackwood (RC Fall 2, 2015), Sher Minn Chong (RC Fall 1, 2015), Patrick Dubroy (RC resident), Liz Sander (RC Summer 2, 2015) , Anjana Vakil (RC Fall 2, 2015),  and Nat Welch (RC Spring 2, 2015). In addition to all of the writers, we’d like to thank Barak Chamo (RC Fall 1, 2015), Timnit Gebru (RC Summer 2012), Robert Lord (RC Winter 2014), Alan O'Donnell (facilitator emeritus and RC Summer 2011), Oskar Thorén (RC Fall 2012), and Alex Wilson (RC Summer 2013) for all their careful editing and help.

Code Words is written and edited by the Recurse Center community. Like RC itself, we aim to make Code Words accessible and useful to both new and seasoned programmers, and to share the joyful approach to programming and learning that typifies Recursers. Code Words contributors retain the rights to their work, and provide their essays under the terms of the Creative Commons BY-NC-SA 4.0 license.

If you’d like to receive updates about new issues and news about the Recurse Center, sign up for our mailing list.


RC Research Fellow Michael Nielsen recently published an essay called Toward an exploratory medium for mathematics. The essay is about about developing user interfaces and data models that allow for semi-concrete reasoning – getting the computational and constraint-solving benefits of a computer without losing the flexibility of paper and pencil.

Michael writes:

In discussions of systems of reasoning it is sometimes assumed that the informal, intuitive systems used by humans are things to be “fixed up”, turned into so-called proper, rigorous reasoning. If the purpose of reasoning were merely verifying correctness, then that would be a reasonable point of view. But if the purpose of reasoning is exploration and discovery, then it is wrong. Exploration and discovery require a logic that is different to, and at least as valuable as, conventionally “correct” reasoning…

Alan Kay has asked “what is the carrying capacity for ideas of the computer?” We may also ask the closely related question: “what is the carrying capacity for discovery of the computer?” In this essay we’ve made progress on that question using a simple strategy: develop a prototype medium to represent mathematics in a new way, and carefully investigate what we can learn when we use the prototype to attack a serious mathematical problem…

A powerful medium reifies the deepest ideas we have about a subject: it becomes an active carrier for those ideas. And to the extent it is successful in reifying those ideas, mastering the medium becomes the same as mastering the subject. In this view, designing exploratory media is about designing tools which can transform and extend our ability to think, create, and discover.

You can read the full essay on Michael’s website and learn more about RC Research on our blog.


We’re excited to welcome Lisa Neigut, James Porter, and Ginger Neigut to the RC team!

Lisa and James are joining us as facilitators. They’re both also RC alums: Lisa attended the Summer 2012 batch, and James attended the Summer 2013 batch.

Lisa was a founding member of the Etsy Android team, where she helped launch 2 apps and a mobile payments reader.  Most notably, one of her hack week projects bumped Etsy stock by 30% in a day. After Etsy, Lisa spent 14 months as the Android Engineer at Electric Objects, helping build a home for digital art.

James has worked in the past on everything from fruit fly genetics to online payment systems to storage infrastructure for bioinformatics. He was in the Summer 2013 batch, and outside of computing enjoys cycling and tabletop games of all sorts (he’s already taught a large contingent of Recursers how to play Netrunner!).

Last but not least, Ginger is joining us as Chief Cuddle Officer, and one-on-one advisor. She is our first canine hire, and we look forward to the new perspective she’ll bring to RC.

Last year we made some changes to the way facilitators work at RC. Rather than hire folks to be facilitators for indefinite periods of time, we now hire facilitators for six months. The main reason we decided to do this was that we got feedback from former facilitators that they felt burnt out after a year or so of doing facilitation work. Facilitation involves daily one-on-one pairing sessions, giving workshops, attending events, and being generally available to Recursers who have questions. Though it involves a lot of programming, it can also be socially demanding.

We call these folks fluid facilitators. Six months seems a good amount of time for people to ramp up and be effective facilitators without burning out.

Last August we hired John J. Workman (RC 2011) and Allie Jones (RC Winter 2013) as our first fluid facilitators. While their six months of facilitation are over, we wanted to keep working with them, so we hired them as programmers. Allie will be working on jobs and recruiting software, and John will be working on software to help grow our community.

We’re so excited to have Allie, James, John, Lisa, and Ginger on the RC team!


We’re excited to announce that Steve Klabnik and Paul Fenwick will be joining us as Recurse Center residents later this year, and that Frank Wang will be rejoining us as a second-time resident! Read more about them below.

If you’d like to work with any of these folks, apply to do a batch of RC during their residency. Keep an eye on our blog for more 2016 resident announcements!


Steve Klabnik is a software developer, working for Mozilla as a core team member of the Rust programming language. A long-time writer, Steve authored the official book on Rust, “The Rust Programming Language”, as well as several others: “Rails 4 in Action”, “Designing Hypermedia APIs”, and “Rust for Rubyists”. Before working on Rust, Steve was heavily involved in the Ruby and Rails communities, and used to teach Rails professionally. Steve will be in residence from  6/20 - 6/23 (Spring 2 and Summer 1 batches).


Paul “@pjf” Fenwick is an internationally acclaimed public speaker, developer, and science educator. Paul is well known for presenting on a diverse range of topics including privacy, neuroscience and neuroethics, Klingon programming, open source, depression and mental health, advancements in science, diversity, autonomous agents, and minesweeper automation. Paul was awarded the 2013 O'Reilly Open Source award, and the 2010 White Camel award, both for outstanding contributions to the open source community. As a Freedom Loving Scientist, Paul’s goal is to learn everything he can, do amazing things with that knowledge, and give them away for free. Paul will be in residence from  7/11 - 7/20  Summer 1 and 2 batches).


Frank Wang is a PhD student at MIT focusing on building secure systems. He did his undergraduate at Stanford, focusing on applied cryptography. He runs the MIT security seminar where top academics come and talk about their most recent research. He is also a member of Roughdraft Ventures, which provides small amounts of capital to early stage student startups. He is currently running a summer program for early stage security companies called Cybersecurity Factory. He has interned at the security teams at Google and Facebook as well as consulted for security companies like Qualys. When he is not busy worrying about your security, he enjoys going to art museums and being outdoors. Frank will be in residence from  5/23 - 6/2 (Spring 2 and Summer 1 batches).


We’re excited to announce three more residents for this summer: Andreas Fuchs, Sarah Sharp, and Jamey Sharp will be joining us as residents in June.

If you’d like to work with Andreas, Sarah, or Jamey, there’s still time to apply to the Summer 1 batch of RC (though the batch is currently full, you may join the waitlist if you are admitted). And remember to keep an eye on our blog for more 2016 resident announcements!


Andreas Fuchs works on the infrastructure team at Stripe, building the systems that other developers use to build payment systems for the Internet. Before starting at Stripe, Andreas was a member of various Common Lisp open source projects, worked on an extremely scalable (and weird!) RDF graph database, and for a while even maintained a decades-old Motif-based GUI framework that was derived from code originally written for Symbolics lisp machines. For as long as he has used computers, his goal was to make it as efficient as possible to waste his own time, and so is constantly working on a grand system orchestration or automation idea. In his spare time, you can find Andreas performing terrible wordplay and learning to play the hurdy-gurdy. Andreas will be in residence from  6/6 - 6/9 (Spring 2 and Summer 1 batches).


Sarah Sharp is a Linux and open source developer, with an interest in hardware and increasing diversity in tech. Sarah graduated with a B.S. in Computer Engineering from Portland State University, and she has been running Debian-based Linux systems since 2003. Sarah wrote the Linux USB 3.0 host controller driver, and was a Linux kernel maintainer for five years. She has also tinkered with Arduinos, real-time operating systems (RTOSes), and she loves to play around with open hardware. Sarah’s favorite open source tools include Darktable (raw photo editor), KDEnlive (video editor), and Inkscape (vector drawing). She frequently uses (but only tolerates) git, libreoffice, and many different Linux command line tools. Sarah is an expert with C, but has also written code in Python, Java, C++, and shell scripts.

Sarah also loves to make fan videos, write blog posts and tutorials, do amateur photography, garden, and bicycle. Sarah is happy to share knowledge, and would love to give tips on creating tech presentations and promoting yourself in the open source community. Sarah is a co-coordinator for Outreachy, a 3-month paid internship program to connect people traditionally underrepresented in tech with open source mentors. Sarah will be in residence from 6/13 - 6/22  (Spring 2 and Summer 1 batches).


Jamey Sharp enjoys learning anything he can about everything from CPU architecture to functional programming, and from real-time embedded systems to web development to control theory and combinatorial search algorithms. But just learning about computer science isn’t as much fun without getting to share it with other people! Jamey has been mentoring people since his undergrad days working on his B.Sc. in Computer Science at Portland State University, which he completed in 2006. Over the past several years he has sponsored over a dozen different six-month software engineering capstone projects, helping students work in code bases including the Linux kernel and the X Window System, as well as quite a few Python projects.

Professionally, Jamey’s career began with web development in Java and Perl during the dot-com boom; proceeded into systems programming in C while creating XCB, a client library for the X Window System network protocol; software product architecture for a computer test for ADHD with components in Java, C, and Python and spanning desktop, web, kernel, and bootloader code; Comic Rocket, a site for helping webcomic readers keep up with their favorites and discover new comics, in Haskell and Python; and most recently, high-assurance software development at Galois, in Haskell, C, and Java. He’s eager to try Mozilla’s new Rust programming language on his upcoming projects. Jamey will be in residence from  6/13 - 6/22  (Spring 2 and Summer 1 batches).


We’d like to thank Perka for sponsoring $10,000 in Recurse Center diversity grants, and enabling more wonderful programmers to spend a batch at RC.

Perka has been a Recurse Center hiring partner since 2013, and this is the second round of grants they’ve provided for Recursers.

The Recurse Center remains free for everyone; we offer grants of $500 - $7,000 to folks from groups that are underrepresented in programming to help cover living expenses.Since 2012 we’ve disbursed over $1 million in grants to Recursers, and diversity at the Recurse Center has improved dramatically.

If you’d like to join the best community of programmers in the world, apply to do a batch of RC.


Five years ago today, six brave souls entered a small NYU classroom for the start of a so-called “writers’ retreat for programmers.”

The whole thing likely seemed as improbable to them as it did to those of us organizing it: A group of people coming together just to learn and code with each other, full-time, without teachers, grades, or a curriculum.

We’ve grown in many measurable ways since that first batch in 2011: We’ve programmed with over 800 exceptional folks who traveled to RC from more than 40 countries. We’ve helped hundreds of new and experienced programmers find jobs. We’ve launched new experiments including a residents program, a programming journal, a research lab, and free mentorship for new programmers.

But it’s the harder to measure things – seeing people finally see themselves as programmers, accomplish things they could never have done before, and change how they treat themselves and others – that make us really proud.

In general, we prefer to focus on how we can improve RC. Today, however, we’d like to take a look back and thank our community. So, thank you to those first six Recursers and the hundreds since who took a chance on us, and who have made RC what it is today.

Founded in 2011, the Recurse Center is a free, self-directed, educational retreat for people who want to get better at programming, whether they’ve been coding for three decades or three months. The retreat is free for everyone, and offers need-based living-expense grants up to $7,000 to women and people from groups traditionally underrepresented in programming. The retreat is funded exclusively through recruiting partnerships.


Here’s a fun idea in case you want to practice reading code and using Emacs:
read Emacs in Emacs!

Emacs makes it easy to see the code behind its commands. For instance, if you
want to see how a particular command-key sequence works, type C-h k and
then the key sequence into the modeline prompt.

If you’re curious how C-h k itself works, type C-h k C-h k. According to
the *Help* buffer that appears, C-h k corresponds to the Emacs Lisp
function describe-key defined in help.el. Move your cursor onto the
help.el text in the Help buffer and press enter. You’re now looking at the
Emacs Lisp source for describe-key.

If you’d like to see how a particular Emacs Lisp function or special form
works, type C-h f and then the name of the function or special form.

Perhaps you’re curious how lambda works: type C-h f lambda and then hit
enter. Another *Help* buffer will appear, saying that “lambda is a Lisp macro
in subr.el”. As before, place your cursor inside subr.el and then press
enter; Emacs will transport you right to the definition of lambda.

Emacs isn’t Emacs Lisp all the way down, though. For instance, addition is
presumably defined in C. C-f + confirms this, noting that “+ is a built-in
function defined in data.c”. If you move your cursor over data.c and press
enter, Emacs will probably prompt you at the modeline for the location of your
Emacs C source directory; it’s likely that when you installed Emacs, you only
downloaded pre-compiled binaries. You can find source corresponding to your
version of Emacs here. Once you tell Emacs
where to look, you can hop into Emacs’s C source code, too.

It’s fun to guess whether a particular function or special form is defined in
Emacs Lisp or C. The answer can also change between versions of Emacs. For
example, until quite recently, the special form for defining a new Emacs Lisp
function, defun, was defined in C. If you’re unfamiliar with Lisp, you might
wonder how it could be otherwise! But according to my *Help* buffer in Emacs
24.3.50.1, “defun is a Lisp macro defined in byte-run.el”.

The exuberant comment above defun‘s definition in byte-run.el is worth
reinstalling Emacs from trunk: “Now that we defined defmacro we can use it!”.
Bootstrapping defun is now the very first use of defmacro in all of Emacs.
If you’re curious where defmacro comes from, you know what to do :)


We’ve decided to pause work on our research lab.
Michael Nielsen, our first research fellow, has
finished his one-year fellowship at RC and is moving across the country to
continue his work at YC Research.

We’re not hiring another research fellow right now. We’d like to restart RC
Research at some point, but we think that the most important next step in
building a successful research lab would be to hire multiple researchers at the
same time, something we can’t currently afford. We’ve learned a ton in the past
year about building a research lab from scratch which we’ll write about once
we’ve had more time to reflect.

Working with Michael has been wonderful. We’ll miss having him around RC, but
we can’t think of a better place for him to go next than YCR, and we’re excited
that he’s going to be continuing the research that he worked on here. Sam
Altman and the rest of the folks at YC have been incredibly supportive of RC
over the years, including helping us when we decided to start RC Research, and
we’re thrilled that they’re going to get to work with Michael.


TL;DR: The first three pieces from the seventh issue of Code Words, our quarterly publication about programming, are now online!

You may notice that we’re quite late with this issue, based on our original quarterly schedule. With Issue Four we started publishing Code Words piece by piece, in order to have more scheduling flexibility. Earlier this year we found ourselves in a bit of a schedule crunch, and so we postponed Issue Seven to the next quarter. And here we are in October, finally publishing!

We’ve learned a lot during the process of publishing Code Words. It is produced entirely by Recursers and RC faculty, and while it’s a time-intensive project, it’s also no one’s full-time job. We’d like to keep publishing it, and for future issues we’re going to be making changes to the way we manage it internally. We’ll also be experimenting with a continuous, rather than quarterly, publication schedule.

Until then, check out the articles in Issue Seven below! We’ll be updating this post as more articles are published.

Issue Seven will feature writing from Serena Peruzzo (RC Spring 1, 2015), Miles Blackwood (RC Fall 2, 2015), Kiran Bhattaram (RC Summer 2, 2016), Nathan Epstein (RC Spring 1, 2016), and Darius Bacon (RC Fall 2, 2015 & Fall 2012). In addition to all of the writers, we’d like to thank Barak Chamo (RC Fall 1, 2015), Robert Lord (RC Winter 2014), and Alex Wilson (RC Summer 2013) for all their careful editing and help.

Code Words is written and edited by the Recurse Center community. Like RC itself, we aim to make Code Words accessible and useful to both new and seasoned programmers, and to share the joyful approach to programming and learning that typifies Recursers. Code Words contributors retain the rights to their work, and provide their essays under the terms of the Creative Commons BY-NC-SA 4.0 license.

If you’d like to receive updates about new issues and news about the Recurse Center, sign up for our mailing list.


The core of the Recurse Center is the community, and the core of our online community is Zulip, the open source real-time chat system.1

We started using Zulip four years ago this month. Our original reasons for adopting it were straightforward: We wanted a private chat system that was persistent, easily searchable, and which supported syntax highlighting for code snippets. We also wanted full names and profile pictures to make it easier for people in our community to find each other, both online and in real life.

Zulip gave us all the benefits above, along with a slew of others we hadn’t expected. Switching to Zulip has turned out to be one of the best decisions we’ve made, and it’s impossible to imagine RC today without it.

One challenge is that it’s become increasingly hard to explain how RC works to potential applicants, since we’ve chosen to have a private Zulip server and so a lot of RC isn’t publicly accessible. This post aims to share an important part of RC that’s previously been nearly impossible to learn about without attending.

RC is an educational institution with an integrated recruiting agency.2 We run full-time, in-person programming retreats in New York City. People come from around the world to spend six or twelve weeks programming together in a self-directed, collaborative, and supportive environment. The primary educational value comes from the participants themselves: It is peer-to-peer, which is why RC gets better as the community becomes larger and more diverse.

While our retreats are in-person, online chat is a major part of RC. Participants use Zulip to ask and answer questions, get code review, and coordinate pairing sessions, reading groups, informal seminars, and countless other forms of collaboration. Zulip is even more essential for our alumni, who are in over 100 cities around the world but remain heavily involved thanks to Zulip.

We have a Zulip instance (called a “realm”) with approximately 1,000 members, who send 1,000-2,000 messages on any given weekday. For those not familiar with it, Zulip uses a system of streams (think channels) and topics (think threads). For instance, we have a graphics stream, and recent topics include “OpenGL objects as process resources?” and “Three.js shaders.”

Many of our streams are dedicated to specific subjects. We have streams for programming languages (e.g., python), tools (e.g., git), and domains (e.g., machine learning). But many of the most significant and widely used streams at RC don’t fall into one of those categories, and so I’d like to focus this post on them.

Every day at 12:30am GMT, a bot called “Alumni Bot” starts a new topic for that day’s checkins. As past Recursers and residents around the world start their days, many chime in with updates about what they’re working on.


Many alumni post daily updates on our alumni-checkins stream. Laura is currently stationed in Antarctica. Shared with permission.

Like many of the best parts of RC, alumni-checkins was started by a Recurser. The stream has been so successful that we created a similar stream for current Recursers. We now have a checkins stream where people currently attending RC can share what they’re working on, what they’re stuck with, what they did the day before, etc. Here’s an example:


Some Recursers choose to post daily checkins to keep themselves on track, find collaborators, and get help. Shared with permission.

This stream is for getting feedback on writing. It’s most commonly used for drafts of blog posts, but it’s also used for conference proposals, talks, papers, and resumes. This stream works remarkably well, and nearly everyone who asks for it gets helpful review and feedback.


Recursers give each other constructive feedback on the writing review stream. This request got feedback in under 30 minutes. Shared with permission.

This stream is powered by a blog aggregator (created by Recursers and appropriately named Blaggregator), which automatically posts links when Recursers who have opted-in post new blog posts. Each post gets linked under a new topic, which makes for easy, filterable discussion.


Recursers have built a bot to automatically share new posts from the community. Shared with permission.

The RSVPs stream is monitored by RSVPBot, an open source bot (authored by an RC alum) that supports creating and RSVPing to events. It also integrates with our Google Calendar, and it can be used to ping everyone attending an event when the event’s about to start.


A Recurser uses RSVPBot to set up a new event. Shared with permission.

This stream is dedicated to sharing our victories, from “my pull request was accepted” to “I finally figured out this bug” to “I’m having a baby!”


Recursers share personal successes on our Victory stream. Shared with permission.

We also have non-default, opt-in streams like politics. Our community is focused on programming and becoming better programmers. But Recursers establish close bonds with each other and have wildly diverse interests beyond programming. Naturally, people want to discuss lots of non-programming things, some of which can be contentious or just distracting to others. To accommodate this without detracting from our primary goal (making a great place to become a better programmer), we have opt-in streams, like politics.

This post was challenging to write because I could only highlight a few of the tens of thousands of messages Recursers exchange each month, and which comprise our online community. Furthermore, like all of RC, both the Zulip software and how RC uses Zulip are constantly changing and far from perfect. There are lots of things we’d like to improve or try, from better integrating Zulip with the rest of RC’s internal software to introducing moderators.

We plan to write more about those things, hopefully before another four years pass.

You can read about Zulip’s open sourcing and RC’s involvement here.↩


RC is free to attend, and people are welcome regardless of if they’re interested in new jobs (in fact, our admissions process explicitly ignores whether people want or can get a job in the US).

For people who are interested in new programming jobs, either immediately after RC or years later, we offer a range of recruiting services from individual counseling to interview prep to negotiation advice.↩



We’re building a new kind of learning environment: One with immense collaboration but no coercion, and diverse participants but a common purpose of becoming better programmers. We’re building a place to realize the ideas of Holt, Illich, and Papert.

Want to help? If you’re new to RC, read on to learn about the role of facilitators and if this might be a good fit for you. If you’re a member of the RC community, read on because this job is probably not what you think it is.1

RC is a radically self-directed educational retreat integrated with a recruiting agency. The primary educational value of RC comes from Recursers themselves: RC is peer-to-peer, which is why it gets better as the community becomes larger and more diverse. RC is self-directed because we believe that education is (to quote John Holt) “the product of the activity of the learner,” and that people learn most effectively when they are in control of and have responsibility for their own education.

Experienced and new programmers come to RC from around the world to spend six or twelve weeks in New York focused on getting better at programming. Afterwards, alumni remain highly involved in the community, both offline and online.

RC is funded through recruiting fees paid by partner companies when they hire alumni we refer to them. This allows us to keep RC free for everyone, and to fund need-based living expense grants for people from groups traditionally underrepresented in technology. There is no expectation or requirement that people who attend the retreat want or take a new job.

The job of facilitators is to improve the environment, structure, and operations of RC. This includes both the experience of participating in our retreat and of being an alum, and both the educational and career services aspects of our business.

Much of this work can be thought of it in terms of questions we try to answer: How can we establish a stronger culture of peer code review and feedback? How can we make it easier for people to find good pairing partners and collaborators in the RC community? How can we help Recursers tackle more challenging and ambitious projects? How can we better support people in learning how to navigate a self-directed environment? How can we maintain and improve the cohesion and trust in our community as it continues to grow? How can we more effectively support people in finding jobs they like? How can we change our physical and social environment to better support both collaboration and quiet, individual work?

Answering these questions and changing RC in response to them requires wearing many hats, from writing to programming to building furniture to project management. It also involves both working independently and collaborating closely with other RC employees and members of our community.

Every job has downsides, and this one is no exception. People usually learn about these things after they join a company, but we think it’s important to highlight them in advance:

Thankfully, we think this job has many more good things going for it:

Lastly, it’s important that you share our core beliefs about education. Dissent and skepticism are great, but if we don’t all agree on enough of the big things we’ll never get anything done.

After each stage we’ll let you know whether or not we’d like to continue as quickly as possible (our goal is within two business days). If you’re advancing to the next stage, we may also give you feedback about what we thought you did well and what you could improve on for the next round.

Some historical context for the curious: RC previously had a role called “facilitator” that was very different from the job we now call “facilitator.” The old role was primarily about giving individual advice, pair programming, and doing code reviews for people.↩


Each May we invite the entire Recurse Center community to return to New York City for Never Graduate Week: five days of programming, socializing, and reconnecting with their batchmates and community. This year over 200 Recursers joined us. They represented all 33 past batches of RC, and traveled here from over a dozen countries and forty different cities.

Our community grows by nearly 250 people a year, and so every NGW is bigger than the last. We realized last year that it would be impossible to fit everyone who wanted to attend in our main space without it feeling like a can of computer-adept sardines. Our primary goal became to find a way we could accommodate as many folks as possible during NGW, and which was scalable for subsequent years. A secondary goal was to host an event in which everyone who attended both learned something and taught someone something.

What we ultimately wound up doing was a major departure from Never Graduate Weeks past: we ran a small unconference-conference hybrid for the RC Community, replete with badges, talks, and several livestreams. All of these pieces came together in such a way that we didn’t fully realize (or admit to ourselves) that we were indeed planning a conference until we were nearly finished. And, largely thanks to it being rooted in a wonderful community, it went pretty well!



We had over 200 folks attend this year’s NGW. Not counting our labor, it cost us just under $19,500 in space, food, drinks, and giveaways (we made hoodies, custom Scoutbooks, lanyards, and hand screen-printed social rules posters).

We didn’t charge folks to attend, but we also had some advantages over traditional conferences: namely a built-in crew of organizers (mainly Sonali Sridhar, James Porter, and me), one big space, and pool of speakers we knew well and could reach out to, rather than having to solicit proposals. We also didn’t have to deal with heavy-duty registration or check-ins – Nick made a quick RSVP page for our site and we were good to go. All of this saved us time and money.

However, we also only had one sponsor: Squarespace, one of our recruiting partners, hosted an awesome end-of-week party for us at their offices, and sent five of their engineers to do a panel discussion during the conference.

There were three spaces open to folks during the week: our main space, a satellite space, and a smaller quiet space for folks who wanted a quiet spot to rest or program. All of these were within a few blocks of each other.

Our main space was where everyone gathered for the welcome talk and breakfast, the closing talk, the unconference events, Thursday presentations, and our afterparty.

Our satellite space was open from Monday - Wednesday, and was where we held the conference-style talks, workshops, and panels.

We hosted seven talks, two workshops, and two panels at Blank Studio in SoHo:

We wanted the scheduled talks to represent the diversity of interests and individuals within our community. Half (9 of 18) of our speakers and panelists were women, and nearly half (8 of 18) were people of color.

Unconferences are participant-organized conferences in which sessions are planned somewhat spontaneously, and are focused on encouraging conversation rather than one person sharing knowledge. There’s no program – attendees register interest in hosting and attending sessions in a central spot as the conference is in session.

We made an unconference wall in our main space, and invited people to post events they’d like to host on it on Tuesday and Wednesday of Never Graduate Week. There were 24 unconference sessions hosted, including a talk on coding with fear, a discussion of great bug stories, a talk and discussion about working for small non-profits, a discussion of computers and DNA sequencing, and a much-needed library reorganization.

We were particularly excited to do an unconference during Never Graduate Week because it echoes the way talks and workshops are organized at RC: nearly everything that happens at RC, from book clubs to code review groups, is initiated and organized by Recursers themselves.



Finally, in a fit of circular inspiration from !!Con, we decided to fill Thursday with a full day of 5 and 10 minute talks from alums in the style of our weekly Thursday evening presentations.

We filled every spot but one! Alums gave 24 presentations. A few choice titles:

Two important aspects of Never Graduate Week are that it allows folks to reconnect with people who were in their batch, and it allows folks who have never met one another (in person or at all) to meet and work together. We chose, by hand, two to three people we thought folks should talk to based on their interests, and sent them to everyone who attended NGW in person the weekend before they arrived. We also hosted a bunch of social events throughout the week, including a Game Night and a picnic.


Much of the work of facilitating social interactions is providing a good substrate and scaffolding rather than micromanaging people and events. We view the RC community as more of a biological system than a machine: if we give people a good environment that’s diverse and balanced, they’ll flourish.

It’s also helpful to have a lot of alumns who are fantastic DJs floating around – one of them, Marko Stamenovic, F2'16, provided the soundtrack to our afterparty, to great acclaim.

Lots of alums can’t travel to New York for Never Gradute Week, and we wanted to include them as much as possible. We livestreamed our opening and closing talks, all of the talks in our satellite space, and all of the unconference events in two of our side rooms in the main space, Lovelace and Hopper. While it wasn’t perfect, nothing exploded, which we’ll count as a win. We also had streams dedicated to discussion of topics we covered in roundtable discussions. We also sponsored alum meet up dinners in London and San Francisco for the folks who couldn’t make it this year.

Never Graduate Week will continue to get bigger as RC grows. I view attendance and interest in NGW as a measure of the health of our community: the more folks who want to attend, the better we’re doing. That means that we’ll be planning for an NGW with more space, more participants, and more fun social and technical events in 2018!


We’re hiring a Product Engineer to help us build useful tools for RC’s operations and community. This is an opportunity to have a meaningful impact on a small number of people.

Read on to learn more about RC, the software we write, the good and bad parts of this job, and our interview process.

RC is a radically self-directed educational retreat integrated with a recruiting agency. The primary educational value of RC comes from Recursers themselves: RC is peer-to-peer, which is why it gets better as the community becomes larger and more diverse. RC is self-directed because we believe that education is “the product of the activity of the learner” (to quote John Holt), and that people learn most effectively when they are in control of and have responsibility for their own education.

Experienced and new programmers come to RC from around the world to spend six or twelve weeks in New York focused on getting better at programming. Afterwards, alumni remain highly involved in the community, both offline and online.

RC is funded through recruiting fees paid by partner companies when they hire alumni we refer to them. This allows us to keep RC free for everyone, and to fund need-based living expense grants for people from groups traditionally underrepresented in technology. There is no expectation or requirement that people who attend the retreat want or take a new job.

This is a full-time job based in New York City. It is a “full-stack” role, by which we mean it involves writing backend code (primarily with Ruby and Rails), using and designing data models (primarily in Postgres), writing lots of JavaScript (primarily using ES6, React, and Redux), and writing HTML and CSS (primarily using Sass and following BEM). In addition to writing software, this job also involves helping to figure out how it should work and if we should even build it in the first place.

From looking at our public website, it might not seem like we write or have much need for software. In fact, software is essential to many aspects of RC. Here are the three biggest areas to give you a sense of the type of software we write.

Software for our community

We have an internal directory where Recursers can browse and search for other members of the community, a collaborative calendar where anyone can organize or join events, and an open source web forum and mailing list (the latter has not seen much attention recently). We’ve also built a simple proxy so our community can easily create recurse.com subdomains. We use Zulip, the open source chat system, extensively, though RC employees have not yet contributed to it significantly (one thing we’d love to do is integrate with Zulip for single sign-on and shared user profiles).

Advertising and admissions software

We’ve built a simple “ad network” called RC Scout, which lets Recursers put a JavaScript snippet on their blogs and personal websites to advertise RC to potential applicants. (You can see a live example at the bottom of this blog post.)

We have a team of RC alumni who work as contractors and conduct all our admissions interviews. We have custom software for every part of this process, including interview scheduling, payment tracking, and application management (commenting, grading, and updating the status of an application). Software also lets us form our initial impressions during application review based off pseudonyms instead of real names which reveal demographic information (e.g., “Dolphin Storm” instead of “Kimberly Lin”).

(Our applicant-facing admissions software is sorely lacking. The take-home project mentioned below will be about this.)

Software for our business

The most extensive tools we’ve built so far have been for our recruiting business. Our core product for this is called Jobs Chat, a dashboard where people considering new jobs can organize their interview process and chat confidentially with RC faculty. It’s threaded by company and lets job seekers and faculty collaboratively schedule interviews, update where folks are in the process, and organize companies into groups. The admin interface for Jobs Chat lets RC help dozens of Recursers navigate their job searches simultaneously. This would be impossible without our software. Jobs Chat integrates with Asana (for task management) and Gmail, with an indispensable email composer and linter.

Every job has downsides, and this one is no exception. People usually learn about these things after they join a company, but we think it’s important to highlight them in advance:

Thankfully, we think this job has many more good things going for it:

Lastly, it’s important that you share our core beliefs about education. Dissent and skepticism are great, but if we don’t all agree on enough of the big things we’ll never get anything done.

We know the things above aren’t required to hire great people. RC’s current Product Engineer does not have a degree (he dropped out of a political science program), applied to RC with no previous connections, and did not have professional experience when we hired him. He is the most productive and enjoyable programmer we’ve ever worked with. He’s moving on to new things later this summer after working at RC for five years, and he has contributed to our company in more ways than we could possibly list.

After each stage we’ll let you know whether or not we’d like to continue as quickly as possible (our goal is within one or two business days). If you’re advancing to the next stage, we may also give you feedback about what we thought you did well and what you could improve on for the next round.


Dear current Recursers, alumni, colleagues, and friends,

Six years ago today was the start of the first batch of the Recurse Center. Since then, RC has both changed dramatically and remained strikingly similar. Many of the changes are easy to spot: We’ve grown from three people with an idea to a global network of over 1,000 alumni; moved from a small room donated by NYU to our own dedicated space; and gone from not having a website to a thriving online community.

The core ideas that animate RC — that self-direction is integral to real growth; that a supportive environment and community are key to helping people flourish; and that you can make such a community free and accessible through recruiting — remain the same, though our understanding of these ideas continues to evolve.

Of course, our path so far has not been smooth, straight, or fully planned. We’ve made many mistakes. And we’d be lying if we said we never wanted to give up on RC. Each of us has wanted to quit when we were feeling particularly down, or our situation felt grim.

But again and again two things above all else have sustained us: A conviction that RC should exist, and the people around us — our community, colleagues, and each other.

The latter — most notably the RC community and our employees — has proven to be an unexpectedly rewarding part of running RC. We have all formed close friendships with Recursers, and been inspired and re-inspired by the dedication, ingenuity, support, and love so many of you have demonstrated over the years.

Thank you for helping make RC what it is today; RC could not exist without you. We hope to have the pleasure of improving RC alongside you for many years to come.

Never graduate,

Nick, Sonali, and Dave
RC cofounders


We’re excited to announce Localhost, a monthly NYC-based series of free public technical talks from members of the Recurse Center community.

Our first speaker will be RC alum Dan Luu, who will be giving a talk about branch prediction on August 22nd from 7 pm - 9 pm at the Two Sigma Ventures offices.

You can RSVP, read the abstract, and find more details about the venue and timing on the talk’s RSVP page.

Localhost talks will be 20–30 minutes long, and will be followed by a dedicated Q&A session. There will be a two-minute break after the talk if folks wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks will be open to the public! We’re setting aside fixed numbers of seats for folks who aren’t members of our community at every talk. This is a first for us, and we’re excited to get to meet more programmers at our events. 

We know that attending a batch of RC requires a large time commitment, and hope that Localhost talks will be a great way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

When possible we’ll stream and record these talks for folks who can’t make it to them and alums who are outside of NYC. We’ll post confirmation of whether or not we’re streaming a talk and a link to the stream on the Localhost page.

We currently have three more talks planned for this year:

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open for future talks!

Special thanks to our first host, Two Sigma Ventures! TSV invests patient financial capital and expert human capital in ambitious early-stage entrepreneurs leveraging data science and engineering to create the future.

All guests of Recurse Center events are required to abide by our
code of conduct.


We’re excited to announce our second Localhost talk. Localhost is a series of monthly, NYC-based, free public technical talks from members of the Recurse Center community.

Our speaker will be former RC resident r0ml, who will be giving a talk on September 26th from 7 pm - 9 pm at Etsy, about how he brought down Morgan Stanley’s network in 1984.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 20–30 minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public! We’re setting aside a fixed number of seats for folks who aren’t members of our community at every talk. This is new for us, and we’re excited to get to meet more programmers at our events.

We know that attending a batch of RC requires a large time commitment, and hope that Localhost talks will be a great way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

We currently have three more talks planned for this year:

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open for future talks!

All guests of Recurse Center events are required to abide by our
code of conduct.


We’re excited to announce our third Localhost talk! Localhost is a series of monthly, NYC-based, free public technical talks from members of the Recurse Center community.

Our speaker is Ron Minsky, who will be giving a talk on October 24th from 6:30 pm — 8:30 pm at Jane Street about the practical role that type systems play in software development.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 20–30 minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public! We’re setting aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our first two Localhost talks!

We know that attending a batch of RC requires a large time commitment, and hope that Localhost talks will be a great way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

We currently have two more talks planned for this year:

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open for future talks!

All guests of Recurse Center events are required to abide by our
code of conduct.


What do you think of when you hear the word “hacker?” If you’re like many people, you think of a 20-something white guy hunched over his computer, intently working alone at 4am, surrounded by darkness and empty soda cans.

That’s the popular culture view of a hacker, but that’s not at all what we want in potential Hacker Schoolers. Here’s what we mean by the word “hacker”:

Someone who is intellectually curious. Hackers enjoy tinkering and understanding how things work. They revel in going deeper into things, and love asking questions: How can I make my code easier to debug? What is making my program slow? How does this work?

Someone who enjoys programming. We spend most of our time at Hacker School programming, there aren’t grades or tests to make you study, and you don’t get a degree or certificate for doing Hacker School, so it’s important that you like coding.

We used to say applicants must “love” programming, but we’ve learned that was a mistake. While it sounds good, it doesn’t actually describe what we care about, and it was dissuading qualified people from applying.

In fact, many of our best students have said they almost didn’t apply because they worried they didn’t love programming enough. Hacker School alum David Peter expressed this fear perfectly:

One of the questions in the interview was, “Do you love programming?” I said yes, because I loved it more than most people I knew. But was it love? I enjoyed writing and drawing equally, if not more. After Hacker School, I’m revisiting these hobbies. Programming wasn’t my first love.“

(You should read David’s entire post if you haven’t already. It’s moving.)

In reality, we just want people who enjoy programming, and who are serious about improving in a focused way. You should like programming enough that the prospect of spending three months getting better at it sounds like fun and not a chore.

If you like feeling your brain stretch as you understand a new concept, or take pride in making your code more concise and elegant, or delight in building things, you’re probably a good fit for Hacker School.

Someone who enjoys sharing what she learns with others. The most respected hackers are those who have built or discovered great things and shared them with the world. At Hacker School, everyone writes free and open source software, and everyone both learns from and teaches everyone else.

Someone who is friendly and communicates well. This is especially important for Hacker School, since we spend three months working closely together. If you can’t communicate effectively, it’s both hard to ask for help and to help others.

You don’t need to have a lot of programming experience. While not every programmer is in a place where Hacker School makes sense, you don’t need to have started your own open source projects or mastered two programming languages to be an awesome Hacker Schooler. If you’re at the point where you can write simple programs from scratch, you’ve probably got enough experience.

The lower bound for experience for students who have successfully done Hacker School seems to be about two months. That is, we’ve had exceptional students who have come to Hacker School with as little as two months of programming experience and who have done enormously well. We don’t think there’s an upper bound for experience.

You don’t need to only care about programming. If you thought Hacker School wasn’t for you because you don’t spend all your time programming, don’t worry. While all Hacker Schoolers enjoy programming, we also like lots of other things, from ballroom dancing to dumpling tours. You don’t need to be single-mindedly obsessed with programming to excel at Hacker School.

You don’t need to have the superficial trappings commonly associated with hackers. None of that stuff matters at Hacker School. The factors that determine if people are good Hacker Schoolers have nothing to do with how they look or other superficial attributes, and everything to do with being a thoughtful, curious person who enjoys programming and wants to focus on improving.

If you enjoy programming and want to spend three, focused months getting better in a diverse and supportive environment, we want you at Hacker School.


We’re excited to announce our fourth Localhost talk! Localhost is a series of monthly, NYC-based, free public technical talks from members of the Recurse Center community.

Our speaker is Leah Hanson, an RC alum who will be giving a talk on November 14th from 7:00 pm–9:00 pm at Dropbox about WebSockets.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 20–30 minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public! We’re setting aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC requires a large time commitment, and hope that Localhost talks will be a great way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

We currently have one more talk planned for this year (David Nolen will be speaking on December 12th), and are working on a schedule for 2018!

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open for future talks!

All guests of Recurse Center events are required to abide by our
code of conduct.


Update: This experiment was a success! We’ve decided to run more week-long mini retreats in the future, check out this blog post from 1/26/18 for more details.

We’re excited to announce a new experiment at RC: one-week mini retreats!

This winter, we’ll be running two one-week mini retreats at RC. They will overlap with the fall and winter batches, and will be just like the six- and 12-week retreats we run, with the same goals and structure, but shorter.

The first mini retreat will be open exclusively to RC alums, and will run from Monday, December 4th through Friday, December 8th. The second will be open to anyone and will run from Monday, January 8th through Friday, January 12th (coinciding with the first week of the Winter 2 batch).

We don’t know if we’ll host more one-week retreats in the future, so this may be a unique opportunity to join the RC community. If you’ve been interested in RC, but have been struggling to figure out how six or 12 weeks in NYC could fit into your schedule, please apply!

We believe that the community is the most important part of RC, because the primary educational value of RC comes from what Recursers learn from each other. Most of the time that people spend involved with RC is not at the retreat, but in the community as alums, and so we are always looking for ways to make the community even better.

The RC community gets better as it gets bigger and more diverse, and we think mini retreats will help on both fronts. A larger and more diverse RC community means more interesting events and discussions, more people with different backgrounds and experiences to learn from, and a better chance of finding people to collaborate with. There are great people who can’t or won’t do a six- or 12-week batch (for example, due to family or work obligations), but who we would love to have in the RC community. One week mini retreats give us an opportunity to bring some of those people in and enrich RC.

The biggest challenge with mini retreats is that a week isn’t a lot of time for focused, deep work. We’re working on structuring the mini retreats so that everyone can get acclimated and hit the ground running.

There are things you should do too:

Because one week is so short, we expect you to commit to spending the full week at RC.

Like many things at RC, mini retreats are an experiment. We’re excited to see how they go, and we’ll be collecting feedback after both retreats to figure out whether we should run more in the future.

The process for applying to a mini retreat is the same as applying to a six- or 12-week retreat. Make sure to choose Mini 1, 2017 (this is only open to, and will only appear to, RC alums) or Mini 1, 2018 from the batch selection drop-down on your application.

Mini retreats have a higher admissions standard than our regular batches. We’re using the same admissions criteria—we’re looking for people who are self-directed, intellectually curious, friendly, sharp, enjoy programming and want to get dramatically better—but we’ll only admit applicants who show us clear, positive signals on each of these. Specifically, we’re looking for people who have thought about and have promising plans for how to make the most of their short time at RC (see “How will it work?” above).

Normally we can take chances on people and admit them even if we’re not sure they meet all our criteria. Since no admissions process is perfect, this lets us get great people at RC who we might otherwise miss. However, because trying new things is inherently risky and because one week is very little time to get focused and productive, we’re not taking those chances for mini retreats.

As usual, admissions for these batches will be first come first served, and space is limited, so apply soon. We’re looking forward to seeing your application and welcoming you into the RC community!


We’re excited to announce our fifth Localhost talk! Localhost is a series of monthly, NYC-based, free public technical talks from members of the Recurse Center community.

Our speaker is David Nolen, a former RC resident who will be giving a talk about the fundamental principles of software on December 12th from 7:00 pm–9:00 pm at Peloton.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 20–30 minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public! We’re setting aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC requires a large time commitment, and hope that Localhost talks will be a great way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

We are working on a schedule of Localhost talks for 2018. Stay tuned!

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open for future talks!

All guests of Recurse Center events are required to abide by our
code of conduct.


Earlier this month, 12 Recurse Center alums met in Berlin to work on generative art in a two-week sprint, which we called an “RC Pop-up.”

One of our goals is to support our alums in becoming better programmers wherever in the world they are. At its core, RC brings together people for intensive periods of personal and professional growth. During a batch, we provide a supportive and collaborative environment, space and time to focus, access to wonderful peers, and the freedom to explore what you’re interested in. While we host lots of social and technical events for alums in New York City, most of the 1,100 members of the RC community live elsewhere.

Many Recursers unsurprisingly report that their learning slows after their batches. Though alums are always welcome to re-apply to do another batch of RC, most don’t have the time or resources to do so. Our goal is to provide more opportunities for continued growth and support for our alums all over the world.

With that in mind, we came up with an experiment we thought would help us do that: a two-week RC Pop-up in a place other than New York City, where alums could recreate the intensity of a full RC retreat. We wanted the Pop-up to give folks a chance to get feedback and push each other to accomplish more than they would have alone.

We were inspired by Depth Jams, events in which people doing similar creative work commit to brief, intense, periods of working together and giving each other advice and critical feedback away from everyday distractions. We have lots of alums interested in graphics and computer art who live in and around Berlin, and given the vibrant community of artists and programmers who live there, we decided it was a good place to start. The School of Machines, Making, and Make Believe hosted us for the two weeks.

 Vanessa Pyne, Moshpyt, FFmpeg

The Pop-up was different than the retreats we run in several ways:

We’re currently evaluating whether or not we’ll organize more Pop-ups in the future, and we are always looking for more ways to support our community’s continued growth.

In the interim, check out the list of participants and some of the work they produced below!

Jonathan Dahan, Glitch, Quil (Clojure)

 Sher Minn Chong, Glyph poster series, p5.js

Veit Heller, Reprise, p5.js

A special thank you to The School of MA and our alums for making our first Pop-up a success!


In 2017 the RC community grew to include more than 1,100 programmers from all over the world.

We asked our community to share things they were proud of having done last year, and received an impressive range of responses. Recursers launched companies, wrote books, gave talks, organized communities and conferences, published research papers, created tools that bettered people’s lives, wrote build tools and microkernels, made games, did some top-notch trolling, and were on the cover of The New York Times.

There were too many accomplishments for us to list in a reasonably-sized blog post, so here’s a selection:

We can’t wait to see what Recursers do in 2018!

Becoming a Recurser means joining a community of people dedicated to learning and becoming better programmers, which can be a major accelerator of growth and productivity during a retreat and beyond. If you’d like to attend a retreat and join the RC community, you should apply to an upcoming batch!


RSVPs for our sixth Localhost talk are now open! Localhost is a series of monthly, NYC-based, free public technical talks from members of the Recurse Center community.

Our speaker is Raph Levien, an RC alum who will be giving a talk about the Xi text editor on January 23rd from 7:00 pm–9:00 pm. Location TBA.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 30-minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public. We’re setting aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC requires a large time commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

Our next few 2018 Localhost talks are scheduled for:

February 27th
March 20th
April 24th


We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open!

All guests of Recurse Center events are required to abide by our
code of conduct.


We’re happy to share that RC now has a cluster of four powerful servers. These machines are freely available to anyone in the RC community to use for their projects, exploration, and research, thanks to the generous sponsorship of Heap.

Our goal is for RC to be the best place to become a better programmer, and having this cluster helps us achieve this by enabling Recursers to do things that would be challenging or impossible with just a laptop.

Our initial cluster has publicly routable IP addresses, 48 cores, 64GB of RAM, 2 GPUs, and 2TB of solid state disk space.



Building this cluster makes RC better by giving Recursers free access to powerful computers, something we haven’t been able to do before. The resources RC has always provided — things like supportive peers and space for focused work — make it a great place to become a better programmer, but there are some kinds of projects that become much easier with access to more powerful computers than just your laptop. This cluster will make it easier for Recursers to learn and work with distributed systems, benchmarking, fuzzing, machine learning, deployment and operations, and lots more.

And like most of RC, this system will be driven by our community. Already, half a dozen Recursers have helped determine how the system should be set up, configured, and implemented. Thanks to their work, it already has automatic cross-cluster network file access and the drivers and software needed for GPU programming.

If you’re already part of the RC community, you can choose a username, add your SSH key, and start using the cluster now.

And if you’re not yet a Recurser, we encourage you to learn more about RC, and consider applying if we sound like a good fit.

We’ve enjoyed a great relationship with Heap since they became an RC recruiting partner in 2015, and dozens of Recursers have praised their thoughtfully designed interview process. We’d like to thank them for sponsoring the cluster, and we’re looking forward to seeing what Recursers build and explore with this new resource.




This winter we held two experimental one-week mini retreats, and we’re pleased to announce that they were a success. Starting April 2nd, we will be hosting a one-week mini retreat every six weeks for the rest of 2018. You can apply for the mini retreats starting in April and May on our apply page.

We believe that the community is the most important part of RC, because the primary educational value of RC comes from what Recursers learn from each other. Our main goal in offering mini retreats is to expand the RC community to make it larger and more diverse. Specifically, we think that there are some amazing people who can’t or won’t come to RC for six or 12 weeks, but who nevertheless would benefit from and contribute to the RC community. The January mini retreat allowed us to welcome 16 new Recursers into our community, and we look forward to expanding the community further through future mini retreats.

Working at RC gave me a much stronger focus on becoming a better programmer. If I was at home, I wouldn’t have felt nearly the same level of inspiration and purpose in my work. - Harry Truong, Mini 1, 2018 & F2, ’15

Another goal of mini retreats is to provide a meaningful opportunity for RC alums to continue to grow as programmers long after their first RC retreat. Some Recursers are able to attend a second or even a third full retreat, but for many it is impossible to commit to another six or 12 weeks at RC. Mini retreats give more alums the opportunity to leverage two of our most important resources: space and community.

The constraint of one week gave me the focus I needed to iterate quickly and make progress quickly without getting sucked down rabbit holes… The environment and the people were wonderful catalysts that kept me going through the week. - Divya Sasidharan, Mini 1, 2018

When planning the first mini retreat, we wondered whether a week was enough time to do significant work. We were blown away by both the quality and quantity of work that mini retreat participants were able to produce. Check out two of the amazing projects that Recursers worked on and blogged about during the Mini 1, 2018 retreat:

I could get unblocked super quickly because the barrier to asking for help was very low and there were tons of knowledgeable people around me. I ended up learning a bunch of other cool stuff I had no intention of learning at the onset of the week by having good conversations where I felt safe saying ‘I don’t know what that is.’ - Thais Laney, Mini 1, 2018

Another problem we had to solve was how to effectively on-board new Recursers into the retreat and still leave them enough time to get programming work done during the week.

Before the retreat, we gave mini retreat attendees early access to our internal communication tools, including Zulip. We also hosted online Q&A sessions with RC faculty and alums, and had an optional welcome dinner the Sunday before the batch started. This allowed participants to meet each other and socialize before the week began, so they could  focus on the retreat during the week.

In our exit survey and interviews, mini retreat participants expressed that they were able to hit the ground running, and found the RC community to be as welcoming and supportive as the participants of longer retreats.

The people and community are incredible.  Everyone is extremely friendly and excited about knowledge in general.  I felt like I could push myself and chat about it and if things failed no one cared and if things went well people were excited.  I also got to see what problems others are working on and have a ton of new ideas to try when I get home :) - Nicolas Bertagnolli, Mini 1, 2018

The RC community gets better as it gets bigger and more diverse. Though it was a small sample size, mini retreat attendees on the whole were more likely to have significant work experience, be older, and be parents than attendees of our full and half retreats. This makes sense — it’s more difficult to take months off if you have major life commitments!

Many mini retreat participants shared that they would have benefitted from more familiarity with RC’s internal tools, more information on how to pair program, and more time after being admitted to RC to settle travel and other logistics before the retreat started. For future mini retreats we plan to open applications earlier, and we’re looking into creating resources that will help new Recursers prepare for their time here before they arrive. We’ll be evaluating how the next few mini retreats go, and will continue to make improvements to them.

One unknown that remains is whether the mini retreat participants will stay engaged in the RC community, and become active alums in the long term. Adding new people to RC only has a sustained positive effect on our community if they continue to collaborate with other RCers, attend events, participate in technical conversations on Zulip, etc. We aren’t ready to commit to hosting mini retreats indefinitely, because we don’t yet know whether mini retreat alums will embrace RC as a lifelong learning community in the same way alums of our regular retreats have. In the fall of 2018, we’ll decide whether to continue hosting mini retreats in 2019.

We still believe that you will get more out of your RC experience if you can spend six or 12 weeks immersing yourself in code at one of our longer retreats. RC is designed to be a place where people can become dramatically better programmers, but that kind of growth can’t happen in just one week. When asked what they would change about the mini retreat experience, many participants said that they wished they could have stayed longer, and are hoping to some day come back to RC to attend a longer retreat.

If you’re interested in RC but can’t make six or 12 weeks in NYC fit into your schedule, attending a one-week mini retreat is a great opportunity to join our vibrant and diverse programming community. Apply today!


RSVPs for our next Localhost talk are now open! Localhost is a series of monthly, NYC-based, free, public technical talks from members of the Recurse Center community.

Our speaker is Julia Evans, an RC alum who will be giving a talk about building a Ruby profiler on February 27th from 7:00 pm–9:00 pm at eBay.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 30-minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public. We’re setting aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC requires a large time commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

Our next two Localhost talks are scheduled for:

March 20th
April 24th


We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open!

All guests of Recurse Center events are required to abide by our
code of conduct.


RSVPs for our next Localhost talk are now open! Localhost is a series of monthly, NYC-based, free, public technical talks from members of the Recurse Center community.

Our speaker is Andrew Kelley, an RC alum who will be giving a talk about Zig, his pragmatic, optimal, safe, and readable new programming language, on March 20th from 7:00 pm–9:00 pm.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 30-minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public. We’re setting aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC requires a large time commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

Our next two Localhost talks are scheduled for:

April 24th
May 15th


We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open!

All guests of Recurse Center events are required to abide by our
code of conduct.


List comprehensions are a syntactic construct that allow you to create
new lists in an elegant and concise way.

Here’s a question, though: If your language did not support list
comprehensions, what would it take to add them? For a language like
Ruby, you may have to dig into the language implementation itself. If
you’re using a Lisp, you can write a macro.

Lisp macros allows you to transform your code at compile time. Macro
calls are run before the rest of your code during a process called
macro expansion. You define macros almost like any other function, except
that the arguments to a macro are unevaluated Lisp code. Because Lisp
code is just data, you can operate on it like any other data.

This is how you can implement list comprehensions in eight lines of
Clojure.

I’ve been thinking about this macro for three days now, and it’s still
terribly exciting to me. It’s the macro I wish I had seen when I was
learning about them. It takes full advantage of Clojure at compile-time
and uses both higher-order functions and recursion.

Let’s see what it can do.

At compile time, it is transformed into code that produces the correct
result. It’s a pretty handy macro. We can see how it works by looking at
some macro expansions.

At its core, list-comp is just a recursive transformation. This is made
obvious by looking at the first macroexpansion of a comprehension with
nested bindings.

If we simply assume that the inner call to list-comp does the right
thing – that is, it successfully binds y to 0 and then 1 –
then it is clear that this expansion works. The call to mapcat will
take care of binding x properly, and then concatenate the results.
This will work with an arbitrary level of nesting.

What happens when we use the :when clause?

If the condition is truthy, we execute the inner comprehension.
Otherwise, when returns nil, which, when concatenated with some
other list, returns that other list.

However, the skeptical reader just noticed a possible wrench in the
works. If :when wraps the recursive call, what happens when there is
no recursive call left? That is, doesn’t everything break if :when is
last form to appear in the bindings?

Thankfully, it doesn’t. The base-case is not the case of a single
binding pair, but instead the case of an empty set of bindings. Then, we
just return the body’s result as a singleton list.

This means that our :when clause can appear at the end of the bindings
vector.

And that’s all there is to it.

A special thanks to Alan O'Donnell and
Darius Bacon for joining me on the quest for
the simplest list comprehension macro.

Edit Jan 2, 2013: I should have mentioned this, but for posterity’s sake,
Clojure comes with list comprehensions already built in. See Clojure’s for
macro.


RSVPs for our next Localhost talk are now open! Localhost is a series of monthly, NYC-based, free, public technical talks from members of the Recurse Center community.

Our speaker is Samantha Goldstein, an RC alum who will be giving a talk about building custom hardware projects using microcontrollers and RFIDs on April 24th from 7:00 pm to 9:00 pm at Etsy.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 30-minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public. We set aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC requires a large time commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

Our next Localhost talk is scheduled for May 15th.

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open.

All guests of Recurse Center events are required to abide by our
code of conduct.


Update: As of June 19th, 2018 we’re no longer hiring for this role.

We’re hiring a Career Facilitator to help run our recruiting business. This involves helping people find fulfilling jobs, establishing and nurturing recruiting relationships with partner companies, and helping strengthen and grow all aspects of our business. The Recurse Center is an educational community and a recruiting agency, and while the primary focus of this role is on the latter, we’re hiring someone to think about and collaborate on improving both.

Read on to learn more about RC, what this role involves, the good and bad parts of working here, and our hiring process.

RC is a radically self-directed educational retreat integrated with a recruiting agency. Experienced and new programmers come to RC from around the world to spend one, six, or twelve weeks in New York focused on getting better at programming. The primary educational value of RC is peer-to peer. We don’t have teachers or a curriculum, and Recursers work on whatever they’re most interested in, teaching and learning from each other. Afterwards, alumni remain highly involved in our community, both offline and online.

Our revenue comes from recruiting fees paid by our partner companies when they hire alumni we refer to them. This allows us to keep RC free for everyone, and to fund need-based living expense grants for people from groups traditionally underrepresented in programming. There is no expectation or requirement that people who attend the retreat want or take a new job.

We started RC in 2011, and for the first several years, we mistakenly organized our company into two divisions: education and recruiting. There were good reasons why we thought this was the right way to operate, but by late 2016, experience had changed our minds.

We now think of RC as an integrated whole. Rather than some of us working on recruiting and some on education, with the two groups mostly keeping to themselves, we now all regularly collaborate to improve all aspects of RC, and we all take a holistic view of the company when choosing what we work on and how we do it.

The primary things you should expect to do in this role include:

We expect your role to change over time as we learn more about how we can most effectively meet our goals, and that you’ll play a large role in figuring out what changes to make and implementing them.

Every job has downsides, and this one is no exception. People usually learn about these things after they join a company, but we think it’s important to highlight them in advance:

Thankfully, we think this job has many more good things going for it:

Finally, working at RC involves a fair amount of uncertainty and change — we’re a small business and we routinely try new things to help us meet our goals. This is either a pro or a con depending on what you value.

Lastly, there are some things you might think are required for this role but aren’t. You don’t need to have a specific degree (or any degree at all), prior experience with recruiting or programming, or an existing connection with RC to be a strong candidate. What we’ve described in this post is what we’ll be evaluating all candidates on; we don’t have any hidden requirements.

After each stage we’ll let you know whether or not we’d like to continue as quickly as possible (our goal is within two business days). If you’re advancing to the next stage, we may also give you feedback about what we thought you did well and what you could improve on for the next round.


For the last three months, Jonathan Dahan, an RC alum from our Summer 2, 2014 batch, has been back at RC building Living Room, a system to make RC physically programmable. Living Room is installed in Lovelace (a room at RC) and is made up of a projector, some cameras, and a database. It can recognize physical objects and can project onto the wall in response to what it sees. Living Room is inspired by Realtalk (a computing system being built at Dynamicland, a genuinely different and exciting community center in Oakland), Natural Language Datalog, and Linda.

We’re supporting Jonathan’s work because we think Living Room will make RC a richer experience for Recursers and alumni: a physically programmable RC will make it easier to see what projects other Recursers are working on, and will make it more likely that projects persist from one batch to the next. We want to give Recursers more control and ownership of RC’s physical infrastructure, and supporting Jonathan’s work is a great way to do that.

Katherine Ye (S’13) started a research blog where she, Jonathan, and other Recursers working on the project are keeping their notes. We’re planning on having the system running by Never Graduate Week, our annual alumni week, in May.

The system consists of a central Datalog-style database that stores facts about the world, and independent processes that can query the database and add facts of their own. There’s a projector that draws pictures in the room, and cameras that can see what’s going on. Everything drawn on the projector is computed each frame from the facts in the database. The database is accessible over the network, so processes can run anywhere.

The project is in the early stages, but it runs. It’s also surprisingly performant. In January, Jonathan and Alex Warth (m1’18) were able to project video from a webcam in real time by having one process put each frame into the database, and another read the frames out and draw them.

If you’re a member of the RC community, stop by any Thursday or Friday before May 18th to pair with Jonathan.

If you’re not yet a part of the RC community, you can still follow the development on GitHub, follow the research blog, and join in the State of the Room video chats weekly at 12:30 pm EDT on Fridays. All the code is open source so you can play, learn, and make your own.

If you’re interested in joining a friendly, welcoming community of people working on becoming better programmers, consider applying to RC. You can join us for a six- or 12-week retreat, or try one of our new one-week mini retreats.


RSVPs for our next Localhost talk are now open! Localhost is a series of monthly, NYC-based, free, public technical talks from members of the Recurse Center community.

Our speaker is Mindy Preston, an RC alum who will be giving a talk about how library operating systems allow application programmers to approach operating systems programming in a way that’s comprehensible, documentable, testable, and hackable with everyday tools on May 15th from 7:00 pm to 9:00 pm at AppNexus.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Mindy’s talk will be the first of many hosted at AppNexus, an internet technology company that powers the real-time sale and purchase of digital advertising. We’re grateful to AppNexus for agreeing to host the rest of our 2018 Localhost events in their space!

In addition to being one of our recruiting partners, AppNexus has adopted some of RC’s social norms, including our social rules. Later this spring we’ll be co-writing a blog post with them about building good engineering environments, and our partnership.

Localhost talks are 30-minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public. We set aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC is a big commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open.

All guests of Recurse Center events are required to abide by our
code of conduct.


We’ve signed a 10-year lease on a new space at 397 Bridge Street in Downtown Brooklyn. We’ll be moving there in late summer.

RC is an unusual business, and that’s reflected in what we need in a space. We weren’t just looking for an office for RC employees: our space is primarily a community hub, both for people currently attending our retreat and our alums. Before we started our search, we came up with hard requirements for any new space.

First, it had to be highly accessible to our alums and future Recursers. It’s important to us to be in a location where alums can drop in on their way to or from work to program after hours or attend an event. Any space we rented had to be accessible to current Recursers 24/7, and close to public transportation. 397 Bridge will have a similar entry system to our current space, is within a few blocks of 11 subway lines (including several ADA accessible subway stations), and is ADA compliant.

It’s also essential our space is comfortable for all Recursers to use and work in. That meant having good natural light for folks working at their computers all day, heating and air conditioning operable 24/7, having gender neutral restrooms, space for a lactation room, and more dedicated rooms to take phone calls.

We also wanted a lease of five or more years. The lease on our current space was also for five years, and it went by quickly — we didn’t want to move RC into a new space just to have to move again a few years later.

Finally, we wanted to move into a larger space that was still affordable. This meant we had to move out of SoHo! Committing to a 10-year lease means that we needed to find a space we could imagine growing into. Our current space is 5,500 square feet, and at times it feels tight. The space at 397 Bridge includes two adjacent floors, and is 10,000 square feet.

Quiet work and spontaneous discussions are both integral parts of RC. Having two floors will allow us to simultaneously support folks who are working quietly and folks who are collaborating.



Though we know this will probably change over the course of the next decade, our current plan is to use one floor as a social space: it will have a kitchen, dining area, presentations area, our computing cluster, a living computer history museum, several meeting rooms, and some desks for pairing. Conversations and pair programming will be encouraged. We’ll also use this space for first day welcome talks, job fairs, end of batch celebrations, and game nights.

The other floor will be a quieter working space: it will have two phone booths, a library, and a few meeting rooms, but will mainly be open with lots of desks, like the main area of our current space in SoHo.

More space will mean that alums will feel more comfortable knowing there’s a desk for them when they stop by during alumni hours to work. Having two floors also means we’ll be able to host social events without disrupting folks who’d like to program, and at hours that makes them more accessible to parents and folks with family obligations in the evenings. We’ll have more opportunities to open RC for technical talks and daytime events.

Finding a space that fit the bill wasn’t straightforward: we saw over twenty places in Brooklyn and Manhattan before we found 397 Bridge Street. We’re excited that it ticks all the boxes on our requirements and our nice to haves, like being near inexpensive food options, hardware/electronic stores, banks, and parks, and being closer to neighborhoods that are more affordable for Recursers to live in.

We often describe RC as an ecosystem, because so many important aspects of it have evolved over time as the result of our community’s ideas and efforts.

Our current space, 455 Broadway, was RC’s first long-term space. Over the past five years, the hundreds of Recursers who spent time here made it a home: they decorated the space with art, created a programmable room, and brought in more hardware than we could accommodate. You don’t need to spend very long in our current space to see the many ways Recursers have helped shape its use, and how its contours in turn help create important parts of the RC experience.

 Our library, with mural by Monica Toth

Moving presents a subtle but significant challenge for RC because it means wiping away all that history and starting fresh. We’ll be documenting our usage of 455 Broadway over the next few months, and will bring as much of what makes this space great along with us.

Ultimately, RC is constantly being defined and redefined by Recursers themselves. When looking ahead to the next 10 years of potential challenges in defining our new space, we like to remember the words of Jane Jacobs:

Cities have the capability of providing something for everybody, only because, and only when, they are created by everybody.

We think this is true of RC, too. It will take work and time to make a home of 397 Bridge: part of the reason we wanted to make a 10-year commitment to a new space is that we understand that it takes time to grow into one. We’re confident that with the help of our alums and future Recursers over the next decade, 397 Bridge will become an even more wonderful version of RC.


RSVPs for our next Localhost talk are now open! Localhost is a series of monthly, NYC-based, free, public technical talks from members of the Recurse Center community.

On June 26th from 7:00 to 9:00 pm, RC alum Aditya Mukerjee will be giving a talk about the  Gitgo project and how it can make Git a practical choice for content distribution, distributed build systems, establishing consensus, and more. The talk will be hosted at AppNexus, our Localhost partner through the rest of 2018.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 30-minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public. We set aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC is a big commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open.

All guests of Recurse Center events are required to abide by our
code of conduct.


RSVPs for our next Localhost talk are now open. Localhost is a series of monthly, NYC-based, free, public technical talks from members of the Recurse Center community.

On July 24th from 7:00 to 9:00 pm, RC alumna Bonnie Eisenman will be giving a talk about caching data and cheating the CAP Theorem with dynamically scaled TTLs. The talk will be hosted at AppNexus, our Localhost partner through the rest of 2018.

You can RSVP, read the abstract, and find more details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 30 minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public. We set aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC is a big commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open.

All guests of Recurse Center events are required to abide by our
code of conduct.


We started our residents program in the fall of 2012. We paused it in late 2016, and officially ended it in early 2017.

The idea for our residents program came from a conversation with a Recurser in our summer 2012 batch. He was one of the more seasoned programmers at RC at that time, and while he loved RC, he said he wished there were far more experienced programmers in his batch to learn from and work with. Specifically, he wished Guido van Rossum, the creator of Python, were at RC to review his Python code.

Based on this feedback we invited some highly accomplished programmers to come spend one or two weeks at RC during our following batch. The goal was to ensure that there were always people at RC who had deeper expertise in certain areas of programming than anyone attending the retreat.

Over the next few years, we had dozens of wonderful people come to RC as residents, usually via one or two week stints. Many of these people have subsequently stayed involved with the RC community for years, continuing to contribute substantially to it. Many of them have also told us that they’ve grown and benefited tremendously from joining the community.

Despite the positive aspects of the program, we decided to permanently stop inviting new residents in late 2016 and had our final new residents in early 2017.1

So why did we end our residents program?

First, our process for finding and vetting residents was inconsistent and opaque. When we started the program, residents were consistently more experienced and accomplished programmers than the majority of people who attended our retreat. Over time, this stopped being true. Eventually, a good portion of the people applying to the retreat were more advanced programmers than many of our residents. Additionally, since we brought on new residents via referrals and invitation, our process for evaluating residents was necessarily somewhat ad hoc and wasn’t transparent to the world or even our community.

The second reason we ended the program is both more subtle and more important: We realized that having a subset of our community ordained and elevated as “residents” was out of line with our core values. And because residents were positioned as experts at RC to support Recursers’ learning (and not also as fellow learners looking to grow themselves), the program subtly reinforced a vessel-filling rather than self-directed view of education. One of the things that makes RC unique is that everyone has the rare opportunity to take responsibility for and direct their own learning — from deciding what is important to them to what their goals are and how to achieve them. At the same time, RC is at its best when everyone is mindful and supportive of each other’s learning goals. Bifurcating our community into “Recursers” and “residents” does not help this.

For all these reasons, we chose to stop inviting new residents to RC.

There was one notable downside to ending our residents program: there was no longer a way to join the community for people who couldn’t or wouldn’t take six or 12 weeks off to attend a batch. In early 2018, we introduced one-week mini retreats to fix this, and anyone can now apply to attend RC for a week and become a full member of the community. After running a few mini retreats, and seeing who chooses to apply to them, we’re even more confident that this decision has led to a better RC.

RC is now simpler and more true to our vision for it. Everyone who joins the community does so by the same process and on the same terms. Everyone at RC, regardless of background or previous experience, is an equal member. And most importantly, everyone who comes to RC does so both to share what they know and to continue to get better themselves. This reflects our beliefs that everyone at RC is an expert in some things and a beginner in others, and that growth is a life-long process.

We had previously slowed down and then paused inviting new residents earlier in 2016 for financial reasons (we paid residents stipends, and RC was particularly cash-strapped at the time). The final residents we hosted in early 2017 were people we had already invited and been talking to before we decided to end the program.↩


We describe RC as being self-directed and community-driven, but what do these terms actually mean?

When we say that RC is self-directed, we mean that people have both the opportunity and the responsibility to direct themselves here. Recursers decide what their goals are, why they have them, how they want to work towards them, and how to assess whether they’re succeeding or failing.

Few if any of these things are true in the places where we spend most of our lives: school and work. In most schools, none of these things are true. Teachers and administrators decide what people should learn (the curriculum), how they will learn it (listening to lectures and doing homework), and how to assess progress (tests and grades).1 Sometimes schools tell people why the school thinks things are important to learn, but that may have little or no bearing on why those things are important (or not) to a student.

Universities say they teach critical thinking or “how to learn” but the general idea remains the same. They tell you the skills you need to learn, how to learn them, and the courses to pass to prove you have. Universities are self-directed in the same way choose your own adventure books are: You’re free to follow any path you like so long as it’s one they’ve laid out for you.2

Many jobs are more self-directed than school, but only in limited ways. For instance, in white collar jobs, employees commonly have the freedom to decide how they do their work, and sometimes even what they work on. But even great jobs can’t be truly self-directed because companies have goals, employees have responsibilities, and managers quite reasonably have expectations for their reports. You can’t be fully self-directed in a typical job because you have a job, and that job probably isn’t one you get to define.

At RC, your “job” is to grow as a programmer — and to define what that means to you, given your own goals and unique circumstances.

This is hard for nearly all Recursers, in part because it’s so different from their past experiences, and in part because it’s a fundamentally uncomfortable thing to grapple with. Recursers have shared that a defining moment for them was on the first day of their batch, after our welcome breakfast and talks concluded, when they sat down and realized that they had to decide for themselves what to do for the rest of the afternoon and the rest of their batch.

When we say that RC is community-driven, we mean that the core educational and business value of RC is the community.3 We as RC faculty do many things, from bringing people together and establishing a healthy environment to providing physical space, advice, and useful resources. But we don’t make RC, Recursers do. In a real way, RC is the sum of all the projects, pairing sessions, code reviews, expertise, questions, answers, presentations, events, and everything else people decide to do here that shapes their and others’ experiences. RC only works because Recursers aren’t all the same — everyone brings a unique perspective and contributes different things to the group. This is one of the two major reasons diversity is essential to the success of RC.4

That’s why the vessel-filling5 model of education taken by nearly every school, university, and bootcamp is in conflict with diversity. That model starts with the assumption that education boils down to a transfer of knowledge from teachers to students. Improving education is thus a matter of figuring out the right set of facts and skills to teach and the most efficient way to get them into students’ heads. The closer students are to clones of each other, the easier this process is.

Harvard and other top universities are community-driven in the sense that the greatest value they provide students is surrounding them with peers. But universities’ explicitly stated educational model (teaching courses by expert faculty) doesn’t allow them to fully embrace or acknowledge this, and their founding assumptions don’t take advantage of it.

In contrast, we try to continuously make RC more community-driven and self-directed, from how we use our internal chat system to our move to overlapping batches to our decision to end our residents program.

While RC can provide many things, we can’t provide motivation. Nor can we tell people what they want, how they should work towards it, or why they are here. These questions are present for all of us all of the time, but they are more evident at RC because we refuse to provide the easy but meaningless answers schools are so eager to offer. Everyone at RC must ultimately struggle with these questions for themselves, though they need not struggle alone.

Thankfully, this struggle gets easier with time and practice as you strengthen your volitional muscles, and surrounding yourself with others who are also committed to self-directed growth gives you a support system to draw upon when you need it. Learning to acknowledge and then work through the challenges of directing your own time is one of the most important things many people take from their time at RC.

K-12 schools in the US go much further. They decide not just that students should learn history but that they should learn specific facts about American History, in 60-minute periods on weekdays between September and May when they are 17-years old. They measure how well students “learn” these facts quite precisely — typically using GPAs with three significant figures!↩

Of course, many people do find a way to chart their own course in college, but the institutional headwinds are against them. I went to college after 18-years of self-directed learning. I was determined to learn on my own terms and not let grades influence my decision-making. I got a lot out of the experience and I don’t regret going to college. Even so, the institutional forces got to me, and after some time I found myself thinking, “Oh, this doesn’t matter, it probably won’t be on the exam.”

The major advantage universities (and bootcamps, MOOCs, and others) have over K-12 schooling is that they’re not compulsory, and so participants choose to attend them, at least in theory. In practice, many people go because of societal or familial expectations, or because getting a four-year degree or learning Rails in 12-weeks is a default or well-trodden path. Here again RC has an unfair advantage: We are both non-compulsory and still odd enough that we’re not yet anyone’s default option.↩

Our sole source of revenue is recruiting: companies pay us to help them hire our alums. As such, it’s not hard to see why RC becomes more valuable as our community grows in size, strength, and diversity.↩

The other reason is that we cannot achieve our mission of building the best place to grow as a programmer without making RC a genuinely diverse and inclusive place. We will not and cannot be the best place to grow as a programmer if only people from some demographic groups thrive at our retreats and in our community.↩

This name is inspired by quotations that likely date back to Plutarch.↩


RSVPs for our next Localhost talk are now open. Localhost is a series of monthly, NYC-based, free, public technical talks from members of the Recurse Center community.

To celebrate one year of Localhost, we’re trying a different format for our next talk: on August 21st from 7:00 to 9:00 pm, eight Recursers will give seven lightning talks about projects they worked on at RC, from ASL translators to landscape generators to adventures in implementing the Viola-Jones algorithm. The event will be hosted at AppNexus, our Localhost partner through the rest of 2018.

You can RSVP, check out the full list of speakers and talk subjects, and find details about the venue and schedule on the talk’s RSVP page.

The format of this talk will be a bit different than our past events. The talks will begin at 7:20 pm. Each talk will last for 5-6 minutes, and will be followed by a 2-minute break for set-up for the next speaker. We won’t have a dedicated Q&A session, and we’ll still ask that you not ask questions during the talk. There will be time to chat with presenters at the end of the evening.

Our September talk will follow the usual format (one 30 minute talk from a single speaker, with a dedicated Q&A afterward).

Unlike most RC events, Localhost talks are open to the public. We set aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC is a big commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). This is even more true for this event: it will be very similar to our Thursday evening presentations. If you RSVP, please read about our social rules before the event.

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open.

All guests of Recurse Center events are required to abide by our
code of conduct.


The more programming I do, the more often I find myself thinking, “Ah, that’s not magic.”  I had one of these moments recently when dealing with a python virtual environment created by virtualenv.  Virtualenv creates a sandboxed python environment with its own installation directories, separate from the system python and other virtual environments on your machine.  This makes it a great way to test on multiple versions of python or to explore a new package that could break other things you care about.

How does it work?  Well, the ‘magic’ works like this:
- create a virtual environment with virtualenv my_env
- chant the magic incantation source bin/activate
- watch as your previously-failing installation of pygame goes smoothly!
- To “turn off” your virtualenv, the magic incantation is deactivate.  

Of course, it’s not actually magic.  Virtualenv is a fairly simple (though clever) bash script that does only a couple of things.  You don’t have to understand much bash scripting to see what’s going on.  In fact, if you only know python, I’ll teach you all the bash you need to understand virtualenv right now.

I’m going to skip the actual creation of a virtual environment, and just focus on what happens when you activate and deactivate that environment.  If you’d like to play along, pip install virtualenv, create a new virtual environment with virtualenv testenv and then cd into the testenv/ directory that was created.  (Don’t run source bin/activate just yet.)

First, let’s look at that incantation, source bin/activate.  What’s going on here?  source is a bash command that runs a file, the same way you’d use import to run your python module.1 bin/activate is the bash script being run.

One other detail of source will be important.  source runs the file provided in your current shell, not in a subshell.  Thus it keeps the variables it creates or modifies around after the file is done executing.  Since (almost) all that virtualenv does is modify environmental variables, this matters.

OK, now let’s look at bin/activate.  Fire up the activate file in your favorite text editor.
The first thing to notice is that it’s only ~80 lines!  Cool - we can handle this.

(The activate script is generated automatically by the virtualenv installation, and has some system-specific parameters, so your copy may be slightly different that mine.  Mine looks exactly like this.)

The first thing we find is a comment:

We already know why this is true - it’s because of the behavior of source that we just learned.  Running a bash file directly (e.g. calling activate from bin/) runs the script in a subshell - not what we want.

Onward:

This is just a bash function definition.  Function calls work just like commands in bash.  Now we know that the commands included in this block are what runs when we say deactivate in our virtual environment.

The meat of the activate file is in lines 42 - 47:

Starting with a call to deactivate ensures that any existing virtual environment is deactivated before a new one is created.  Virtual environments are separate from each other; they can’t be nested.  

The rest of this is pretty straightforward.  export is the only other bash command we need to know, and it’s really simple: it just exports a variable into your current environment. It also ensures that environmental variables in processes spawned from the current one get the same values.  Since we’re  running the file via source, the effect is to set variables and then keep them after the activate script finishes running. 

So the activate script does three primary things:
1. Sets a VIRTUAL_ENV bash environmental variable containing the virtual environment directory
2. Prepends that directory to your PATH
3. Sets the new PATH.  

What is PATH?  The PATH is an environmental variable representing a list of directories.  Your system will look for programs and scripts in the order that directories are listed.  The list is separated by colons.  

Let’s see this in action.  To see what your PATH looks like before you run the activate file, hop into your terminal and type echo $PATH.  This prints out the value of PATH to the terminal. Mine looks in part like this (I’ve inserted line breaks for clarity):

All this says is that when I type a command like python, my system looks first in /usr/local/bin for python.  If it can’t find it, it moves on to /usr/local/sbin, then to /usr/bin, and so on.  

Now let’s run the activate file and see what changed.  (Again, I’ve inserted line breaks for clarity.)

Sure enough, that testenv directory has been prepended to my PATH.  Now bash will look for python, or any other system command, first in the bin/ directory here in my testenv.  What’s in there?  Let’s take a look:

There’s our activate file that we’ve been examining, plus a version of python!  So this is the python installation that will get modified if we install packages, and the python that will be run by python.  For easy confirmation of this, we can use which:

We’re using the testenv python, not the system python (which is found in usr/bin/).

Notice that activate also modified my bash prompt (PS1). We’ll skip some of the details here - the important point is that this code stores your old PS1 and inserts the name of the virtualenv into the new one.2

We’re done with our virtualenv for now - let’s come back to deactivate.

deactivate calls export to restore the old environmental variables, then calls unset to remove unneeded variables from the environment.  (You can verify this from the terminal by using the command env to view all your environmental variables.)  Finally, deactivate calls unset -f deactivate to remove the deactivate function itself.  (-f removes a function.)  The function is now gone from the environment, which you can easily verify:

Our PS1, PATH, and PYTHONHOME end up with their original values.

There you have it - no magic, and just a tiny bit of bash scripting to understand the power of a virtual environment.


source is the same as the dot operator .↩



            There’s a particularly bewildering bit of code in these lines:
        


            The if statement as written will always return false - but the following line doesn’t do anything anyway.  This turns out to be a consequence of the system-dependent nature of virtualenv and the fact that the activate script is automatically generated.  See here for a more detailed explanation.
             ↩



In September of 2016 we stopped accepting applications for RC Start, our mentorship program for new programmers. We stopped running RC Start because we didn’t get the results we expected, and because we realized it was a strategic mistake.

We introduced RC Start in January of 2016. It was a free, one-on-one mentorship program for people just beginning as programmers. Each person who was admitted to RC Start was matched with an RC alum for three 45-minute sessions, either in person or on Skype. What happened in the sessions was entirely up to the RC Start participant and their mentor, and if both people were interested, they were welcome to continue meeting after the initial three sessions.

We made RC Start because we thought it would be a useful thing to have in the world. Lots of people want to get started as programmers, but starting out can be intimidating. We knew from our own experience how helpful a few well-placed pieces of advice can be. We were also sad to regularly have to reject people who had $15,000 of debt from a programming bootcamp because they didn’t meet our minimum requirements for programming ability. We hoped there was a better way.

RC Start was also something we were well positioned to do: at the time we had almost 700 alumni, all of whom were qualified to mentor someone new to programming.1 The sort of advice that’s useful when you’re just starting out generally doesn’t require specialized knowledge on behalf of your mentor, and it seemed likely that all RC alumni would be qualified to work with most RC Start participants.

Finally, we hoped that some of the people who did RC Start would eventually apply to RC, attend a retreat, and become part of the RC community. While programmers of all experience levels come to retreats at RC, you need to already be able to program in some capacity. RC Start was designed to be accessible to a wider range of people by relaxing the constraint that you had to already know how to program to participate. We knew there were lots of people just learning to program who would eventually make great Recursers. By building a connection to these people early, we thought they’d be more likely to apply to RC when they were ready. We were specifically interested in building a more diverse applicant pool for RC by reaching people from groups traditionally underrepresented in programming.

People liked it. Most participants found the experience valuable. Our alumni liked the opportunity to be helpful. Between January and September of 2016, we matched 167 RC Start participants with mentors from the RC community. Our community provided over 350 combined hours of mentoring. Where possible, we matched people who lived in the same city so that they could meet in person. Where it wasn’t possible, people met over Skype. Fifteen RC Start participants ended up attending a retreat and becoming members of the RC community. There was more demand than we expected, and we ran RC Start for nine months instead of the original two or three months that we planned.

Not everything went the way we thought it would. People who applied to RC Start had more programming experience than we expected. This meant that they had more specific requirements for mentorship that made it harder for us to match them (e.g. looking for a mentor with experience in Angular 2). The RC Start applicant pool also ended up being less racially diverse and gender balanced than the existing applicant pool for our retreats.

We also began to realize that RC Start was a strategic mistake: it didn’t help us build our community, which is the most valuable part of RC, and it wasn’t truly community-driven.

Our first mistake was that we couldn’t add RC Start participants to our community. We’ve known for a long time that the most valuable part of RC is the community. This is true from a business perspective – we make money by helping members of our community find jobs – but more importantly it’s true from an educational perspective. The people you meet, the projects you work on together, and the relationships you build are a large part of what makes attending RC valuable.

We couldn’t add RC Start participants to our community because our retreat had more stringent admissions requirements than RC Start. This meant RC Start participants couldn’t come to RC events, program at RC during alumni hours, or access Zulip and our mailing lists. We knew this going in, but we didn’t fully appreciate the ways that this would make things strategically difficult. It created some practical and logistical problems (e.g. RC Start participants wanted a place to chat online and ended up setting up a Slack instance themselves), but more importantly, it meant we were doing work that didn’t make the core of RC substantially better.

Our second strategic mistake was that while RC Start was superficially community-driven – all mentors were members of the RC community – it wasn’t community-driven in the way the rest of RC is. RC thrives on serendipity. When you come to a retreat, you meet and work with all kinds of people, many with wildly different interests. With so many people at RC, you’re likely to find plenty who are interested in the same things you are. The things you do at RC depend on who you meet, and how you collectively decide to spend your time.

RC Start didn’t work the same way. We paired each participant with one mentor. We did our best to make good matches, but if your mentor didn’t have the experience you were looking for, didn’t know the answers to your questions, or just wasn’t available, there wasn’t anyone else for you to talk to. This made RC Start fragile.

All of the things that motivated us to do RC Start are still true. We still think there should be more effective ways to support people who are just getting started with programming, and we’d still like to have more wonderful people apply to RC from an even more diverse range of backgrounds and experiences. While RC Start had some strategic issues, it’s given us insight into how we should approach these problems in the future.

We now have over 1,200 alumni.↩


RSVPs for our next Localhost talk are now open. Localhost is a series of monthly, NYC-based, free, public technical talks from members of the Recurse Center community.

On Monday, September 17th from 7:00 to 9:00 pm, RC alumna and former facilitator Allison Kaptur will be giving a talk about how using Mypy, an optional static type checker for Python, has changed how she writes Python. The talk will be hosted at AppNexus, our Localhost partner through the rest of 2018.

You can RSVP, check out the full list of speakers and talk subjects, and find details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 30 minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public. We set aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC is a big commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open.

All guests of Recurse Center events are required to abide by our
code of conduct.


RSVPs for our next Localhost talk are now open. Localhost is a series of monthly, NYC-based, free, public technical talks from members of the Recurse Center community.

On Tuesday, October 23rd from 7:00 to 9:00 pm, RC alum Veit Heller will be giving a talk about Carp, a compiled, type-inferred, and borrow-checked programming language that runs natively on any supported platform without the user having to write any types or think about memory management. The talk will be hosted at AppNexus, our Localhost partner through the rest of 2018.

You can RSVP, check out the full list of speakers and talk subjects, and find details about the venue and schedule on the talk’s RSVP page.

Localhost talks are 30 minutes long, and are followed by a dedicated Q&A session. There will be a two-minute break after the talk for folks who wish to leave. There are a few reasons we run talks this way:

Unlike most RC events, Localhost talks are open to the public. We set aside a fixed number of seats for folks who aren’t members of our community at every talk. It’s been great meeting so many new folks at our Localhost talks!

We know that attending a batch of RC is a big commitment, and hope that Localhost talks are a way for people to get a taste of what the RC community is like (and maybe even apply for a batch afterwards!). If you RSVP, please read about our social rules before the event.

We’ll open RSVPs and post details for future talks on our Localhost page and here on our blog. Follow us here and on Twitter for updates on when RSVPs open.

All guests of Recurse Center events are required to abide by our
code of conduct.


We’re happy to announce a new set of policies intended to make RC more accessible to parents and caregivers of kids of all ages. You can read these policies in their entirety in our User’s Manual.



RC already offers a flexible schedule while still being an immersive, full-time retreat. We’ve got a late start (10:30 am) and a four-day week (Fridays being optional). You can choose between different retreat lengths to fit your schedule. It’s alright to head out early every once in a while for an appointment, or miss a day or two if you tell us in advance. We don’t have any mandatory late-night or weekend events, and there are plenty of opportunities to socialize and bond with other Recursers during core hours, rather than off the clock.

We started offering mini retreats in part to allow Recursers with children to attend a retreat. After running the first two, we got feedback that those retreats were scheduled during school break weeks, which were especially challenging times to coordinate child care. We looked into the schedules for subsequent mini retreats, to ensure that the majority do not coincide with school breaks.

More importantly, the work, collaboration, and learning that happens at RC takes place both in-person and online, making it easy to stay engaged and active even if you’re on a different schedule than most other Recursers or if something is temporarily keeping you away from the space.

We’ve adopted these new policies simply because we believe it’s the right thing to do. RC gets better as it gets bigger and more diverse, and we believe that more great programmers will be able to come to RC if we create a space that is easier for caregivers to navigate. We’ve also been inspired by an increasing number of Recursers with children attending a retreat, and by seeing many of our alums become parents for the first time over the past few years. Now that we’ve moved to a bigger space, more options for better supporting parents are available to us: we are able to have a wellness room, and we can host potentially loud events on one floor during core hours without disrupting focused work on the other floor.

Accessibility helps everyone, not just the folks whose needs are directly addressed by the changes. Hosting events at a wider variety of times will provide more socializing opportunities to parents as well as people with longer commutes or prior evening commitments. When it’s not being used by a parent or caregiver, the wellness room will be available to all Recursers who might need it to be comfortable at RC. We are committed to making RC accessible to anyone who wants to spend time here becoming a better programmer. We hope that the combination of living expense grants (available to people from groups traditionally underrepresented in programming), one-week mini retreats, and our new family-friendly policies will make it easier for parents and caregivers to thrive at RC.

If you’re interested in joining the RC community, apply today!


We’ve just launched Joy of Computing, a site where you’ll find one new link to a technical project posted each day.1 Everything on the site is made and submitted by Recursers.

Over time, we hope to grow the site into a destination for finding fun, technical work. We aim to convey the full range of things people create during and after RC, from neat gists to ambitious projects, gifs of prototypes, stories of odd bugs, games, apps, computer-generated music and art, compilers, dev tools, electronic crafts, works-in-progress, and so much more.

There are over 1,300 members of the RC community in the world, and it’s nearly impossible to see all the neat stuff that they do during and after RC—even Recursers find it hard to stay up to date. We’ve also done a poor job so far of sharing Recursers’ work with the wider world. We think there are two reasons for this.

The first reason is that our priority has always been making RC a great place to grow as a programmer. For us, this means providing a space where people can feel like they belong, ask questions without fear, and focus on programming and learning with as few external distractions as possible. It is easier to build a space like this when everyone is there to learn, has committed to healthy social norms, and feels comfortable with each other. The side effect of this is that RC is a relatively closed community. It isn’t because we want to be exclusive, but rather the opposite: we’ve found this is the best way to make a genuinely inclusive environment.

But this comes at a significant price. It’s harder to let new people know about RC and even harder to let people see and experience what goes on here before applying and attending.

The second reason we’ve struggled to share what happens at RC is related to its structure. If RC had a curriculum and teachers that taught it, we’d have easy answers to the questions of what people learn here or what a typical day looks like. But we don’t have teachers or a curriculum, nor do we tell people what they must do at RC. Rather, Recursers decide for themselves what they want to accomplish and how to structure their time, and so the answers to what people do here or what a “typical day” looks like are as varied and diverse as the people who come to RC. This is what we mean when we say that RC is self-directed and community-driven.

With Joy of Computing we intend to share much more of what happens at RC publicly, in a way that’s in line with our community-driven structure and which doesn’t disrupt the experience of people attending RC.

You can think of Joy of Computing as a bit like a big group Tumblr. Any of the 1,300+ people in the RC community can submit their own or other Recursers’ work to the site. Each submission is reviewed by one other Recurser to make sure it’s appropriate for the site (in short: the work must be technical, open source, and made by a Recurser), and once approved it gets added to a queue of upcoming posts. Every morning the site randomly publishes one post, weighted by how long it’s been in the queue.

The site is in some ways a successor to Code Words, the quarterly publication of technical writing we shuttered in 2016. But unlike Code Words, Joy of Computing is designed to be truly community-driven, rather than carefully curated by RC faculty. It is meant to be serendipitous and a bit messy — just like RC. Additionally, we aim to reflect the diversity of work people do at RC, and not only the highly polished, long-form writing that Code Words featured.

A lot of computing has felt grim recently, and rightfully so. Each day has brought a new reminder of Google and Facebook’s scandals and surveillance, and our industry’s broader failings. The world has realized that technology isn’t a panacea, and some of its effects are downright harmful. We as programmers must think carefully and deeply about the impact of our work, and change our behavior accordingly.

In a climate like this it’s easy to lose sight of the positive things that attracted many of us to programming in the first place. We hope Joy of Computing will serve as a healthy counterbalance to the news of the day, and remind you that there are still many good sides of computing and technology. Programming can be not only useful but also playful, intellectual, exciting, expressive, delightful, and humane.

We released the site privately to the RC community earlier this month ahead of our public launch today, which is why the site already has a number of posts.↩


Update: As of December 17th, we are no longer accepting new applications for the Fellowship. You may still apply for our regular one, six, and 12-week retreats.

We’re accepting applications for $10,000 Fellowships for women, trans, and non-binary people who would like to work on a project or research at the Recurse Center this winter. The Fellowships will be funded directly by the Recurse Center. We will be reserving at least 50% of our funding for women, trans, and non-binary people of color.

Is there a project you’ve always wanted to start or contribute to, but you haven’t had the time or resources to do so?  Now’s your chance: apply to RC this winter for a one, six, or 12-week retreat. We’ll provide up to $10,000 in funding (depending on batch length), 24/7 access to our space, and a supportive community of fellow programmers.

You can work on whatever programming-related project you want. The only hard constraints on what you can do here are that it must involve code, and the code must be open source so that others may freely use, learn from, and build upon it.

For example, you could make experimental games, or algorithmic art or music. You could build software for accessibility, like screen readers or automated transcription. You could make a better ad blocker, or other tools to protect people’s privacy and security. You could contribute to existing developer infrastructure, start a new programming language, or kickstart original long-term research.

At RC, you’ll have a space where you can focus on your work without the regular obligations of school or a job. You’ll also have the freedom to approach your work however you see fit, and will retain all rights to anything you do here. You don’t have to “finish” your project during your time here, and you won’t be reporting to an advisor or a boss. If you realize that it’s not the best thing to continue doing, you can set it aside and choose something else to work on.

Our new space in Brooklyn has two floors, a wellness and lactation room, pairing stations, and lots of natural light. One of our floors is set up for pairing, giving presentations, and group work, while our other floor has a library of books and is kept quiet for focused individual programming.

In addition to attending the retreat, you’ll join a community of over 1,300 kind, sharp, and intellectually curious programmers who have experience in a wide variety of programming topics. They have done academic research, given scores of conference talks, started companies, and created art, games, and music. You’ll be connected with folks who can pair with you, discuss what you’re working on, answer questions, and contribute to generative conversations about programming.

Nearly seven years ago, we set out to create a gender-balanced environment at RC. In early 2012, we partnered with Etsy and offered our first need-based grants for women who were admitted to RC but couldn’t afford to pay for living expenses during their time here. Over the years we’ve made numerous efforts to make RC a more diverse and inclusive place, from establishing healthy social rules, to expanding our grants to support people from traditionally underrepresented racial and ethnic groups, to introducing one-week mini retreats and revising our policies to be more family-friendly. In total, we have given more than $1.5 million in grants to people from traditionally underrepresented groups in technology since launching our grants program.

Ensuring a supportive and diverse environment is crucial to our mission of building the best place to grow as a programmer because RC is community-driven. While our community has grown in size and diversity along many dimensions, it has been increasingly challenging for us to maintain a gender-balanced environment. We are still very far from our goal of consistently having RC batches be comprised of at least 50% women, trans, and non-binary people. Despite regular outreach efforts, our applicant pool has skewed increasingly male, and thus RC has as well.1 Because our batches are relatively small, our gender balance can fluctuate significantly; at points this year RC has been about 40% women, trans, and non-binary people, but in recent months and looking ahead to our upcoming batches, we are doing significantly worse, which is why we’re trying this now.

We hope that our Fellowships will help diversify our applicant pool and encourage more people, especially women, trans, and non-binary people of color, to apply to RC.

The amount of money you’re eligible to receive for a Fellowship depends on how long you come to RC for. We’re offering $10,000 for a 12-week batch, $5,000 for a six-week batch, and $1,500 for a one-week mini batch.

To qualify for a Fellowship, you must:

Current members of the RC community who meet the above criteria are welcome to apply for a Fellowship.

The admissions process for Fellowships is very similar to our standard admissions process:

Our admissions criteria for Fellowships is identical to our normal admissions criteria, with one exception. For a regular batch, we look for people who want to become dramatically better programmers, and we expect people doing a batch of RC to prioritize that, even above making progress on a project. But for Fellowships, the focus is making progress on a project or research, even if it doesn’t make you a dramatically better programmer (though we hope it does!). And so we’ll be evaluating applicants in part on what they hope to do at RC, and not whether and how they want to improve as programmers.

We review applications on a rolling basis. However, given the tight timeline before the session begins on January 7th, you should apply as soon as possible to ensure you have time to complete the admission process. We plan to do the majority of interviews for Fellowships between December 18th and 20th. Because of the holiday break, we cannot guarantee interview availability during the week of December 24th.

If you think this a Fellowship could be a good fit for you, we hope to see you apply. And if not, we hope you’ll share this opportunity with a friend or colleague who may benefit from it.

If you have any questions, email us at faculty@recurse.com.

We do not take demographics into account when making admissions decisions: we hold everyone who applies to RC to the same bar. To reduce unconscious biases, we use pseudonyms and hide names and demographic information during our initial application review.↩


Mary

We’re thrilled to announce that Mary Rose Cook is joining the Hacker School faculty!

Mary was in the summer 2012 batch, and we’ve been working on hiring her ever
since.

Mary is the author of some really awesome open source projects, including Isla, a programming language for young children. She’s written multiple libraries, including Andro.js, Machine.js and Glazz. She’s also made two very fun and challenging games, most recently the inventive platformer, Empty Black.

I could go on raving about Mary’s many accomplishments, but I don’t
think they capture why we’re so excited to have her joining us. Here’s the real reason we’re so happy: In addition to being a wonderful programmer, Mary is a delightful human being. She’s fun, funny, inquisitive, patient, friendly, creative and a pleasure to work with.

Please join us in welcoming Mary to Hacker School. Together, we’re going to
continue building Hacker School into the best place on earth to learn and grow as
a programmer.

— Hacker School










(Alan, Allison, Dave, Mary, Nick, Sonali, Tom, and Zach)

(Alan, Allison, Dave, Mary, Nick, Sonali, Tom, and Zach)


Today, I’m going to share some things we learned from the last batch of Hacker School, and announce our winter 2013 residents and grant sponsors.

While it’s too late to apply for our current batch, applications are open for our summer 2013 batch.

Last batch, as an experiment, we invited a few great programmers we respect tremendously to be residents at Hacker School, each for one or two weeks. The experiment was a huge success and Stefan Karpinski, Jessica McKellar, David Nolen, Alex Payne, and Peter Seibel deserve all the credit. Hacker Schoolers got to talk and pair with them, learn from their experiences, and become friends with them.

Now that we have some distance between ourselves and the last batch, I want to share some of the most interesting things we learned from our residency program.

We were lucky to be able to pepper our residents with questions about how they learn, and there was a surprising amount of variety to their answers. Some of our residents said that they learned best with self-directed study, while others said that they need more structure. One even said he learns best with the constraints of a job.

This has affected how we run Hacker School in two ways. First, it has inspired us to experiment with adding more optional structure to the batch, and second, it has made us much more wary of the idea that there is one true way to learn programming. If Hacker School is going to be the best place in the world to become a better programmer, we must be able to cater to all types of students.

Next, having residents at Hacker School reaffirmed our belief that reflection and introspection are integral to the learning process. Despite the differences in how they approached learning, all of our residents have thought a lot about the paths they took to get to where they are now. Though we recently removed a daily reflection feature from our internal website because it wasn’t getting used enough, introspection has become a core part of the way programming is learned at Hacker School1.

Lastly, there’s a lot of value in watching experienced programmers work. Two of our most successful group activities have been seminars watching Peter do a live refactoring of a small tic-tac-toe program and having David walk through and explain an implementation of miniKanren. Watching great programmers work shows us how much we can improve and inspires us to try to get there.

Given how much their presence improved Hacker School, it was a no-brainer to invite all of our past residents back for another batch. We set our expectations appropriately given that, unlike us, they have concerns outside of Hacker School, and we were ecstatic to learn that Stefan, Jessica, and David were all able to come back for this batch. Residents are now a core part of Hacker School and we’re grateful that Stefan, Jessica, and David will be spending time with us again.

In addition, we’re excited to have two new residents joining us this batch: Jacob Kaplan-Moss and Glyph. Jacob is one of the creators of Django and Glyph is the creator of Twisted. In addition to their obvious technical qualifications, Jacob and Glyph are warm, friendly, and thoughtful and will help make Hacker School a safe place to ask questions and grow as a programmer. We’re looking forward to learning from their experience and we know they’ll help make Hacker School even better. You can read more about Jacob and Glyph on our residents page.

Our goal is to make Hacker School the best place on earth to become a better programmer. One of the best predictors of how much you will improve during your time here is how comfortable you are admitting you don’t know something. The most successful Hacker Schoolers actively seek out things they don’t understand and fearlessly ask questions until they do. We want to create an environment where everyone, both men and women, are able to do these things and excel.

Women have made up a small minority of programmers for many years. When you are in a minority, it is easy to feel like you don’t belong and to be susceptible to stereotype threat. If you don’t feel like you belong at Hacker School, you won’t be as comfortable asking questions and admitting gaps in your knowledge, and if you can’t do that, you won’t improve as much as you could. This is one of the reasons we care so much about having gender parity at Hacker School. Our goal is to eliminate the negative effects of being in a minority that female programmers have to deal with in most of the rest of the world. While we’re not there yet (our past three batches have been 35-45% female), we’re working on fixing this problem by providing need-based grants to any female student who needs one2. Hacker School remains free to attend, but being in New York for three months without a job is not free and having cash on hand to cover the cost of living can make all the difference.

For the past three batches, generous and committed companies have stepped up to help us provide these grants that we cannot afford to give ourselves. We want to take a moment to thank the companies who are sponsoring grants for this batch, and the people at each one who made it possible. Thanks to Albert Ni at Dropbox, Marc Hedlund at Etsy, Scott Chacon at GitHub, and Marc Yun at PhotoShelter. All these companies care tremendously about supporting female programmers and are putting their money where their mouths are. Without these wonderful sponsors, Hacker School would not be possible. We are honored to have their support. Thank you!

Curious about Hacker School? Read more about us and apply for our summer batch.

More on this in a future blog post.↩

The grants have successfully boosted the number of women able to do Hacker School, without impacting men’s chances of being accepted, since we’ve been able to admit all of the qualified students who have applied to our recent batches. If you’d like to sponsor need-based grants for women or men to do Hacker School, please email us.↩


We’re thrilled to announce nine residents for the summer 2013 batch of Hacker School.

Joining us for the first time will be Nada Amin, Mel Chua, Lindsey Kuper, Kevin Lynagh, Peter Norvig, Brandon Rhodes, and John Myles White.  Two of our favorite people, Stefan Karpinski and Jessica McKellar, are each returning for their third residency. 

They’re all smart, thoughtful, accomplished, and genuinely nice people, and we’re incredibly excited to have each of them. Check out our residents page to learn more about them.

We want to make Hacker School the best place on earth to become a great programmer, and we want Hacker School to be the most productive three months of our students’ lives.

That’s why we started our residents program last year to bring the best programmers we can find to Hacker School. Residents come for one or two weeks and work directly with students: They pair program, do code reviews, give short talks, run seminars, and bond with the batch.

If you’re a type systems nerd; if you want to dig your teeth into Scala, Clojure, Rust, or Julia; if you want to learn Python networking with the folks who wrote the books; or if you just want to pair program with Peter Norvig, Hacker School is for you. 

If you want to become a much better programmer and you’re intimidated by this list of residents, Hacker School is for you. (Read Nick’s blog post, What we mean when we say “hacker”, if you’re not sure if we mean you.)

Yes! The application deadline is this Thursday, May 2nd. After that, we’ll still accept applications, but it’s much harder to get admitted late. Apply now.
[Edit May 24th: And Alex Payne too!]


We want to be more transparent about Hacker School. We think this will help the world understand Hacker School better and make it easier for us to attract the kind of friendly, ambitious, and rigorous students who excel here.

As a first step towards more transparency, we’ve decided to publish the Hacker School User’s Manual. This was written as an internal document to help new students navigate Hacker School, but we also think it’s a good way to help people understand what we’re about. Hopefully this will answer some of the more common questions about how Hacker School works and maybe even encourage a few more people to apply.

The document is virtually identical to the version we use internally, except for the “Other resources” section. This section has a bunch of URLs and email addresses that are only useful if you’re a Hacker Schooler. It has been replaced with a brief summary.

There are many parts of this document we’d like to rewrite. There are sections that are out of date or no longer accurately reflect our opinions, but we don’t want to let the perfect be the enemy of the good. The information in the User’s Manual is much better than anything else we have published so far, and if it helps a few more people better understand Hacker School, it’s worth it.

There’s a lot more to do in our quest to be more transparent – there are blog posts to write, copy to revise, and of course the User’s Manual has to be updated before the next batch starts – but we think this release is a good start. Happy reading!


We have one more resident to announce for the summer 2013 batch: Alex Payne. Alex co-authored O'Reilly’s Programming Scala, was one of the first programmers at Twitter, and most recently served for two years as CTO of Simple.

Alex was in our first group of residents in the fall batch last year.  He embodies what we look for in residents: he’s talented, accomplished, and knowledgeable, but also humble, unassuming, and incredibly friendly. We’re delighted to welcome him back this summer.


People often ask how much programming experience you need to do Hacker School. We think that’s the wrong question to ask, because we don’t actually care how much experience you have. What we really care about is if you’d be a good fit for Hacker School and if Hacker School would be a good fit for you. We determine this primarily by figuring out if you love programming, so if you’re wondering if you should apply, the right question to ask yourself is, “do I really love programming?” If you do, you’d love Hacker School. If you don’t, you’d be unhappy here.

We can’t stress this enough: We spend almost all of our time at Hacker School coding. If you get excited thinking about how programming languages are written, spend hours on end solving Project Euler problems for fun, and get a burst of joy every time you squash a bug, you’re almost certainly a good fit for Hacker School. If you don’t enjoy these things, you won’t be happy here and you won’t get what you want out of it.

It may seem like we’ve sidestepped the original question, so I’ll answer it in a different way: How much programming experience do you need to do Hacker School? Enough to know you love it. This doesn’t have to be very much, although it can’t be nothing, because you can’t know you love something if you’ve never done it before. We’ve met people who have fallen in love with programing after as little as a few months. So don’t concentrate on how long you’ve been programming. We won’t be. We’ll be concentrating on how much you love it, and what you’ve done in the time you’ve been coding.

Try not to see this as “applying” to Hacker School. There aren’t any bars you have to get over, nor are there hard qualifications that we look for. Instead, see it as figuring out if Hacker School is what you really want. Read our about page and our FAQ. We try to be as explicit as possible to make it easy for you to figure out if you’ll enjoy and benefit from Hacker School.

Don’t fool yourself into thinking that you love programming if you don’t really. You’ll only end up unhappy down the road. Don’t lie to us and say that you really love programming if you don’t. Hacker School won’t make it easier for you to start your own startup or get a high paying job as a programmer if you don’t actually enjoy programming. You simply won’t get what you want out of it.

If you haven’t programmed before, there’s no time like now to start! There are lots of good resources online. We recommend getting your feet wet with Codecademy’s JavaScript lessons and moving on to Learn Python the Hard Way or Learn Ruby the Hard Way by Zed Shaw. Once you know a bit, you can have some fun solving Project Euler problems. They start out easy but get challenging quickly.

Have fun and do what you love. If that happens to be programming, you should come to Hacker School.


Update 2/25/14: Since we wrote this blog post, we’ve begun to deemphasize “student” in favor of “Hacker Schooler” and other context dependent words and phrases (see our blog post, “Words are hard”). While this post is out of date in its use of “student,” the rest of its advice is still relevant.

One of the surprising things we’ve learned while running Hacker School is that many of our students almost didn’t apply because they thought they wouldn’t get
in. This includes people who are exceptional Hacker Schoolers, and who are exactly the type of people we look for.

This scares us, since it suggests there are people who know about Hacker School and would be a great fit, but who aren’t even applying because they don’t think they’re qualified.

The goal of this post is to be as transparent as possible about what we look for, so that you apply if you’re one of these people. Similarly, we want to make it as easy as possible for you to show us that you’re one of these people, so we don’t make a mistake and miss you when reviewing applications.1

Here are the qualities we look for, and some tips on how to convey them in your application and interviews:

Admissions tips: Link to code you’ve written, a technical blog, or anything else that shows us that you program.2

Admissions tips: Tell us about your weaknesses as a programmer, and how you’d like to grow. (If you’re a new programmer, this can be hard, since you might not even know what you don’t know. That’s fine! It’s ok if your answer is “I’ve only been programming for eight weeks, and I’ve never written a program from scratch that’s longer than 20 lines.”).

You’re friendly. We’re a tight-knit community, and we spend three months in close quarters. Purely for our own happiness we don’t want to admit jerks. We also think this is pedagogically important.

You’re self-directed. Hacker School isn’t a programming “bootcamp.” We don’t have a fixed curriculum that we force-feed you, nor will we dictate how you spend your time. There are a ton of resources to take advantage of here (from facilitators to residents to the other students), but it’s ultimately up to you to get the most out of Hacker School, and this requires that you’re able to organize and prioritize your own time.

You’re intellectually curious. Your curiosity is your north star at Hacker School, and we want to see that you get excited about ideas.

Admissions tips: Tell us about something that engaged you intellectually when answering the question about the most fascinating thing you’ve learned recently. We want to hear about something surprising you’ve learned, and it doesn’t need to be about programming. For example, it could be about high-frequency trading or how ancient Greek math was more practical than most people think.

Admissions tips: We care more about depth than breadth – we’d rather people have a deep understanding of one language than a superficial understanding of three. We want to see that you understand the code that you’ve written and don’t just bang things together until they work. If you’re really new to programming, we want to see that you’ve previously been successful in learning something hard, whether that’s law or biomedical engineering.

Admissions tips: Use the Hacker School admissions process as an opportunity to evaluate us and decide if Hacker School is a good choice for you. We love it when people ask thoughtful questions that show they’re engaged and actively thinking about if Hacker School is the right choice for them.

If you think Hacker School is a good fit for you, we’d love to see you apply, and we hope this post helps you with your application.

Some basic tips for applying: Know what Hacker School is and what it’s not (you should read our about page, FAQ, and User’s Manual beforehand); use proper spelling and grammar (you don’t need to be “formal,” but you should write in full sentences); and demonstrate good judgement in how you present yourself in your application.↩

One negative signal for us is if you previously programmed and then stopped (e.g., you studied CS and then became a product manager). If this applies to you, tell us why you left programming and what’s changed in the interim. We also want to see signs that you’ve already started coding again.

Update: A couple of people were confused by this point, so to clarify: We’ve had students who went through traditional CS programs, hated them (and were almost driven away from programming), and were awesome Hacker Schoolers. So the above is a negative signal, but it only matters absent stronger positive signals. E.g., if the person actually programs, that’s a positive signal, and counts much more for us.↩


Little Lisp is an interpreter that supports function invocation, lambdas, lets, ifs, numbers, strings, a few library functions, and lists.  I wrote it for a lightning talk at Hacker School to show how easy it is to write an interpreter.  The code is 116 lines of JavaScript.  I will explain how it works.

First, let’s learn some Lisp.

This is an atom, the simplest Lisp form:

This is another atom, a string:

This is an empty list:

This is a list containing an atom:

This is a list containing two atoms:

This is a list containing an atom and another list:

This is a function invocation.  A function invocation comprises a list where the first element is the function and the rest of the elements are the arguments.  first takes one argument, (1 2), and returns 1.

This is a lambda, which is a function definition.  The function takes a parameter, x, and just returns it.

This is a lambda invocation.  A lambda invocation comprises a list where the first element is a lambda and the rest of the elements are the arguments.  The lambda takes one argument, "Lisp", and returns it.

Writing a Lisp interpreter is really easy.

The code for Little Lisp has two parts: the parser and the interpreter.

Parsing has two phases: tokenizing and parenthesizing.

tokenize() takes a string of Lisp code, puts spaces around every parenthesis and splits on whitespace.  For example, it takes something like ((lambda (x) x) "Lisp"), transforms it into  ( ( lambda  ( x )  x )  "Lisp" )  and transforms that into ['(', '(', 'lambda', '(', 'x', ')', 'x', ')', '"Lisp"', ')'].

parenthesize() takes the tokens produced by tokenize() and produces a nested array that mimics the structure of the Lisp code.  Each atom in the nested array is labelled as an identifier or a literal.  For example, ['(', '(', 'lambda', '(', 'x', ')', 'x', ')', '"Lisp"', ')'] is transformed into:

parenthesize() goes through the tokens, one by one.  If the current token is an opening parenthesis, it starts building a new array.  If the current token is an atom, it labels it with its type and appends it to the current array.  If the current token is a closing parenthesis, it stops building the current array and continues building the enclosing array.

When parenthesize() is first called, the input parameter contains the array of tokens returned by tokenize().  For example:

When parenthesize() is first called, the list parameter is undefined.  Lines 2-3 run and parenthesize() recurses with list set to an empty array.

In the recursion, line 5 runs and removes the first opening parenthesis from input.  Line 9 starts a new, empty list by recursing with a new, empty array.

In the recursion, line 5 runs and removes another opening parenthesis from input.  Line 9 starts another new, empty list by recursing with another new, empty array.

In the recursion, input is ['lambda', '(', 'x', ')', 'x', ')', '"Lisp"', ')'].  Line 14 runs with token set to lambda.  It calls categorize() and passes lambda as the input argument.  Line 7 of categorize() runs and returns an object with type set to identifier and value set to lambda.

Line 14 of parenthesize() appends to list the object returned by categorize() and recurses with the rest of the input and list.

In the recursion, the next token is a parenthesis.  Line 9 of parenthesize() starts a new, empty list by recursing with an empty array.  In the recursion, input is ['x', ')', 'x', ')', '"Lisp"', ')'].  Line 14 runs with token set to x.  It makes a new object with a value of x and a type of identifier.  It appends this object to list and recurses.

In the recursion, the next token is a closing parenthesis.  Line 12 runs and returns the completed list: [{ type: 'identifier', value: 'x' }].

parenthesize() continues recursing until it has processed all of the input tokens.  It returns the nested array of typed atoms.

parse() is the successive application of tokenize() and parenthesize():

Given a starting input of ((lambda (x) x) "Lisp"), the final output of the parser is:

After parsing is complete, interpreting begins.

interpret() receives the output of parse() and executes it.  Given the output from the parsing example above, interpret() would construct a lambda and invoke it with the argument "Lisp".  The lambda invocation would return "Lisp", which would be the output of the whole program.

As well as the input to execute, interpret() receives an execution context.  This is the place where variables and their values are stored.  When a piece of Lisp code is executed by interpret(), the execution context contains the variables that are accessible to that code.

These variables are stored in a hierarchy.  Variables in the current scope are at the bottom of the hierarchy.  Variables in the enclosing scope are in the level above.  Variables in the scope enclosing the enclosing scope are in the level above that.  And so on.  For example, in the following code:

On line 3, the execution context has two active scopes.  The inner lambda forms the current scope.  The outer lambda forms an enclosing scope.   The current scope has b bound to "b".  The enclosing scope has a bound to "a".  When line 3 runs, the interpreter tries to look up b in the context.  It checks the current scope, finds b and returns its value.  Still on line 3, the interpreter tries to look up a.  It checks the current scope and does not find a, so it tries the enclosing scope.  There, it finds a and returns its value.

In Little Lisp, the execution context is modeled with an object made by calling the Context constructor.  This takes scope, an object that contains variables and their values in the current scope.  And it takes parent.  If parent is undefined, the scope is the top, or global scope.

We have seen how ((lambda (x) x) "Lisp") gets parsed.  Let us see how the parsed code gets executed.

The first time interpret() is called, context is undefined.  Lines 2-3 are run to make an execution context.

When the initial context is instantiated, the constructor function takes the library object.  This contains the functions built in to the language: first, rest and print.  These functions are written in JavaScript.

interpret() recurses with the original input and the new context.

input contains the full example output from the parsing section:

Because input is an array and context is defined, lines 4-5 are run and interpretList() is called.

In interpretList(), line 5 maps over the input array and calls interpret() on each element.  When interpret() is called on the lambda definition, interpretList() gets called again.  This time, the input argument to interpretList() is:

Line 3 of interpretList() gets called, because lambda, the first element in the array, is a special form.  special.lambda() is called to create the lambda function.

special.lambda() takes the part of the input that defines the lambda.  It returns a function that, when invoked, invokes the lambda on some arguments.

Line 3 begins the definition of the lambda invocation function.  Line 4 stores the arguments passed to the lambda invocation.  Line 5 starts creating a new scope for the lambda’s invocation.  It reduces over the part of the input that defines the parameters of the lambda: [{ type: 'identifier', value: 'x' }].  It adds a key/value pair to the lambda scope for each lambda parameter in input and argument passed to the lambda.  Line 10 invokes the lambda by calling interpret() on the lambda body: { type: 'identifier', value: 'x' }.  It passes in the lambda context that contains the lambda’s scope and the parent context.

The lambda is now represented by the function returned by special.lambda().

interpretList() continues mapping over the input array by calling interpret() on the second element of the list: the "Lisp" string.

This runs line 9 of interpret() which just returns the value attribute of the literal object: 'Lisp'.  The map operation on line 5 of interpretList() is complete.  list is:

Line 6 of interpretList() runs and finds that the first element of list is a JavaScript function.  This means that the list is an invocation.  Line 7 runs and invokes the lambda, passing the rest of list as arguments.

In the lambda invocation function, line 8 calls interpret() on the lambda body, { type: 'identifier', value: 'x' }.

Line 6 of interpret() finds that input is an identifier atom.  Line 7 looks up the identifier, x, in context and returns 'Lisp'.

'Lisp' is returned by the lambda invocation function, which is returned by interpretList(), which is returned by interpret(), and that’s it.

Go to the GitHub repository to see all the code.  And look at lis.py, the dazzlingly simple Scheme interpreter that Peter Norvig wrote in Python.


I’m excited to announce that we’ve partnered with Juniper Networks.

Juniper has been a wonderful supporter of Hacker School: They’ve both sponsored our summer 2013 batch and provided 20 $5,000 grants for female programmers. Although Hacker School is free for all students, living in New York for three months is most certainly not, and these grants made a huge difference for a number of women who would otherwise have been unable to attend Hacker School.

Throughout our work together, Juniper has proven itself to care deeply about supporting programmers, and increasing the number of female developers in particular. This support helped make our summer 2013 batch our largest yet with 70 students.

This batch has also been one of our most diverse: we welcomed robotics and statistics Ph.D’s, a former professional ballet dancer, a 20-year veteran of Wall Street, our first high school student, and bright and experienced engineers from some of the world’s top startups and tech companies. Seventy-five percent of our students came from outside of New York, 15% came from outside of the country, and 30% were female.

Hacker School works best with such a diverse student body. Our model is based in large part on people coming together from a range of backgrounds and experience levels, and helping each grow as programmers. Juniper’s support this summer has helped make this possible.

Thank you, Juniper!


Today we’re announcing the Hacker School Maintainers Program. The Maintainers Program will bring maintainers of free and open source software (FOSS) into Hacker School, either physically or virtually, to help Hacker Schoolers contribute to their projects. We’re extremely excited to have Stefan Karpinski, David Nolen, and Glyph as our first maintainers.

We’re running this experiment for three reasons. First, we think it will be a useful piece of optional structure for some Hacker Schoolers. Second, we would like to give back to FOSS communities, many of which we owe a great deal to. Finally, we would like to experiment with running parts of Hacker School asynchronously over the Internet.

We often get asked  “How do you learn at Hacker School without any structure?” This is a confusing question for us because we don’t believe structure is inherently bad. We believe people learn best when they are driving their own education and studying things that interest them. That doesn’t mean that we don’t think structure plays a part in the learning process, just that it must be self-imposed.

Few people can learn without structure, but the pieces of structure that work for you may be different than the ones that work for someone else. Furthermore, coming up with structure on your own is hard. This is why we spend so much time thinking about how we can provide optional structure at Hacker School. We like optional structure because it allows you to pick the pieces that work for you and ignore everything that doesn’t.

We’ve been bitten by having too much required structure before. One year ago, in our summer 2012 batch, we held an Open Source Week, where for one week everyone stopped what they were working on and contributed to FOSS projects. Some Hacker Schoolers loved it and got a lot out of it. Others would have rather stayed home.

Contributing to FOSS isn’t right for everyone. Some people find it uninteresting. For others, it simply isn’t the best way for them to grow as a programmer. But for those for whom the time is right, contributing to FOSS projects can be a very important step in their evolution as programmers and we’re excited to make it a larger part of Hacker School.

Hacker School wouldn’t be possible without free software. We would like to find ways to give back to the communities and projects that have made our lives better. Many of us still remember what it was like to have to pay hundreds of dollars for a C compiler. Now it’s hard to imagine a world where we don’t have the freedom to read and modify the source of the tools we use every day. We’re not sure what sort of impact the Maintainers Program will have, but we won’t consider it a success unless the projects and maintainers we work with do, too.

Hacker School would be far worse if it didn’t take place in person. Friendship, comfort and trust, all of which are necessary for effective learning, are more easily built in person than online. This means that many of the benefits afforded to internet businesses are not available to us. We’d like to find ways to use the Internet to our advantage without sacrificing the things that make Hacker School great.

As an experiment, we’ve designed the Maintainers Program to work even if a maintainer can’t physically be at Hacker School. We’re going to use all the software we have at our disposal—video chat, ssh, screen, tmux, mailing lists, and more—to make the Maintainers Program work as seamlessly as possible whether or not the maintainer is in the same room or even available at the same time.

The Maintainers Program is simple in practice: contributing to FOSS projects can be hard, especially if you’ve never done it before. Maintainers will help Hacker Schoolers navigate their project, understand what needs to be done, and give feedback and code review. There are no guarantees that your code makes it into a project, but we hope that having maintainers available for guidance will make it more likely.

We want our maintainers to be genuinely nice people. This is why all of our initial maintainers are past residents. Stefan has been a resident every batch since we started the Residency program. He’s a great evangelist for the Julia programming language and because Julia is written almost entirely in Julia, the path from user to contributor is a smooth one. David was a resident in our fall 2012 batch and he’s been a constant presence around Hacker School ever since. His enthusiasm for ClojureScript and core.async is infectious and he’s been instrumental in helping Hacker Schoolers contribute to open source projects in the past. Glyph is the founder of the Twisted project and an incredibly warm person. He was a resident in our winter 2013 batch and we’re thrilled that we could find a way to get him involved with Hacker School again.

We’re also looking for a few more maintainers. We’re going to be asking people we know for recommendations, but we’d also love to have your input. We’re looking for maintainers who are warm and empathetic and who have projects with existing communities of contributors. If you think of someone (or want to nominate yourself), you can use this Google form.

As much as we’d like to respond to everyone who nominates someone, we simply don’t have the time, so don’t expect a response unless we have questions about the person you’re nominating.

We’re really excited to be welcoming Stefan, David, and Glyph back for another batch of Hacker School. If contributing to Julia, ClojureScript, core.async or Twisted is something that you’d enjoy doing, there’s still time to apply for our fall 2013 batch.


This summer’s residencies have been our most successful so far. Residents and Hacker Schoolers worked together to write interpreters and compilers, learn about their learning styles, and compete in the ICFP contest, along with dozens of other projects and collaborations.

We’ve written previously about the minimum amount of experience you need to come to Hacker School.  Sometimes people ask the opposite: can you have too much experience for Hacker School to be a good fit?  We believe there isn’t an upper bound. Even experienced programmers can improve with three months of focused, deliberate practice in a supportive community.  Residents help us build that community, so that even the most experienced Hacker Schoolers have a chance to work with someone who will blow their minds.  This summer’s ten smart, knowledgeable, and kind residents were a tremendous asset to Hacker School and set a high bar for future residents.

With this backdrop, we’re delighted to welcome eight residents this fall. Mel Chua and Lindsey Kuper are coming back for their second residencies, Jessica McKellar is coming back for her fourth, and Will Byrd, Philip Guo, Jacqui Maher, Yaron Minsky, and Alex Rudnick will be joining us for the first time.

We’re equally excited to have three great previous residents – Stefan Karpinski, Glyph, and David Nolen – kicking off our Maintainers Program.

You can read more about our residents, and there’s still (barely) time to apply for the fall 2013 batch.


People frequently ask us who comes to Hacker School. They usually have some preconceived notions about what the “typical” Hacker Schooler looks like, and they’re often surprised when they learn who our alumni actually are.

Much of this confusion comes from the fact that Hacker School is incredibly diverse. There are now about 300 Hacker Schoolers from our first two and a half years, and they come from a staggering array of backgrounds. For most demographic questions, the answer to “Have you had any Hacker Schoolers who __?” is probably “Yes.”1

The goal of this post is to dispel some common myths about who comes to Hacker School. The following data comes from our current batch (fall 2013), which is our eighth batch.2

Myth #1: Hacker School is only for new programmers

False. While we’re very much open to relatively new programmers, nearly two-thirds (62%) of our current batch had been programming for at least two years prior to coming to Hacker School, and 41% of the batch had been programming for more than three years.

Additionally, nearly half of the current batch (45%) worked professionally as programmers prior to Hacker School, and 42% of those (19% of the entire batch) had at least three years of professional programming experience. Just under a quarter (22%) have undergraduate computer science degrees, and half of those (11% of the entire batch) have graduate degrees in computer science.

Myth #2: Hacker School is only for experienced programmers

False. More than a third (37%) had been programming for less than two years; 8% had been programming for less than six months.

Just over half (55%) have never worked professionally as programmers, and more than three quarters (78%) don’t have computer science degrees.

Myth #3: Hacker School is only for people in New York

False. Most people in the current batch (72%) moved to New York for Hacker School.

And people aren’t just coming from neighboring states. The current batch hails from California, Colorado, Georgia, Kentucky, Massachusetts, Michigan, New Jersey, Oregon, Pennsylvania, Texas, Virginia, Washington, and Wisconsin. There are even a few from New York.

More strikingly, 29% of the current batch came from outside the US. This batch includes Hacker Schoolers from more than a dozen countries, including Belgium, Canada, France, Hong Kong, Italy, Japan, Norway, Russia, Sweden, Switzerland, UK, and Ukraine.

Myth #4: Hacker School is only for young people and recent college grads

False. The average age in the current batch is just over 28, with ages ranging from 19 to 58. There are more people in the current batch over 30 than under 25.

There are of course characteristics that Hacker Schoolers have in common. This is unsurprising, since we look for smart, friendly, self-directed, intellectually curious people who enjoy programming and want to get dramatically better.↩

We didn’t have this data until very recently. Since we don’t make admissions decisions based on where people live, how old they are, or what degrees they have, we don’t ask any of these questions on our application. We had to survey our batch to write this post.↩


We’re happy to announce that Dropbox, Etsy, Jane Street, Tapad, and Tumblr have all sponsored grants for female programmers for our current batch of Hacker School. Each grant is for $7,000, and makes it possible for a woman to attend who would otherwise not be able to afford to (Hacker School remains free for everyone, so the grants are used for food, housing, and other living expenses during the batch).

This support has helped make our current batch 42% women. These grants make Hacker School bigger, more diverse, and a better experience for everyone involved.

These grants are our hack for how to have a gender-balanced environment without negatively impacting men or lowering the bar for women. The grants work because they increase the pool of qualified women who are able to do Hacker School.

We also believe the grants help signal to women and men around the world that Hacker School is institutionally and structurally committed to having a gender-balanced environment. This helps attract phenomenal people who don’t need financial assistance, in addition to the people who do.

One of the many benefits of having a gender-balanced environment is that, at least within the confines of Hacker School, the pressure to represent or focus on “women in programming” largely fades away, and people are free to focus on programming rather than rehashing tired arguments.

In fact, one of our social rules is that Hacker School is not a place to discuss gender or sexism in tech. This is because the purpose of having a gender-balanced environment is to have a place where women can simply be programmers, rather than forever being seen as “female programmers” or experiencing stereotype threat. There are many places in the world to discuss and debate these issues, but there are precious few where people can avoid them. We want Hacker School to be one of those places (read more in our User’s Manual). We’ve heard from many women that this was one of the most refreshing aspects of Hacker School.

On behalf of all of Hacker School, we’d like to thank Karen Sperling at Dropbox, Collette Ricard and Kellan Elliott-McCrea at Etsy, David Powers and Caitlin Maynard at Jane Street, Michael Moss at Tapad, and Sean McDermott at Tumblr, who have all been essential to making this possible. Thank you!


At Hacker School, we spend a lot of time thinking about what it means to be a
good programmer. My goal with this post is to share some of our thinking on
this topic and to hopefully help people better understand Hacker School in the
process.

First, a quick note: This is just one way to think about becoming a better
programmer. It’s almost certainly not the only way to think about it and you
may find some other way more useful to you.

This is a list of what we believe are fundamental qualities that all good
programmers share. It is based on our observations from the more than two years
that we’ve been running Hacker School. It’s not perfect—there are
qualities that we’re missing and there’s some overlap between the ones that we
have listed—but it’s been very useful for us so far. We expect that it
will grow and change as Hacker School does.

Programming languages are just tools for telling computers what to do. It is
better to have a strong command of one than a weak command of a bunch. Good
programmers have at least one language that they know inside and out and can
reach for to easily solve whatever problem is at hand.1

Being a systematic debugger means that you have a good mental model of your
code and that when you run into a bug—that is, when your program doesn’t
work as expected—you generate hypotheses about what’s wrong, instead of
blindly changing things until your program works.

Most programs interact with the outside world, so having an understanding of
your environment is important. This includes the I/O and concurrency primitives
that your language provides, the way your language finds, loads, compiles, and
runs code, the way that your program gets info from the outside world (e.g.,
environmental variables and command line arguments), and the way your OS
handles file access, device access, search paths, etc.

Knowing how your hardware works makes it easier to write efficient programs.
Even if you are writing programs in a higher level language, understanding
things like the call stack, the MMU, the cost of context switching, the memory
hierarchy, and the characteristics of the network you are connected to will
inform your programming decisions.

A lot of people confuse algorithmic thinking with knowing a bunch of particular
algorithms like quicksort or binary search.

An algorithm is a set of steps describing a calculation. Much of programming is
simply describing algorithms to a computer. Being comfortable with algorithmic
thinking means having good intuition for how to store and manipulate your data,
being able to think both iteratively and recursively, and being able to reason
about the performance characteristics of the code you write.

Programming is not as math-heavy as many non-programmers think, but as you
start tackling tougher problems, you’ll find that being comfortable with math
comes in handy. Many interesting areas of programming like computer graphics,
signal processing, and cryptography require a deep understanding of math. Even
just measuring the performance of your code can require some statistical
thinking.

It is hard to imagine a good programmer who cannot write a program from
scratch.

Most of the time you’re not writing a program from scratch. Instead,
you’re working with other programmers on a large project.

Well-structured code allows you to easily navigate up and down through layers
of abstraction. In a well-structured program, you can ignore implementation
details when they don’t matter and modify the implementation without having to
make changes in all the places where the code is used.

Code radius is a term that Alan came up with.
Your code radius is the size of the largest program you’re comfortable writing
from scratch. Increasing your code radius takes practice. The structural tools
that work well for a 500 line program are not necessarily the same as the ones
that work for a 5,000 line program or a 50,000 line program.

Often times it’s faster to try out a few different solutions and decide which
is the most elegant than to figure out the correct one just by thinking about
it. If you find “quickly” to be too subjective, consider the inverse: It’s hard
to imagine a good programmer who is slow.

Good programmers use their tools effectively. This doesn’t mean you have to use
all the tools available to you in order to be a good programmer—not
everyone likes IDEs and plenty of good programmers prefer printf to a
debugger—just that good programmers are productive with the tools they
choose to use.


      This is not to say that all programming languages are equivalent, that
they are equally good at all tasks, or that it isn’t worth learning more than
one programming language. Just that all good programmers have a deep
understanding of at least one language.↩



Treating people like adults is a core tenet of Hacker School. That’s because
trusting people to make good decisions for themselves is a huge part of
self-directed education. In the fall 2012 batch, we made two small, seemingly
innocuous changes to the structure of Hacker School that had the unintended
effect of not treating people like adults. The changes had a surprisingly
large, negative impact on Hacker School.  Here’s what happened and what we do
differently now.

The first change we made was giving each facilitator a group of Hacker
Schoolers to get to know over the course of the batch. We did this because we
wanted to develop a good mental model of each programmer at Hacker School, and
make sure no one slipped through the cracks. The outwardly visible changes were
minimal. Everyone got assigned to a morning checkin group with their
facilitator, and each facilitator met personally with each Hacker Schooler in
their checkin group around once a week.

In the previous batch, each facilitator had been assigned to one of our three
rooms, and Hacker Schoolers tended to go to the same room every day out of
habit. Checkin groups were large—nine or ten people to a group, two
groups per room, one facilitator per group—so this new arrangement felt
pretty similar.

The second change we made was suggested by Hacker Schoolers from the previous
batch. Since the beginning of Hacker School, we’d had a mandatory, large group
dinner every week. Twice in the summer 2012 batch, we experimented with
splitting up into smaller groups and going to restaurants for dinner as a
change of pace. Everyone seemed to like the smaller dinners because they were
more intimate. At the end of the batch, a number of people told us that we
should make all dinners small instead of large, so we decided to give it a
shot.

Both of these changes felt minor, but their side effects were largely negative
and they didn’t do a good job at accomplishing their goals.

Knowing that everyone had a facilitator assigned to them introduced a different
power dynamic and encouraged people to treat us like teachers and to not take
responsibility for their own learning. Checkins were delivered to facilitators
and felt a lot like reports on homework assignments (which we don’t have). A
lot of people didn’t believe checkins were valuable, so we had trouble
convincing everyone to show up to Hacker School on time. Our mental model of
everyone did get better, but the negative effects of the change far outweighed
the positive ones.

Assigned small group dinners felt like class trips and we felt like chaperones.
We would say things like “Is everyone here? OK, let’s go!” The class trip
dynamic extended to the dinners themselves: they didn’t feel like relaxed meals
between peers and weren’t the bonding experiences that we hoped they would be.

Since last fall, we’ve made changes to checkins and dinners to make sure that
we’re treating everyone at Hacker School like an adult.

Facilitators no longer have assigned Hacker Schoolers. Checkin groups are now
half the size and often don’t contain any facilitators. Hacker Schoolers are
responsible for structuring their checkins however they see fit. This means we
don’t have as good a mental model of every Hacker Schooler, but it turns out
that in an environment where everyone is responsible for their own education,
having a good, centralized mental model of each person is much less important
than we originally thought.

Dinners are now in one big group, not at restaurants, optional, and always
accompanied by a talk. Having large non-restaurant dinners eliminates the
chaperoning, making them optional trusts each person to decide whether or not
they should come, and having talks makes them worth coming to.

There’s also been a more fundamental change. Since last summer, it feels like
we’ve also become a happier organization. It’s impossible to prove the
connection, but I feel like it has a lot to do with running Hacker School in a
way that’s more in line with our values.


We’re excited to announce that Google is sponsoring over $150,000 of need-based
grants for female programmers to come to Hacker School. These grants will allow
us to provide financial assistance for living expenses to women for our
upcoming batch and hopefully beyond. (Tuition, of course, remains free for
everyone; the grants are only for living expenses for those in financial
need.1)

This is the largest sponsorship of grants we’ve ever received, and we’re
incredibly thankful for Google’s support. For nearly two years, we’ve worked to
secure grants for female programmers who cannot afford to live without an
income during Hacker School. Getting enough grants has been (and remains)
a challenging and time-consuming process. In addition to helping make Hacker
School bigger and better, Google’s generous support will give us a bit of
breathing room over the next months, and allow us to spend even more time on
improving other parts of Hacker School.

Thank you, Google!


      You can read more about our thinking behind these grants and how they
      work in some of our
      previous
blog posts.↩



We’ve got exciting news: We’ve hired Tom Ballinger and Alan O'Donnell to be facilitators for the next batch of Hacker School! I can’t describe how happy we are to have them join us.

Alan was in the first batch and has been part of Hacker School since the very beginning. He’s a polyglot and enjoys coding in everything from C to Clojure. Unsatisfied with the mathematical purity of Haskell, he’s recently started learning Coq, a language so pure it’s not even Turing complete.

Tom was in the most recent batch and was a tremendous asset to the group. I checked my notes from when I interviewed him for the batch, and I had exactly one concern: Tom was so excited about doing Hacker School I was worried we wouldn’t live up to his expectations. Given that he’s agreed to join us, I guess we did ok.

Tom and Alan embody the best of Hacker School: They love programming and are smart, intensely intellectually curious, and extremely friendly. They’re also proof that you don’t need to study computer science to become a great programmer. In fact, neither of them were CS majors or followed a traditional path to programming.

I can’t think of a single time I’ve heard either of them say something mean. On the other hand, I can think of countless times I’ve heard them ask thoughtful questions, or go out of their way to help others improve their understanding. They’re egoless programmers; their focus is always on helping themselves and others learn, and never on showing off how much they already know.

For these and many more reasons, we know that they’ll be fantastic facilitators. They have Hacker School in their DNA.

Please join Dave, Sonali and me in welcoming Tom and Alan. Together we’re going to continue to build Hacker School into the best community to learn and grow as a programmer.

Now back to reviewing applications for the next batch!

– Hacker School
Nick, Dave, Sonali, Tom and Alan

P.S. We think it’s important to have both male and female facilitators, and we’re cognizant of the fact that we just hired two more dudes. We also feel strongly about only hiring people who truly grok Hacker School, and to do that they need to have experienced it first hand. We’ll be hiring more women as the gender balance of our alumni improves.


We don’t like to use the term “student” to refer to people who come to Hacker School, but we’ve had trouble finding another word to replace it.

Words are hard to choose because they come with context. In some ways, “student” is a good word for us to use. Almost everyone who comes to Hacker School can identify as having been a student at some point in their lives. This makes “student” friendly and familiar. Calling yourself a student can also signal your commitment to learning.

Unfortunately, “student” brings some non-Hacker Schooly context with it. “Student” implies a traditional student-teacher relationship that isn’t present at Hacker School. It implies that there is someone else responsible for your education, when there is not.

We’ve tried using other words, but none of them are perfect. A safe one is “Hacker Schooler.” All it implies is that you’ve decided to come to Hacker School. Unfortunately “Hacker Schooler” can be a bit of a mouthful and cumbersome to use in some situations.

Another term we’ve considered using is “hacker.” The word “hacker” describes a very particular identity and subculture and there are plenty of people who make great Hacker Schoolers but don’t identify as hackers.

The word “developer” has similar problems, but for different reasons. It has a professional connotation similar to “software engineer,” but being a professional programmer, or wanting to be one, is not a requirement for coming to Hacker School either.

“Programmer” is actually not bad. All that it implies is that you write computer programs. Everyone at Hacker School does that. Still, even “programmer” has its problems. Not everyone who applies to Hacker School identifies as a programmer when they apply.

“Student” isn’t the only word that we struggle with. “School” has given us even more trouble and it has many of the same problems. A school is a place of learning, which is a good start, but it also has teachers, grades, homework, and curriculum, none of which are part of Hacker School. Explanations of Hacker School often start by explaining that it’s probably not like any school you’re familiar with.

Calling ourselves a school causes all sorts of confusion. Experienced programmers think they have too much experience for Hacker School even though Hacker School is designed for people with a wide range of experience levels,1 our alumni have trouble describing what Hacker School is like to other programmers, and companies have a hard time understanding how they should compare us to other places they hire from.

This seems to be a problem for anyone trying to explain the unfamiliar. If you invent new words, few people will know what you’re talking about, but if you make analogies using existing words, you bring along all their context, whether you want to or not.

There are also new programmers who think they don’t have enough experience for Hacker School, though this probably doesn’t have to do with the word “school.”↩


Ever since we ran our first experimental residents program in the fall 2012 batch, residents have become an institution at Hacker School.  We’re delighted to welcome another exciting crop for the winter 2014 batch.

Five of our former residents are joining us again: Mel Chua, the rare engineering education expert who’s also an engineer herself; Stefan Karpinski, a co-creator of Julia who’s gotten Hacker Schoolers hooked on LLVM, dynamic dispatch, and the intricacies of floating-point numbers; Lindsey Kuper, a researcher on the cutting edge of deterministic parallel computing; Kevin Lynagh, a prolific ClojureScript and JavaScript hacker with one of the coolest tattoos we’ve ever seen; and Jessica McKellar, a Twisted maintainer, Python core contributor, and talented nerd-sniper.

Three new residents are joining us as well.  Evan Czaplicki is the creator of Elm, a purely functional language for web programming. Greg Price is a kernel hacker, programming language enthusiast, and systems programmer who’s worked at Ksplice and Quora. Robert Lefkowitz, aka r0ml, gave a talk about APL during the last batch of Hacker School that had more Q&A and more laughter than any other talk we’ve had.

The Maintainers Program didn’t work out as well as we hoped last batch, and we’re discontinuing it (in its current form, anyway).  We found that for Stefan, being a maintainer was just like being a resident—he was already helping Hacker Schoolers contribute to Julia. For Glyph and David, Hacker Schoolers weren’t very interested in contributing to their projects. We’re still interested in running experiments that help Hacker Schoolers contribute to free and open source software, and we’ll have more experiments in the future.

We want to create an environment where all Hacker Schoolers can become much better programmers over the course of the batch.  Residents help make sure that even the most advanced Hacker Schoolers—many of whom have more expertise than facilitators—get exposed to new ideas, have their thinking challenged, and work with specialists in industry and academia. We can’t wait to see what the winter batch will do with this round of residents.


In August of 2012, we made the mistake of sharing how many people had applied to our summer batch, and with that we implicitly shared Hacker School’s acceptance rate. We now believe this was a bad decision and we no longer publish our admissions statistics. 

That’s because we think about admissions differently than much of the world. While most colleges and universities want to make their acceptance rates as low as possible, we’d be thrilled if we could increase ours. We think there are several reasons why low acceptance rates are bad, and few reasons why they’re good for us.1

Our acceptance rate is the complement of our rejection rate, and our rejection rate is a direct measure of how much time we spend reviewing and interviewing applicants who we conclude aren’t good fits for Hacker School. Why would we try to spend more of our and others’ time doing that? We currently spend a few hundred hours each batch on admissions, and our goal is to reduce this number, not increase it.

There are two ways to make your acceptance rate go down: You can either get more unqualified applicants to apply (and then reject them) or reject qualified applicants who you would have otherwise accepted. Neither of those options make any sense to us. Our goal is to get more qualified people to apply and then accept them.

In our experience, bragging about how few people you accept has the negative effect of encouraging people to apply who are just looking for something impressive to put on their resumes, and who don’t actually have a good sense of what Hacker School is and why they want to do it. Worse, it can discourage qualified people from applying because they’re convinced they’ll never get in. This scares us, since the latter group is thoughtful enough to pause and reflect on whether they and Hacker School are a good fit. And those are much more likely to be the people who would do well at Hacker School.

There is one case when it’s clearly been helpful for us to have a low acceptance rate: When talking with companies about recruiting Hacker School alumni. Companies are always happy to hear we have a low acceptance rate, presumably because they think it’s a good proxy for the quality of our alumni. We’d happily do away with this advantage in exchange for a higher acceptance rate and more qualified people at Hacker School.

Traditional colleges and universities have other reasons for wanting low acceptance rates, for example, because it boosts their rankings on lists of the “best” colleges. We don’t – and, thankfully, don’t need to – care about such things.↩


Applications for both the summer 2014 and fall 2014 batches of Hacker School are now open. Batches are filled on a rolling basis and applications close either two weeks before the batch begins or when the batch fills up,1 whichever happens first, so the earlier you apply, the better. If we admit you to Hacker School but the batch you apply to is already full, you’ll have the option of deferring to a later batch. Before applying, we strongly encourage you to read our about page, FAQ and User’s Manual.

This is the first time we’ve opened applications for multiple batches at once. Traditionally, we’ve opened applications two to three months before each batch starts. Opening applications for the fall 2014 batch (and every subsequent batch) at least six months ahead of time and doing interviews on a rolling basis will give people who need more than a few months of heads-up the chance to do Hacker School. Knowing the size of future batches further in advance gives us more certainty and allows us to plan for upcoming batches more effectively.

Because we’ve changed to rolling admissions, we no longer have fixed application deadlines. While it’s better to apply earlier, don’t stress too much about delaying for a few days, especially if we’ve recently opened applications for the batch you’re applying to. We don’t believe the application should take long to finish, but it’s better to submit a good quality application than a rushed one.

Good Hacker School applications are well written. Being able to write well isn’t an official qualification for Hacker School, but reality has made it a de facto one. As we get more applications, we have less time to read each one. This means that if you’d make an awesome Hacker Schooler but it doesn’t come across in your application, there’s a good chance that we’ll miss you. Writing clearly will help us see that you’re a friendly, self-directed, intellectually curious and rigorous person. You can find out more about what we look for in Hacker Schoolers in an older blog post.

Hacker School is a place to become a dramatically better programmer, whether you’ve been programming for 20 years or just for a few months. If the idea of spending three months with like minded people building an OS kernel, a pattern matching library, a BitTorrent client, a game engine, or anything else that strikes your fancy sounds exciting, Hacker School is for you. If you don’t know what any of those things are, don’t worry. Hacker School is for you too.

At Hacker School, we value intrinsic motivation and self-direction. Hacker School is free for everyone. The environment is supportive, gender-balanced, and intellectual. If hearing this gets you excited, we’d love to have you apply.

Our main constraint is physical space. If we accept enough people into a future batch, we will move to a larger location.↩


We’ve made a lot of mistakes over the past three years of Hacker School. Sometimes our bad decisions are immediately obvious, but sometimes they’re more subtle and it’s only with time, feedback, and reflection that we realize we’ve screwed up. These mistakes are like poor architectural decisions that don’t manifest themselves until you’ve lived with them for a while.1

This is a post about mistakes we’ve made and tried to fix. In the interest of brevity, this post is greatly abridged, since the entire list would be much too long and embarrassing.

We no longer believe people must “love” programming to come to Hacker School. We learned that many of our alumni nearly didn’t apply because they worried they didn’t really “love” programming. Around the same time, Hacker School alumna Sunah Suh recommended the excellent book Unlocking the Clubhouse, which presents strong evidence that this language is gendered. We’ve since stopped saying that people must “love” programming (see my post about the word “hacker”).

We no longer tell people not to think about jobs until the end of the batch. The purpose of going to Hacker School is to be become a better programmer, and so we long advised people not to get distracted by jobs during the batch. But we found that this advice was hard for many people to follow, since most people quit their jobs for Hacker School, and it’s natural to think about what you’ll do afterwards. Given this, we now help people with jobs whenever they want and have optional interview prep sessions throughout the batch on Fridays. We’ve found that these changes have made it easier for people to focus on their education (and not worry about jobs) during the rest of their time at Hacker School.

We no longer have assigned facilitators or mandatory group dinners. These were two things we experimented with in the fall of 2012. At the time, they seemed like minor, positive changes, but we now see them as straying from our core principles. Dave wrote about this in detail in his post, Treating people like adults.

We don’t compare applicants to alumni who share superficial characteristics or demographics. This mistake is a bit different from the others because it’s not something we ever intentionally did. We realized about a year ago that we frequently found ourselves saying, “applicant X reminds me a lot of Y,” where X and Y more often than not shared the same race and gender, or other irrelevant demographics or traits. A similar voice or speech pattern can conjure up feelings, good or bad, about someone else and lead you to wrongly project other less superficial attributes onto that person. Given this, we now have a policy of not making comparisons betweens people who share superficial characteristics and call each other out any time we do.2

Our interview process now includes a pairing session. For our first five batches, our interview process didn’t include any programming or time working with applicants. In retrospect, this seems obviously wrong: One of the biggest questions we try to answer in our admissions process is what it’s like to work with someone, and yet we were never working with them at any point in the process. We’ve since tried to fix this by turning our second round interview into a pairing session, where the goal is to treat applicants as if they were already working with us at Hacker School. They get to choose the language to use and the project to work on, as well as what specifically they want to do (e.g., to add a small new feature, refactor a chunk of their code, etc.). Many applicants have told us that they really enjoyed the pairing sessions, and benefited from it regardless of whether they got in.

We shouldn’t have named our company “Hacker School.” Both parts of our name have caused us trouble: Hacker because so many people take it to mean a person who breaks into computers rather than a clever programmer.3 School because it implies a rigid and traditional approach to education that we emphatically reject. This mistake is different from the others on this list because we haven’t yet corrected it, and probably never will, given how time-consuming and costly it would be.

If only we could wave a wand and discover the things we do now that we’ll someday consider mistakes!↩

We’re also updating our internal review system to obfuscate applicants’ names to avoid any subconscious bias during our application review process. We’ll soon be considering applicants named “Blue Dart” and “Purple Rover” rather than “Jane Doe” and “José Smith”.↩

We’ve also struggled to a lesser extent with the stereotype of “nerdy white guys” that many people associate with the word “hacker.” See our post, What we mean when we say “hacker”.↩


Update 6/30/14: We’ve hired someone for this job. You can read more in our blog post “Welcome Rachel!”

We want to hire an operations person. Up until now, everyone we’ve hired has been a programmer and a Hacker School alum. We’ve done many hundreds of programming interviews, but we haven’t interviewed for non-technical roles before, so this is uncharted territory for us. It’s also incredibly important: Whomever we hire for this role will be essential to our continued growth and success.

In much the same way that we think grades and exams are poor proxies for learning, we think many interviews are poor proxies for how people actually work and what companies are actually like. We want our interview process to give you a sense of what it’s like to work with us, and vice versa. Our goal is to have a process that accurately reflects our company.

We also want to clearly explain the expectations for this job and the details of our interview process ahead of time, so there aren’t surprises.

The job

We’re looking for someone to take charge of operations, accounting, and event coordination at Hacker School. This job will entail everything from managing our office space to handling inbound email to planning group alumni events to working with our lawyers and accountants. It will also entail working closely with the entire company (all eight of us!). Since we are a small team, everyone has significant responsibility and helps define and determine our future growth and success.

Who we’re looking for

We’re looking for someone who writes well, exercises good judgement, is extremely effective, and is energized by being around other people.

What we offer

A few extra things to know

What to expect from our interview process

The first step is to email your resume or LinkedIn (just make sure it’s public) to ops@hackerschool.com, along with a paragraph or two about why you’re interested in the job. Please use thoughtful, conversational English.

Next, we’ll set up a phone call with one of the founders (Nick, Dave, or Sonali). This will be a short call to learn more about your background and interests, to share more about the job and Hacker School, and to answer any initial questions you have.

If that goes well, we’ll send you a short writing task, which will be representative of some of the work the job requires.

Lastly, we’ll schedule a half or full day of in-person interviews. This will be a series of interviews each with one or two Hacker School employees, as well as a lunch with several of us (we want you to get a chance to meet everyone in the company). We will do our best to make individual interviews representative of the actual work the job entails. For instance, we’ll tell you about a real challenge we’re facing, and you and the interviewer will work together to solve it. We’ll also give you lots of opportunities to ask us questions.

We think it’s rude when companies go silent and stop responding to people they’re interviewing. We promise not to do this, and will follow up with everyone who makes it to the phone round promptly with whether or not we’re interested in moving to the next round. Since we don’t know how much inbound interest we’ll get, we can’t promise to send personal responses to everyone who applies, but we will reply with a quick thank you and acknowledgement that we got your message.

We’ll do our best to give you an offer (or a no) within one week of your in-person interviews. We do not give exploding offers.


Hacker Schoolers have helped to define a lot of what makes Hacker School great. This is true both in the obvious sense that Hacker School is fundamentally composed of the people who participate in it, but also in the deeper sense that they organize and create many of the things that make up the Hacker School experience.

When people come up with ways to improve Hacker School they don’t need anyone’s permission to see them through. If a Hacker Schooler wants to organize a seminar on Lua or get more regular code review, they can make it happen.

In past batches, people have started SICP and Nand2Tetris reading groups, set up the Hacker School Beverage Coalition, run Iron blogger challenges, and organized everything from poker nights to Code Review Thursdays.

But because we have month-long gaps between batches, we effectively throw out all of these additions to Hacker School at the end of each batch, and we never get to take advantage of the momentum we’ve built up.1 It’s also emotionally and psychologically taxing to always be starting fresh and to have to reestablish the social environment.

Beginning this summer, we’re going to try an experiment: We’re going to have overlapping batches, with a new batch starting every six weeks. This is different from what we’ve done for the past three years, which was to run three batches a year with one-month breaks in between. Batches will still be about three months long.

Since batches will overlap, each batch will get to spend about six weeks with the batch that started before it and about six weeks with the batch that comes after it.2 We’re calling each six-week period a rotation.



We think this will improve Hacker School in several ways.

First, more of the improvements people make to Hacker School will persist between batches. We think this will increase the rate at which Hacker School improves.

Second, Hacker Schoolers will still get a core group of people to bond tightly with — the people in their batch — but they’ll also get to meet and work closely with more Hacker Schoolers than they otherwise would be able to.

Lastly, Hacker Schoolers starting their first rotation will benefit from being around the people who are doing their second rotation. The Hacker Schoolers who have already gotten the lay of the land will be able to help the newcomers more quickly acclimate to Hacker School’s environment.

Starting fresh each batch does have at least one advantage: it lets us more easily recover from mistakes we’ve made.↩

This won’t be true for our batch beginning on June 9th, since it will only overlap with the following batch. This means there will likely be fewer people at Hacker School during the first half of the batch compared to our past batch and more people during the second half of the batch.↩


Rachel

We’re excited to welcome Rachel Vincent to Hacker School!

Before joining us, Rachel worked in the fashion industry developing digital strategies, planning events, and maintaining e-commerce sites. At Hacker School, Rachel will be focused on our single biggest organizational weakness: operations. She’ll be responsible for keeping calendars and checklists, developing process out of chaos, and helping us automate as much of what makes Hacker School tick as possible.

Hiring Rachel is a milestone for us for a number of reasons. Not only is this the first non-programming position we’ve hired for, but Rachel is also the first person we’ve hired from outside the Hacker School community. Before Rachel, we had never written a job post, developed an interview process, or made a hiring decision without three months to get to know someone first.

We learned a lot during the process, which we plan on writing about in more detail soon. In the mean time, we want to thank everyone who applied and interviewed for the job. We are honored and humbled that so many highly qualified people wanted to work with us, and we’re sorry that we could only hire one person.

Please join us in welcoming Rachel to Hacker School! We’re thrilled to have her and we’re excited about all the ways that she’ll help make Hacker School better.


We’ve enjoyed seeing our social rules spread into other parts of the tech community. Many people laugh in recognition when they hear about “No feigning surprise” or “No well-actuallys,” since they recognize that they’ve done these things and been annoyed when other people do them.

Our fourth rule, “No subtle -isms,” is less well-understood. Unlike the first three rules, it sounds vague and confusing, or maybe obvious – lots of organizations have a rule banning sexism. However, “no subtle -isms” doesn’t go without saying. Unlike many rules around sexism and racism, Hacker School’s social rule is intended to target subtle behaviors – things that nearly everyone does.

We often say that the Hacker School social rules are intended to be lightweight.  Another way to put this is that we expect that Hacker Schoolers will occasionally break one of the social rules. When this happens, another Hacker Schooler will say, “Hey, that was a well-actually,” and the first Hacker Schooler will say “Oops, sorry!” That’s it – accidentally breaking social rules is common, expected, and readily forgiven. Even Hacker School founders sometimes slip up.

Hacker School social rules are much lighter than a code of conduct. Someone who violates a conference’s code of conduct could get written up, warned, or ejected from the conference. Violating a code of conduct is a big deal, and it usually isn’t hard to avoid doing so. By contrast, it’s much harder to avoid breaking the Hacker School social rules, and people often make mistakes.

Our last social rule, “No subtle -isms,” bans subtle racism, sexism, homophobia, transphobia, and other kinds of bias. Like the first three rules, it’s targeting subtle, accidental, mildly hurtful behavior. This rule isn’t targeting slurs, harassment, or threats.  These kinds of severe violations would have consequences, up to and including expelling someone from Hacker School.

Breaking the fourth social rule, like breaking any other social rule, is an accident and a small thing. In theory, someone should be able to say “Hey, that was subtly sexist,” get the response “Oops, sorry!” and move on just as easily as if they’d well-actually'ed. In practice, people are less likely to point out when this rule is broken, and more likely to be defensive if they were the rule-breaker. We’d like to change this.

Following “No subtle -isms” looks different for different people. Someone who’s never thought much about bias in tech might decide to read Unlocking the Clubhouse or Stuck in the Shallow End. Someone else might check if they ask Hacker Schoolers of different races for help in proportion to the population at Hacker School. For faculty, since resident Lindsey Kuper mentioned it to us a year ago, we’ve been trying to stop using “you guys” to refer to mixed-gender groups. (As part of this effort, the very British facilitator Mary Rose Cook has started saying “y'all” with an English accent, which is a real treat for the rest of us.)

Like the other three rules, “No subtle -isms” is about recognizing the ways we’re unconsciously making our friends’ lives a little worse. Like the other three rules, breaking it does not make you a bad person and is not a huge deal.

For the last year, the “No subtle -isms” rule has carried some implementation guidelines. One of these is asking people not to debate whether or not something is an -ism. From the manual:

If you see a subtle -ism at Hacker School, you can point it out to the relevant person, either publicly or privately, or you can ask one of the faculty to say something. After this, we ask that all further discussion move off of public channels. If you are a third party, and you don’t see what could be biased about the comment that was made, feel free to talk to faculty. Please don’t say, “Comment X wasn’t homophobic!”  Similarly, please don’t pile on to someone who made a mistake. The “subtle” in “subtle -isms” means that it’s probably not obvious to everyone right away what was wrong with the comment.

When we introduced this policy, many women in our community responded positively.  At the same time, some men described their process of discovering what their female friends were going through, and worried that other men would miss out on this opportunity to become allies. That’s a genuine cost of having this policy. Nevertheless, we believe that this cost is outweighed by two benefits. First, we want marginalized people to feel welcome, not like they have to defend their presence. Second, we don’t want marginalized people to have to spend time educating non-marginalized people who might be coming to these ideas for the first time. Faculty - not other Hacker Schoolers - are happy to help people discover resources for learning about anti-oppression.

To give everyone an equal chance to focus on programming, we ask that conversations about bias happen somewhere that’s opt-in (like a designated lunch discussion or a private email thread) and not somewhere that’s opt-out (like the mailing list, public chat, or within earshot of someone trying to program).

We’re working to eliminate subtle -isms at Hacker School, but we still have a long way to go. For example, we’ve spent more time, energy, and money fighting sexism than fighting racism, homophobia, or transphobia, which is wrong of us. (Although our employees are diverse on some axes, we’re 90% white.) There are also class barriers to attending Hacker School - while Hacker School is free, living in New York for three months is not.

These are hard problems, but we’re committed to fixing them.

You’re welcome to use Hacker School social rules in your community. For an example of using the social rules in addition to a code of conduct, you can look at !!Con. If you use the rules, please credit and link to Hacker School.


This post tries to answer a seemingly simple question: What do people work on at Hacker School? The question isn’t as simple as it first seems because Hacker School doesn’t have a curriculum and Hacker Schoolers are extremely diverse: They choose to do a huge range of things, from writing small games to contributing to large existing projects.

There are a few things that are true across the board. Everything written at Hacker School is open source, and everyone works on projects they choose for themselves based on their interests and what they want to learn. Most people focus on projects that will be hard but possible for them to do given their current programming abilities. Beyond that, it’s hard to make any general statements, and so the best way to get a sense for the types of things people do here is through examples.

So, without further ado, here are nine things people do at Hacker School:1

Explore a new programming language – with its creator. Daria has been learning Elixir, a functional programming language built on top of the Erlang virtual machine, with the help of its creator, José Valim, who’s currently in residence at Hacker School.

Implement the Fast Fourier Transform and build a custom compression scheme. Marisa and Nava have combined programming and linear algebra to do image processing and compression work.

Write a useful open source library, and become the top-trending project on GitHub. Sahat has been writing a token-based authentication module for AngularJS called Satellizer, and with nearly 2,800 stars it was recently the top-trending project on GitHub.

Contribute to Rust, and find bizarre bugs in its string search algorithm. Nick discovered that "bananas".contains("nana") returns false in Rust. He then tracked down the bug, submitted a patch, and wrote a blog post.

Do hard-core things with bytecode and add tail-call optimization to Python. Liuda wrote a Python decorator that can automatically make a function tail-recursive by manipulating its bytecode.

Build tools you want for yourself. Victor has been working on Ractor, a distributed actor system in F#.

Find serious security vulnerabilities, and make the web a little safer. Max discovered that Maven Central serves JAR files unencrypted by default, and wrote dilettante, a man-in-the-middle proxy that injects malicious code. His blog post received so much attention that the company behind Maven Central is reversing their policy and will start providing free HTTPS access.

Build a photobooth. Laura built everything for an ASCII photo booth, from the hardware to the software to process the images, and patched GPUImage’s Mosaic filter along the way. And a slew of Hacker Schoolers pitched in to make hardware hacks for our summer party.

Reflect and be introspective, especially about learning. In addition to working on projects, Hacker Schoolers reflect on how they learn. Dana wrote a great post about her experience at Hacker School.

If any of the above sounds exciting to you, you should apply to Hacker School. And please don’t let any of these projects intimidate you: Most people report that Hacker School enabled them to tackle things they previously thought they couldn’t.

To be clear, this is just a small sampling of things Hacker Schoolers have done in the past few weeks, and isn’t in any way comprehensive.↩


tl;dr: Applications for our fall batch are open. Etsy is sponsoring the batch and providing $5k grants for female students (we’re open to more sponsors).
We’re starting a Hacker School Residency program, where awesome programmers come work closely with our students for one or two week stints. Peter Seibel will be the first resident. You can nominate residents.

Hacker School exists largely because we like to ask, “What if?” What if we ran a writer’s retreat for programmers? What if there were no grades, teachers, or formal curriculum? What if you could always feel comfortable saying, “I don’t understand?” What if we made social rules explicit?

Last batch, we partnered with Etsy to get equal numbers of men and women in Hacker School. We had no idea if that was feasible, since in our three previous batches we had had exactly one woman.

We were blown away by the response we got: Over 650 women applied, and we ended up with many more qualified women requesting financial assistance than we anticipated. Thankfully, 37signals and Yammer stepped up to provide additional grants for women.

The result? Twenty three of the 51 students in our current batch are female, and Hacker School is much better for it.

One thing we’ve heard repeatedly from women in Hacker School is that they love that here they’re “programmers” and not “female programmers.” A student told me last week that it feels like Hacker School has always been half women. It’s no longer a “what if.”

We’re thrilled to announce today that Etsy will be hosting our fall batch and sponsoring an additional 10 grants. Etsy has been an absolute pleasure to work with, and it’s hard to imagine how they could have been any more thoughtful, tasteful, or respectful. They’ve been an ideal partner.

We want to make this batch bigger and better than our last, and we’re currently in talks with several other companies interested in sponsoring Hacker School and providing grants. If you’re interested in working with us as well, please let us know.

Some of the best moments at Hacker School have come after talks by guest speakers.1 David Nolen spoke one Saturday about ClojureScript. The Q&A after his talk turned into a mini workshop with a handful of students, which turned into David staying and sharing his expertise and enthusiasm for nearly eight hours. He came back a few weeks later and walked a group of students through the internals of the ClojureScript compiler until almost 11pm. That led to half a dozen Hacker Schoolers signing Clojure contributor agreements and adding support for code reflection to the ClojureScript REPL.

My cofounder Dave recently asked another “what if”: What if the world’s best programmers did two week residencies at Hacker School? As usual, we don’t know the answer (which is why it’s a question worth asking), but we suspect it will be good.

Admittedly, this sounds far-fetched. Why should the best programmers in the world take two weeks off from their jobs to come work with us? But Hacker School itself initially sounded improbable. Who would quit their jobs and dedicate themselves to becoming better programmers for three months, and where would we find space to do it – full-time, for free – in one of the most expensive real estate markets in the world?

It no longer seems improbable that people would leave their jobs to do Hacker School. In fact, dozens of people now have, and many have done much more. Well over half of our current batch moved to New York solely for Hacker School, and more than 20% of our current batch moved countries to do it. (And somehow we’ve managed to beg, borrow, or steal space for five batches.) While Hacker School may have sounded improbable when we started, it clearly wasn’t impossible.

So today we’re announcing our Hacker School Residency. The idea is simple: Great programmers come work with us, full-time, on open source projects.

We’re delighted to say that Peter Seibel, author of Coders at Work and Practical Common Lisp (and programmer at Etsy), has generously agreed to be our first resident. Peter spoke at Hacker School earlier this summer and blew us away with his thoughtful advice for becoming a better programmer and genuine engagement with students.

We’re looking for more Hacker School Residents now. We’re looking for people who are at the top of their field, love what they do, and are genuinely nice human beings. If you’d like to nominate someone, including yourself (especially if your name is Peter Norvig), please send us a nomination. If you think it’d be impossible to take an extra week or two off work, ask yourself: “What if?” Maybe we can find a way to make it happen.

A student asked me recently how I thought Hacker School was going. It was a surprisingly hard question to answer. On the one hand, I’m unabashedly proud of what we’ve accomplished in just over a year. On the other hand, we’re chronically dissatisfied with Hacker School: There are a thousand ways we think we could do better, and we’re far from where we want to be.

To be clear, we’re not a bootcamp or a training program, we’re something different: The place where programming is important, where people come to focus, learn from each other, and do great work. We’re an ongoing experiment, and we think we can keep getting better, so long as we’re always willing to ask, “what if?”

Curious? Read about Hacker School and apply to our fall batch.

This is a separate post of its own, but the short of it is: Hacker School talks are 20 minutes, with no questions during the talk. After the talk we take a two minute break, at which point it’s entirely socially acceptable for anyone who wants to to leave. Then we start Q&A and go until students run out of questions or the speaker can’t take any more, usually the latter.↩


Ever since we moved to overlapping batches, we’ve had a problem with our batch names. With
eight batches a year, Summer, Fall, and Winter no longer make sense. For
a while we’ve been avoiding the problem by embedding dates directly into the
batch names, but that wasn’t an elegant solution.

Today we’re introducing new batch names. Batches will be named with a season,
the number 1 or 2, and a year. For example, the batch starting on October 6th
of this year is called Fall 2, 2014. Here is a full list of batch names for
2015:

It’s not a typo that Winter 2 comes before Winter 1. While it is confusing,
we think the alternative isn’t much better: Winter 2, 2014 would be followed
by Winter 1, 2015. We wish there was a perfect solution, but we feel a bit
better knowing that naming is one of the two hard problems in Computer
Science.1

Batch names can be abbreviated with the first letter of the season (e.g.
F2'14). In the interest of disambiguation, the abbreviations for Spring and
Summer use the first two letters of the season (Sp1'15 and Su2'16).

We’ve added the new batch names to our FAQ, apply page and the rest of our site.  We’ve
also retroactively applied the new names to all existing overlapping batches.
If you find a place where we’re still using old batch names, please let us
know.


      The others are cache invalidation and off-by-one errors.↩



Update 9/22/14: Hacker Schooler Marcus Malka suggested “How to Read a
Paper”
by Srinivasan
Keshav as a
companion to Paper of the Week. We’ve included it here for posterity. You can
read more about it in PotW #2.

Today we’re introducing the first recurring series on the Hacker School blog.
It’s called Paper of the Week. Every Monday we’ll link to a computer science
paper that’s worth reading, submitted by a member of the Hacker School
community.1

Our goal is to present academic computer science in a practical and accessible
way. Reading the right papers can be enriching and enlightening, but there’s a lot
of CS research happening and it’s hard to figure out what papers have useful
insights into everyday programming. Lots of Hacker Schoolers read and talk
about papers, and we thought it would be fun to share some of them with the
rest of the world.

We’ll be featuring papers that are relevant to programmers of all levels. Some
of them will be Ph.D dissertations, others will be short essays published in
journals or just posted to the Web.

If you’re new to academic writing, the language can be dense and intimidating.
This is true even for experienced programmers. Don’t despair! Sometimes you
will need to read a sentence one word at a time, looking up the definition of
each term you don’t understand. Often, it will take multiple reads to grok what
the paper is about. Even if you don’t end up fully understanding a paper, the
experience of puzzling through it is often worthwhile.

This week’s paper is Growing a
Language by Guy
Steele. It is a version of a
talk he gave at OOPSLA ‘98. At
the time, Steele was working at Sun Microsystems on the Java programming
language. He was already well-known for his work developing Scheme with
Gerald Sussman.

The paper was submitted by Hacker School resident Mel
Chua who had this to say about it:

I ran into this during my first programming job as a fresh college grad. I
didn’t have a formal CS education, so I didn’t know much about CS theory,
and… to be entirely honest, at some level, I didn’t even want to look at it
(because what if I looked and found it was Too Hard and I was Not Smart Enough
To Be A Programmer?) So I irrationally avoided formal CS theory due to
Impostor Syndrome.

However, I loved humor – which was how this paper snuck on my radar
under the guise of “check out this great joke!” It wasn’t until partway through
that I realized I was laughing at CS theory. Steele’s talk uses natural
language to illustrate how programming languages are built up from primitives,
but he does so in such a gentle, conversational way that it takes a little
while to get the joke of what he’s trying to do. At first, it just sounds like
he’s talking funny about topics that aren’t relevant to programming, but stay
with it. It is absolutely worthwhile.

Happy reading!


      If this gets popular, we may also publish submissions from the public. No
      promises that we’ll ever do this, but if you feel the urge to send in
      your favorite paper, you can email potw@hackerschool.com.↩



This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week, we have two papers: a paper and a bonus meta-paper. We’ll start with
the meta-paper.

Hacker School alum Marcus Malka submitted How to
Read a
Paper
by Srinivasan
Keshav, a
computer science professor at the University of Waterloo, and three of his
students: Hossein Falaki, Earl Oliver, and Sumair Ur Rahman. It was originally
published in the July 2007 issue of Computer Communication
Review, but
the version we’re linking to is a living document and was last updated in 2013.

How to Read a Paper has several useful tips and strategies for effectively
reading academic papers. Some of it is geared towards researchers who are peer
reviewing papers for their colleagues, but most of the tips are applicable for
any reader.

This week’s paper is Reflections on Trusting
Trust by
Ken Thompson. Thompson is the
co-creator of the UNIX and Plan 9 operating systems as well as the Go
programming language. The paper is adapted from a lecture he gave upon
receiving a Turing Award for his hand in the creation of UNIX, and was
published in the August 1984 issue of Communications of the
ACM. It was submitted by Hacker Schooler Leah
Hanson who shared the following:

A short piece by Ken Thompson illustrating that you have to trust your
compiler/the people who wrote it: reading the source code [of the compiler,
etc.] is not enough to be really sure that the compiler is doing what it should
be doing. This had some of the mind-expanding feeling that recursion often
gives people when they first grasp it; the malicious binary version of the
compiler both affects the next version of the same compiler compiled with it
(self-hosting compiler) and some target binary (the one that handles logging
into Linux).

A recent related blog post, Countering “Trusting Trust” talks about
a way to defend against this attack (given that not all of your compilers are
infected by exactly the same attack). This method can have some false
positives, in the form of compiler bugs (that are not malicious attacks).

We want to let people participate in Paper of the Week, so we’re adding a
section called Read Along. If you want to take part in Read Along, all you
have to do is read the paper, create an original work in response, and email
us a link of what you make by noon Eastern Time on the following Monday.
Your original work might be a blog post explaining the paper or any insights it
gave you, a program that implements some of the paper’s ideas, or something
else entirely. It’s up to you. We’re not promising to publish everything, but
our goal is to make Read Along something that’s easy to participate in, so
don’t be shy about submitting, even if it’s something small.

This week, Hacker School facilitator Tom
Ballinger decided to take on Guy Steele’s
challenge to explain garbage collection using only words of one syllable as
primitives. You can see the results on his
blog.

Happy reading!


The short: We now have need-based living expense grants for blacks and Latino/as, as well as people from other groups traditionally underrepresented in programming. Etsy, Juniper, Perka, Stripe, Betaworks, and Fog Creek have partnered with us to fund the grants, and help make the demographics of Hacker School better reflect those of the US. Hacker School remains free for everyone.

In early 2012, we partnered with Etsy and began offering need-based grants to women who couldn’t afford to pay for living expenses during Hacker School. This was part of a larger effort to make Hacker School more gender-balanced, and it has worked extremely well.

Over the past two and a half years our community has gone from being under 5% women to being 35%, and from being a few dozen people to nearly 450.

Simultaneously, and in many ways because of this, Hacker School has become a better experience and community along almost every dimension.

There are many reasons why diversity is valuable, but there are two reasons why it is especially important to Hacker School as an organization.

The first is that diversity helps to reduces the harmful effects of stereotype threat. Put another way, we focus on diversity so Hacker Schoolers don’t have to. We want you to be able to focus on becoming a better programmer, not being the only person like you in the room. The more diverse Hacker School is, the easier it is for a greater range of people to do that.

Second, a large part of the value of Hacker School is what Hacker Schoolers learn from each other. Hacker School relies on a diverse range of experiences and perspectives; if everyone were the same, no one would have anything to learn from each other! Our self-directed and peer-driven educational model is in this way very different from traditional, one-size-fits-all approaches to education.1

Given this, it’s unsurprising that Hacker School has gotten better as our community has grown to include more women, trans people, genderqueer people, older people, younger people, parents, and people from a greater range of racial, ethnic, and socioeconomic backgrounds.

But while we’re proud of the progress we’ve made, we’re still far from where we want or need to be: Hacker School is still not 50% women and, like the programming world at large, it is still overwhelmingly white and Asian. And while we strive to eliminate it, our community isn’t free of sexism or racism.

Today, we’re excited to take the next step in building a stronger and more diverse community, and announce the largest expansion of our grants program to date. We’ve secured grant funding for our next full year of batches, and are expanding our grants program to support people from traditionally underrepresented racial and ethnic groups in programming, in addition to women.

This is only possible because of the outstanding support and commitment of our partner companies. Etsy has committed over $200,000 in grants for the coming year, and Juniper has pledged an additional $100,000 for grants. Etsy and Juniper have been the two greatest champions and supporters of female programmers at Hacker School, and we are honored to have their continued and expanded support.

We’re also thrilled to announce four new grant sponsors: Betaworks, Fog Creek, Perka, and Stripe. These companies are deeply committed to supporting and increasing diversity in programming and are all sponsoring multiple grants over the next year. We couldn’t be happier to be working with them.

We applaud these companies for not just talking about the importance of supporting diversity, but for stepping up and doing one of the most effective things we’re aware of: Giving money directly to those who need it, with no strings attached.

Our grants are now available to people who identify as women, black, Latino/a, Native American, and Pacific Islander. Since Hacker School charges no tuition, the grants are intended to be used for living expenses during your three months of Hacker School: You can use your grant for housing, food, childcare, or anything else you need during your time here. Each grant is for between $500 and $7,000, depending on the need of the recipient.

Hacker School is in the unusual position to be able to support both relatively new and very experienced programmers from a wide range of backgrounds. There are other organizations focusing purely on getting more people from underrepresented groups into programming and we think that’s an important part of the puzzle. But we also think it’s vitally important to additionally support people from underrepresented groups who are already working as programmers and who struggle with the pervasive discrimination in our industry. The lack of black and female programmers is partially because of how few initially enter the field, but also because of how many are driven out by racism, sexism and unsupportive environments.

So, whether you are entirely self-taught or you have a CS degree, we want you at Hacker School. And regardless of if programming is just something you do for fun or if programming is something you’ve been doing professionally for years, we want you at Hacker School. People with everything from three months to 20 years of programming experience have told us they found Hacker School to be a life-changing experience.

As we said when we announced our grants for women two and a half years ago, we are in no way lowering our admissions bar for anyone. We hold everyone who applies to an equal standard, and no man has ever been denied admission to Hacker School because a woman was admitted. We accept every person who applies who we believe we’re a good fit for and who would benefit from and contribute to Hacker School.

We are always eager to reduce bias in our admissions process, and so this year we began automatically generating pseudonyms for applicants. Instead of seeing names like “José Smith” and “Kimberly Lin” we now see names like “Croissant Wave” and “Representative Mint” when doing our initial application review. We conduct Skype interviews and applications still contain personally identifying information like GitHub links, so the pseudonyms are only intended to eliminate unconscious bias in the first minute or two of our application review.

The data from our past two years of batches has been remarkably consistent: The percent of women in a given batch is statistically indistinguishable from the percent of women who applied to that batch. If 35% of applicants for a batch are women then the batch will be approximately 35% women. We’ve found the same to be true at every step of our admissions process: Men and women are invited to interview, advanced to a second interview, and admitted at the same rates. We believe this provides strong evidence that we’ve succeeded in our commitment to holding women and men to the same admissions standards.2

This also suggests that one of the bests paths to a vibrant and diverse community is outreach: Our community has grown larger and stronger not by turning people away, but by welcoming people from a broader range of backgrounds to apply in the first place.

If you want to spend three months programming with friendly peers with a wide array of experience levels and perspectives, you should apply to Hacker School. And even if Hacker School isn’t what you’re looking for, please help us spread the word.

 Please contact us if you’re interested in supporting diversity and sponsoring grants at Hacker School.

Update 10/1/14: After making this announcement, we were told that “Hispanic” is a word few people identify with and many find hurtful. We’re sorry that we weren’t as informed as we could have been and we’re grateful to everyone who let us know how we could do better. We’ve removed “Hispanic” from this blog post and from the rest of our site. We’ve also replaced “non-white Latino/a” with “Latino/a” because it’s more straightforward and better takes into account how people self-identify.

Consider a traditional lecture-based class with a fixed curriculum. That model is built around homogenity, not diversity: It’s much easier to operate if everyone involved has the same background, interests, learning-style, and rate of growth. Our model is the opposite: It’s helped not harmed by diversity.↩


We haven’t previously tracked other demographic information in our admissions process, so we don’t have similar data for other groups, though we believe the same is true for them as well.↩



This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Error Detecting and Error Correcting
Codes by Richard
Hamming. It was published in
the April 1950 issue of the Bell System Technical
Journal. Hamming
worked at Bell Labs from 1946 to 1976. During those years, the transistor,
information theory, modern cryptography, the solar cell, the laser, UNIX, C,
and the error correcting codes described in this paper were all invented at
Bell Labs.

Hacker School alum Dan Luu submitted this paper and said
the following:

Despite being more than six decades old, Hamming codes are probably the most
commonly used error-correcting codes (ECC) today, and I’ve probably
used/implemented them more often than all other types of ECC combined. They’re
one of the first things you should consider if you’re sending/storing data in a
lossy medium and you need ECC that’s simple/fast, or if you’re operating on
small chunks of data.

Also, I believe this is the second paper written on error
correcting codes, and that it’s often considered to be the seminal
work in the field. Because the field was so young at the time, the
paper assumes no background, which makes it eminently readable.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), email us a link of what you make by
noon Eastern Time next Monday, and we’ll link to it from our blog.

Nobody submitted a Read Along this week, so there’s nothing to post here. If
you are reading along with us, please don’t be shy! Even a one paragraph
Gist with your unedited thoughts would be fun for
other people to read.

Happy reading!


Applications are now open for the Spring 2, 2015 batch of Hacker School, which runs from March 30th through July 2nd. There are also plenty of spots left in the Winter 1, Winter 2, and Spring 1 batches. You can see the dates for these batches in our FAQ. The application deadline for Spring 2 is March 9th, 2015, but admissions are rolling, so the earlier you apply, the better.

Hacker School is free for everyone, but we know that living in NYC can be expensive. We offer need based grants to cover living expenses for people who identify as women (cis or trans), black, Latino/a, Native American, and/or Pacific Islander.

If you’re interested in applying to Hacker School, we strongly encourage you to read our about page, FAQ and User’s Manual.


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is On Understanding Data Abstraction,
Revisited by William
Cook, an Associate Professor of Computer
Science at The University of Texas at Austin. It was originally presented at
OOPSLA ‘09. Among his many
accomplishments, Cook was one of the original designers of AppleScript. He
wrote a history of the language, which you can find on his
website. He’s also
currently fighting cancer, so if you enjoy his paper and have a bit of money to
spare, you can
donate
to his treatment.

This week, I decided to submit a paper myself. Alan
O'Donnell, one of our facilitators, told me
about this paper last year and it has had a profound effect on how I think
about programming. The paper compares two forms of data abstraction, objects
– the kind you find in Smalltalk, Java, Ruby, etc. – and abstract
data types (ADTs), which include C’s built-in primitive types and the algebraic
data types that are common to the ML family of languages. Cook’s thesis is that
while people often conflate the two, objects and ADTs are two distinct forms of
data abstraction, which have different properties and use-cases.

Reading this paper felt like lifting a mental fog. Every programming problem
that I approached suddenly had two possible solutions instead of one: I could
solve the problem with objects, or I could solve it with ADTs. I mostly program
in Ruby and JavaScript, which makes it more likely that I’ll solve my problems
with objects (both languages have stronger support for objects than ADTs), but
even the knowledge that there’s another option has been a useful tool for me in
my everyday programming.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose),
email us a link of what you make by noon Eastern Time next
Monday, and we’ll link to it from our blog.

Hacker School facilitator Tom Ballinger is back with another Read Along
submission. In it, he
works through parts of last week’s paper in Python while reflecting on his own
reading and learning styles.

Happy reading!


Allison Kaptur, a long-time Hacker School facilitator and dear friend, has decided to take the next step in her career and join the team at Dropbox. Allison’s contributions to Hacker School are innumerable, and we’re sad to see her go, though we are happy that she will be joining many Hacker School friends at Dropbox.

Like many things at Hacker School, Allison’s departure is atypical. Allison told me in our weekly one-on-one a couple of months ago that she was ready to move to a pure programming role at a software company, and so continuing to be a Hacker School facilitator was no longer the best way to pursue her personal and professional goals. I was sad, but quickly understood that this is indeed the right path for her after hearing her reasoning.

Being transparent here turned out to have a lot of benefits, both for Hacker School and for Allison.

For Hacker School, it meant time to plan, and an opportunity to help Allison choose a minimally disruptive time to depart. As a small company, it’s especially tough to lose a key employee, and having a significant heads up is helpful. It also gave Hacker School the opportunity to be involved in Allison’s job search (our business model is, after all, recruiting).

For Allison, it meant she didn’t have to lie to or be evasive with us or her colleagues, or worry about finding time to interview or take surreptitious trips to California. It also meant she could use us for references and referrals for potential employers, and draw upon Hacker School’s resources and community for interview prep and negotiation advice.

Many companies and people are unnecessarily closed off about their future plans, opting to pretend everyone’s jobs will be their last. But that’s rarely true nor productive. My cofounders and I have had similarly candid conversations with other employees when they’ve been approached by other companies or were considering medical school. Each time, we have tried to be frank about our goals and to hear and understand our employees’, and to genuinely try to find what’s best for Hacker School and our employees. I don’t think this would work in all contexts or for all people, but it has worked well for us.

Thank you, Allison, for helping build Hacker School these past years, and for continuing to contribute, even as you move on. We wish you the best of luck, and can’t wait to see what you accomplish next.


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is The Power of Interoperability: Why Objects Are
Inevitable by
Jonathan Aldrich an Associate Professor at
Carnegie Mellon University. It was published in Onward! Essays,
2013

I submitted this paper because it’s a good companion to last
week’s. Aldrich argues that the essential thing
about objects is that they can provide services that operate at a higher level
than just data abstraction. I don’t think this paper invalidates last week’s.
It’s perspective is different and complimentary.

This paper also draws on The Early History Of
Smalltalk by Alan
Kay, which could easily be called The
Early History of Object-Oriented Programming. Aldrich’s perspective on objects
seems much closer to Kay’s original ideas than Cook’s does.

When I found Aldrich’s paper on the front page of Hacker News last week, I had
just finished reading Kay’s. If you have time, Kay’s paper is a nice companion
to this one.

At the suggestion of Hacker Schooler Leah Hanson,
we’re going to be posting the abstract from each paper to whet your appetite.
Here’s this week’s:

Three years ago in this venue, Cook argued that in their essence, objects are
what Reynolds called procedural data structures. His observation raises a
natural question: if procedural data structures are the essence of objects, has
this contributed to the empirical success of objects, and if so, how?

This essay attempts to answer that question. After reviewing Cook’s definition,
I propose the term service abstractions to capture the essential nature of
objects. This terminology emphasizes, following Kay, that objects are not
primarily about representing and manipulating data, but are more about
providing services in support of higher-level goals. Using examples taken from
object-oriented frameworks, I illustrate the unique design leverage that
service abstractions provide: the ability to define abstractions that can be
extended, and whose extensions are interoperable in a first-class way. The
essay argues that the form of interoperable extension supported by service
abstractions is essential to modern software: many modern frameworks and
ecosystems could not have been built without service abstractions. In this
sense, the success of objects was not a coincidence: it was an inevitable
consequence of their service abstraction nature.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), and email
us a link of what you make by noon
Eastern Time next Monday.

We’d we’d love to get your feedback on what changes we could make to Paper of
the Week to make it even more likely that you’ll submit a Read Along. If there
are things we could change to make PotW more welcoming, please let us
know.

Happy reading!


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is The Chubby Lock Service for Loosely-Coupled Distributed
Systems.
It was written by Mike Burrows at Google and was presented at
OSDI'06, USENIX’s
Symposium on Operating Systems Design and Implementation.

This week’s paper was submitted by Hacker Schooler Leah
Hanson, who said the following:

Chubby is a distributed lock service; it does a lot of the hard
parts of building distributed systems and provides its users with a
familiar interface (writing files, taking a lock, file
permissions). The paper describes it, focusing on the API rather
than the implementation details; it is written in a very readable
style. There are amusing stories about other Google engineers
(their users) using the API incorrectly; in response, they either
fix the API or the implementation so that it’s no longer a problem.

Chubby provides locks and files. Distributed systems usually have
one master (in a database, the master approves all writes before
they’re real); when the master dies, a new machine needs to be
elected master. Without Chubby, this is a hard problem and
implementations are error prone. With Chubby (which depends on
Paxos, the gold standard for this), a machine will try to grab a
lock & write it’s name in a file when it wants to elect itself
master; if it succeeds, it’s the new master and the other machines
will believe it once they read it’s name in the file. Chubby
provides an simple interface, but still gives you the correctness
of using Paxos (which is very complex to use).

You have to work at Google if you want to see Chubby’s source code,
but ZooKeeper is an opensource alternative.

Here’s the abstract from the paper:

We describe our experiences with the Chubby lock service, which is
intended to provide coarse-grained locking as well as reliable
(though low-volume) storage for a loosely-coupled distributed
system. Chubby provides an interface much like a distributed file
system with advisory locks, but the design emphasis is on
availability and reliability, as opposed to high performance. Many
instances of the service have been used for over a year, with
several of them each handling a few tens of thousands of clients
concurrently. The paper describes the initial design and expected
use, compares it with actual use, and explains how the design had
to be modified to accommodate the differences.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), and email
us a link of what you make by noon
Eastern Time next Monday.

Last week’s paper was The Power of Interoperability: Why Objects
Are Inevitable. Here are the Read Along
submissions:

Happy reading!


Coming from a background in higher-level languages like Ruby, Scheme, or Haskell, learning C can be challenging. In addition to having to wrestle with C’s lower-level features like manual memory management and pointers, you have to make do without a REPL. Once you get used to exploratory programming in a REPL, having to deal with the write-compile-run loop is a bit of a bummer.

It occurred to me recently that I could use gdb as a pseudo-REPL for C. I’ve been experimenting with using gdb as a tool for learning C, rather than merely debugging C, and it’s a lot of fun.

My goal in this post is to show you that gdb is a great tool for learning C. I’ll introduce you to a few of my favorite gdb commands, and then I’ll demonstrate how you can use gdb to understand a notoriously tricky part of C: the difference between arrays and pointers.

Start by creating the following little C program, minimal.c:

Note that the program does nothing and has not a single printf statement.1 Behold the brave new world of learning C with gdb!

Compile it with the -g flag so that gdb has debug information to work with, and then feed it to gdb:

You should now find yourself at a rather stark gdb prompt. I promised you a REPL, so here goes:

Amazing! print is a built-in gdb command that prints the evaluation of a
C expression. If you’re unsure of what a gdb command does, try running help
name-of-the-command at the gdb prompt.

Here’s a somewhat more interesting example:

I’m going to ignore why 2147483648 == -2147483648; the point is that even
arithmetic can be tricky in C, and gdb understands C arithmetic.

Let’s now set a breakpoint in the main function and start the program:

The program is now paused on line 3, just before i gets initialized.Interestingly, even though i hasn’t been initialized yet, we can still lookat its value using the print commnd:

In C, the value of an uninitialized local variable is undefined, so gdb might print something different for you!

We can execute the current line with the next command:

Variables in C label contiguous chunks of memory. A variable’s chunk is
characterized by two numbers:

The numerical address of the first byte in the chunk.

The size of the chunk, measured in bytes. The size of a variable’s
chunk is determined by the variable’s type.

One of the distinctive features of C is that you have direct access to a
variable’s chunk of memory. The & operator computes a variable’s address,
and the sizeof operator computes a variable’s size in memory.

You can play around with both concepts in gdb:

In words, this says that i‘s chunk of memory starts at address 0x7fff5fbff5b4 and takes up four bytes of memory.

I mentioned above that a variable’s size in memory is determined by its type, and indeed, the sizeof operator can operate directly on types:

This means that, on my machine at least, int variables take up fourbytes of space and double variables take up eight.

Gdb comes with a powerful tool for directly examing memory: the x
command. The x command examines memory, starting at a particular address.
It comes with a number of formatting commands that provide precise control
over how many bytes you’d like to examine and how you’d like to print them;
when in doubt, try running help x at the gdb prompt.

The & operator computes a variable’s address, so that means we can feed &i to x and thereby take a look at the raw bytes underlying i’s value:

The flags indicate that I want to examine 4 values, formatted as hex numerals, one byte at a time. I’ve chosen to examine four bytes because i’s size in memory is four bytes; the printout shows i’s raw byte-by-byte representation in memory.

One subtlety to bear in mind with raw byte-by-byte examinations is that on Intel machines, bytes are stored in “little-endian” order: unlike human notation, the least significant bytes of a number come first in memory.

One way to clarify the issue would be to give i a more interesting value and then re-examine its chunk of memory:

The ptype command might be my favorite command. It tells you the type of a C expression:

Types in C can get complex
but ptype allows you to explore them interactively.

Arrays are a surprisingly subtle concept in C. The plan for this section
is to write a simple program and then poke it in gdb until arrays start to
make sense.

Code up the following arrays.c program:

Compile it with the -g flag, run it in gdb, then next over the
initialization line:

At this point you should be able to print the contents of a and
examine its type:

Now that our program is set up correctly in gdb, the first thing we should
do is use x to see what a looks like under the hood:

This means that a’s chunk of memory starts at address
0x7fff5fbff5dc.  The first four bytes store a[0],
the next four store a[1], and the final four store
a[2]. Indeed, you can check that sizeof knows
that a’s size in memory is twelve bytes:

At this point, arrays seem to be quite array-like. They have their own
array-like types and store their members in a contiguous chunk of memory.
However, in certain situations, arrays act a lot like pointers! For instance,
we can do pointer arithmetic on a:

In words, this says that a + 1 is a pointer to an int and holds the
address 0x7fff5fbff570. At this point you should be reflexively passing
pointers to the x command, so let’s see what happens:

Note that 0x7fff5fbff570 is four more than
0x7fff5fbff56c, the address of a’s first byte in
memory. Given that int values take up four bytes, this means
that a + 1 points to a[1].

In fact, array indexing in C is syntactic sugar for pointer arithmetic:
a[i] is equivalent to *(a + i). You can try this
in gdb:

We’ve seen that in some situations a acts like an array and in others it
acts like a pointer to its first element. What’s going on?

The answer is that when an array name is used in a C expression, it
“decays” to a pointer to the array’s first element. There are only two
exceptions to this rule: when the array name is passed to
sizeof and when the array name is passed to the &
operator.2

The fact that a doesn’t decay to a pointer when passed to the
& operator brings up an interesting question: is there a
difference between the pointer that a decays to and
&a?

Numerically, they both represent the same address:

However, their types are different. We’ve already seen that the decayed
value of a is a pointer to a’s first element;
this must have type int *. As for the type of
&a, we can ask gdb directly:

In words, &a is a pointer to an array of three integers.
This makes sense: a doesn’t decay when passed to
&, and a has type int [3].

You can observe the distinction between a’s decayed value and
&a by checking how they behave with respect to pointer
arithmetic:

Note that adding 1 to a adds four to
a’s address, whereas adding 1 to
&a adds twelve!

The pointer that a actually decays to is
&a[0]:

Hopefully I’ve convinced you that gdb a neat exploratory environment for
learning C. You can print the evaluation of expressions,
examine raw bytes in memory, and tinker with the type system
using ptype.

If you’d like to experiment further with using gdb to learn C, I have a
few suggestions:

Use gdb to work through the Ksplice pointer challenge.

Investigate how structs are stored in memory. How do they compare to
arrays?

Use gdb’s disassemble command to learn assembly programming! A
particularly fun exercise is to investigate how the function call stack
works.

Check out gdb’s “tui” mode, which provides a grahical ncurses layer on
top of regular gdb. On OS X, you’ll likely need to install gdb from
source.

Alan is a facilitator at Hacker School. He’d like to thank David Albert, Tom Ballinger, Nicholas Bergson-Shilcock, and Amy Dyer for helpful feedback.

Curious about Hacker School? Read about us and apply to our fall batch.


This is the first of what may become a series of posts highlighting Hacker Schoolers. The goal is to share more about the many paths people take before, during, and after Hacker School.

Our first profile post is on Stephanie Samson, who’s a current Hacker Schooler in the Fall 1, 2014 batch. Steph kindly agreed to take 15 minutes out of her day to talk with me about what she did before Hacker School, and what she’s working on now.



How did you start programming?

I really started right around high school. I was working with the Santa Fe Institute mentoring middle school students about science and math, and that’s where I got my first exposure to programming. But I didn’t dive deeply into it until December of last year, when I went to a hackathon in Australia. I joined a team as a designer, but I started learning Ruby.

What did you do next?

I just spent a month focused on teaching myself Ruby, and then I decided to apply for some jobs. I never thought I’d get any offers, but I did. I worked at Gramercy Studios until August, when I came to Hacker School.

What have you worked on at Hacker School so far?

I’ve worked on a Scheme interpreter, a translation bot, and an API wrapper for Google Translate, all in Python. I’ve also been learning some more CS fundamentals, like recursion and linked lists, which I’ve found to be very helpful since prior to Hacker School I didn’t have any experience with more “computer science-y” stuff.

When working on the Scheme interpreter I decided to try test-driven development. I would first write tests for the output that my interpreter should have for different inputs, and then make them pass. I was just getting started with TDD, and I was stressed about whether or not I was approaching it correctly, so I sat down with Zach, Tom and Jesse [facilitators and a fellow Hacker Schooler] and they helped me get on the right track.

Now I’m trying to encourage Susan [a fellow Hacker Schooler], who’s also writing an interpreter, to use TDD.

How come you chose to write an API wrapper?

I wanted to make a translation bot for Zulip [Hacker School’s internal chat system]. And so I looked for an API wrapper for Google or Bing Translate, but I couldn’t find a good one, so I decided to make my own. It was a really interesting project for me because I’ve never made anything like it. I had to first understand what makes a good API wrapper, and so I had to read other people’s code for other API wrappers. The big lesson that I learned is to read other people’s code; I found this to be more helpful than even reading people’s blog posts about their projects. This is something I’ve definitely gotten better at Hacker School – reading other people’s code.

How have you found pair programming with other people?

I’ve really enjoyed pairing with people. It’s great to get to work with people who are genuinely curious, who want to become better programmers, and who aren’t judgemental. It’s great to be able to ask questions and not get a “well, actually” or have someone feign surprise. It’s also really helped me with concentration, and just focusing on one thing at a time. I think that’s more important than multitasking.

What are you planning to work on next?

I’m going to learn more about functional programming using Elm. There are several people here working on Elm, and I find the community really helps you learn faster. I made much faster progress with Python thanks to the people here, and I think the same will be true with Elm.

Thanks to Stephanie Samson for being a wonderful part of the Hacker School community, and for taking the time to chat for this interview. If you’d like to join a supportive, energizing, and intellectually curious community, there’s still time to apply for our Winter 1 batch which begins on November 17th.


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Out of the Tar
Pit by Ben Moseley and Peter Marks,
which was presented at
SPA2006.

Out of the Tar Pit was submitted by Hacker Schooler Pablo
Torres, who shared the following:

In Out of the Tar Pit, Moseley and Marks argue that the biggest source of
complexity in programs is mutable state, because keeping track of all possible
combinations of bits is unmanageable. They introduce the notions of essential
and incidental complexity, the former referring to details that are inherent to
a problem and the latter to those complications that arise due to a particular
solution one might attempt - for example, issues added by the programming
language in use.

They continue by comparing Object-Oriented Programming’s approach of breaking
state up into small, manageable pieces and providing controlled mutations with
Functional Programming’s solution of avoiding mutations altogether; they also
spend some time analyzing Logic Programming. They favor the simplicity of FP,
even though they admit that it takes discipline to achieve.

Finally, they offer recommendations on how to build systems that are easy to
reason about by using the tools provided by Functional Programming and
relational database modelling.

Here’s the abstract from the paper:

Complexity is the single major difficulty in the successful development of
large-scale software systems. Following Brooks we distinguish accidental from
essential difficulty, but disagree with his premise that most complexity
remaining in contemporary systems is essential. We identify common causes of
complexity and discuss general approaches which can be taken to eliminate them
where they are accidental in nature. To make things more concrete we then give
an outline for a potential complexity-minimizing approach based on functional
programming and Codd’s relational model of data.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), and email
us
a link of what you make by noon Eastern Time next Monday.

Last week’s paper was The Chubby Lock Service for Loosely-Coupled
Distributed Systems. Here are the Read Along
submissions:

Happy reading!


We’re excited to announce that Jean Yang and Matt Might will be in residence at Hacker School during our upcoming Winter 1 batch.

Jean is an MIT PhD student studying programming languages. She created Jeeves and Haskell Ryan Gosling and also worked on Verve, an operating system verified end-to-end for type safety.

Matt is an Associate Professor at the School of Computing at the University of Utah who researches data structures, meta-programming and parsing with derivatives, and teaches a course on compilers.

Jean will be in residence at Hacker School from November 17th – November 20th, and Matt will be in residence from December 1st – December 4th.

If you’re as excited to work with Matt and Jean as we are, apply to our Winter 1 batch!

We’ve been lucky to have some amazing residents this summer and fall. Crista Lopes, José Valim, Leigh Honeywell, Peter Seibel, Jessica McKellar and Paul Tagliamonte all joined us earlier this year, and we’re grateful to have spent time programming with and learning from them all.


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Managing Update Conflicts in Bayou, a Weakly Connected
Replicated Storage
System by Douglas
B. Terry, Marvin M. Theimer, Karin Petersen, Alan J. Demers, Mike J. Spreitzer
and Carl H. Hauser. It was written at Xerox’s Palo Alto Research Center and
presented at SOSP ‘95, the ACM Symposium on Operating
Systems Principles.

This week’s paper was submitted by Hacker Schooler Maggie
Zhou, who shared the following:

Designing a storage system in the face of bad networks and update conflicts,
are still problems today (see: the network is (not)
reliable). Bayou presents an
early example of designing in the face of network partition and conflicting,
concurrent updates. It was the first systems paper I got through and really
made me want to read more.

Here’s the abstract from the paper:

Bayou is a replicated, weakly consistent storage system designed for a mobile
computing environment that includes portable machines with less than ideal
network connectivity. To maximize availability, users can read and write any
accessible replica. Bayou’s design has focused on supporting
application-specific mechanisms to detect and resolve the update conflicts that
naturally arise in such a system, ensuring that replicas move towards eventual
consistency, and defining a protocol by which the resolution of update
conflicts stabilizes. It includes novel methods for conflict detection, called
dependency checks, and per-write conflict resolution based on client-provided
merge procedures. To guarantee eventual consistency, Bayou servers must be able
to rollback the effects of previously executed writes and redo them according
to a global serialization order. Furthermore, Bayou permits clients to observe
the results of all writes received by a server, including tentative writes
whose conflicts have not been ultimately resolved. This paper presents the
motivation for and design of these mechanisms and describes the experiences
gained with an initial implementation of the system.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), and email
us
a link to what you made by noon Eastern Time next Monday.

Last week’s paper was Out of the Tar Pit. Here are the Read Along submissions:

We also had one more Read Along submission for the Chubby paper from two weeks ago:

Happy reading!


This is a follow-up to my earlier post, What people do at Hacker School. As before, the goal is to answer the deceptively simple question of what people do at Hacker School. Because Hacker School projects are as diverse as Hacker Schoolers themselves, the best way to answer this by example.

So here’s another small sampling of things people have done at Hacker School in the last few weeks:

Create language for generating minimalist art. Sarah is building LeWittScript, a conceptualist art and code project for generating art in the style of the American artist Sol LeWitt.

Build software to broadcast terminal sessions. Jesse wrote a reimplementation of Termcast in Python to let people share their terminal sessions over SSH and the web.

Contribute back to Community (in ClojureScript). Madhu and Suren are adding a search feature to Community, the open source forum software we replaced Google Groups with internally this year.

Write a Twitter-based file system. Adrien wrote a FUSE-based file system on top of Twitter so you can cat, ls and rm your followers.

Pair program and then write a blog post – together. Susan and Stephanie added a feature to bpython, and then pair blogged the experience.

Update a kernel module to fix your keyboard. Chase’s keyboard wasn’t working how he wanted it to, so he read the Linux source, wrote a patch, and blogged about the process.

If you’d like to spend three months becoming a better programmer and working on projects like these, you should apply to Hacker School. Don’t let any of these projects intimidate you: Most people report that Hacker School enabled them to tackle things they previously thought they couldn’t.


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Worlds: Controlling the Scope of Side Effects by Alessandro Warth, Yoshiki Ohshima, Ted Kaehler and Alan Kay. It was presented at ECOOP 2011 and is based on part of Warth’s Ph.D. thesis Experiments with Programming Languages. When this paper was published, all four authors were researchers at Viewpoints Research Institute.

Worlds was submitted by Hacker School resident David Nolen, who shared the following:

Alan Kay’s VPRI group published this fascinating paper on a general pattern for
controlling the scope of side effects. The formulation is object oriented in
flavor but the observations and results are significant and may be arrived at
by other means. Specifically, in the closing “Related” section they note that
Worlds deliver the same benefits made possible by persistent data structures.
This is one of the key papers that inspired my work around
Om.

Compare the undo implementation I described for an Om based
TodoMVC and the undo
implementation described in section 3.2. They are surprisingly similar (I had
not actually read the source in this section when devising my example). In
section 3.3 they describe extension methods - this is available in
ClojureScript via specify. You can think of specify as an instance level
type class extension that returns a new extended (equal) value. Internally Om
uses this feature all over the place. In ClojureScript extension methods are
very high performance - deep cloning with persistent data structures is O(1).

I think in the long run this paper will likely be one of the seminal references
for anyone trying to reconcile the powerful modularity of stateful Object
Oriented programming with the stunning properties derived from value oriented
functional programming - particularly when attempting to apply these strategies
to the computer programming domains that still exhibit staggering complexity at
scale (this is what VPRI is interested in) - namely UI programming.

Here’s the abstract from the paper:

The state of an imperative program—e.g., the values stored in global and
local variables, arrays, and objects’ instance variables—changes as its
statements are executed. These changes, or side effects, are visible globally:
when one part of the program modifies an object, every other part that holds a
reference to the same object (either directly or indirectly) is also affected.
This paper introduces worlds, a language construct that reifies the notion of
program state and enables programmers to control the scope of side effects. We
investigate this idea by extending both JavaScript and Squeak Smalltalk with
support for worlds, provide examples of some of the interesting idioms this
construct makes possible, and formalize the semantics of property/field lookup
in the presence of worlds. We also describe an efficient implementation
strategy (used in our Squeak-based prototype), and illustrate the practical
benefits of worlds with two case studies.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), and email
us
a link to what you made by noon Eastern Time next Monday.

This week Brian Cobb wrote a reflection about the the Bayou paper with an explanation of the Write Log and the Undo Log. Thanks Brian!

Happy reading!


Tests are pieces of code that check if your main code works.  I write
tests to catch bugs when I refactor.  I write tests to force myself to
think through and handle edge cases.  I write tests to show the users
of my project that my code does what I say it does.

For this essay, I will describe the code and tests for a tiny web app
that draws a blue sky if it’s day time.



And a black sky if it’s night time.



I will describe all the code I wrote.  The web app.  The microscopic
testing framework.  The tests for the client side code.  The mocks
that fake layers of the web app and technologies that are not
pertinent.  The tests that use these mocks.  The refactored code that
simplifies the mocks by dividing the web app code into different
pieces that have single responsibilites.

Along the way, I will talk about many fun things.  Temporarily
patching libraries written by other people.  Writing code that
pretends to be the Internet.  Making Ajax requests by hand.  Writing a
little web server.  Examining a function to find out how many
arguments it expects.  Making asynchronous blocks of code run serially
so they don’t tread on each other’s toes.

To see the code from this essay in runnable form, go to
the testing
from the ground up GitHub repository.  At each evolution of the
code, I will include a link to the corresponding commit.

This is the HTML that defines the only page in the web app.  It has a
canvas element that displays the sky.  It loads the client side
JavaScript, client.js.  When the DOM is ready, it
calls loadTime(), the one and only function.

Below is the client side JavaScript.

loadTime() starts by making an Ajax request to the server
to get the current time.  This is done in several steps.  First, it
creates an XMLHttpRequest object.  Second, near the
bottom of the function, it configures the object to make
a GET request to "/time.json".  Third, it
sends the request.  Fourth, when the requested time data arrives at
the client, the function bound to request.onload fires.

The bound function grabs the drawing context for the canvas element.
It parses "day" or "night" from the JSON
returned by the server.  If the value is "day", it sets
the draw color to blue and draws a rectangle that takes up the whole
canvas.  If the value is "night", the color is black.

Below is the server-side JavaScript.  It is run
on Node.js.  Near the bottom, the
code uses the Node HTTP module to create a web server.  It specfies
that every web request should be handled
by requestHandler().  Each time this function is called,
Node passes it a request object that has the URL that was
requested, and a response object that can be used to send
data back to the client.

If the client requested "/", the root,
the index.html file is read from disk and its contents
are sent back to be displayed in the user’s browser.
If "/time.json" was requested, the server looks up the
time, creates a piece of JSON that looks something like {
"time": "day" } and sends it back to the user’s web browser.

Here is
the code
for the basic web app.

Test code is very simple.  It runs application code, and throws an error if the
outcome is not as expected.  Test code can be structured as functions, where each
function tests a specific scenario.

Some of the test code is boiler plate that runs each test in turn, prints
the outcome and reports errors.  It is nice to abstract this code into a framework
to avoid repetition.  This is the one I wrote.

test() could be used to write a test like this:

Which, when run, would look like this:

How does the testing framework run the tests it is given?

test() takes a series of arguments that alternate between
string descriptions and test functions.  It throws away the ones that
are strings, which are merely human-readable window-dressing.  It puts
the functions into an array.  It walks through that array, calling
each function and printing a period to indicate that the test passed.

The test functions use test.isEqual() to assert that
certain variables have certain values.  (A real testing framework
would have a more permissive and pragmatic version
of isEqual() that returned true in a case
like test.isEqual({ love: "you" }, { love: "you" }).) If
an assertion fails, an exception is thrown, an
error is printed and the tests stop running.

I don’t want to have to run the server when I run the tests.  That
would be an extra step.  It would add statefulness that would need to
be reset before each test.  It would necessitate network
communications between the test and the server.

This is the code I wrote that pretends to be the server deciding what
time it is and the Internet relaying that information back to the
client.  It does this by faking an Ajax request.  It replaces
the XMLHttpRequest constructor function with a function
that returns a home-made Ajax request object.  This object swallows
the web app’s call to open().  When the web app
calls send(), it calls the function that the web app has
bound to onload.  It passes some fake JSON that makes it
seem like it is always day time.

When the real code runs in a real web browser, it renders the sky to
the real canvas in real blue.  This is problematic.  First, I don’t
want to require a browser to test my code.  Second, even if I
capitulated to that requirement, it would be hard to check if the
right thing happened.  I would probably need to look at the individual
pixels of the canvas drawing context to see if they were bluey.

Instead of walking down that horrid road, I wrote some code that
pretends to be the browser DOM and the canvas element.  It
redefines getElementById() to return a fake canvas.  This
has a fake getContext() that returns a fake drawing
context that has a fake fillRect() and a fake reference
to a fake canvas that has a width
and height.  Instead of drawing, this function checks
that the arguments passed to it have the expected values.

This is the full test.

Don’t worry.  That code is as bad as this essay gets.

Here is
the code
that includes the testing framework and the first client side test.

Those mocks are pretty horrid.  They make the test very long, which
discourages me from writing tests to check for other ways the code
might go wrong.  The mocks are horrid because the client side code is
one big function that communicates with the server, asks what time it
is, parses the response and draws in the canvas.

To solve this problem, I refactored the code by pulling the drawing
code out into its own module, renderer.  This module
includes fillBackground(), a function that fills the
canvas with the passed color.  As a side benefit, the main web app
code is now easier to understand and change.

This lets me replace the complex document mock with a
short renderer.ctx() mock.  The test becomes shorter,
simpler and less brittle.

Here is
the code
for the modularised renderer and resulting simplified client side
test.

I wrote three more functions that split the code into pieces,
each with a different responsiblity.  This will let me write better tests.

This is get().  It makes an Ajax request to the passed
URL.  The Ajax request object calls the passed callback with the
response.

This is getTime().  It uses get() to make an
Ajax request to "/time.json" and
parses "day" or "night" from the response.

This is displayTime().  It takes a string with the
value "day" or "night" and draws either a
blue sky or a black sky.

I changed the body tag in the HTML page.  It now
calls getTime(), passing displayTime() as
the callback.

Having more modular code means I can mock parts of the web app
API, rather than mocking browser code written by third parties.  This
makes each test for a specific piece of functionality more succinct, which
makes it easier to write more extensive tests.

The first test checks that getTime() correctly parses JSON
sent by the server.  The second test checks that a call
to fillBackground() draws a rectangle at the correct
position and size.  The third test checks
that displayTime() draws a rectangle of the correct color
for the time of day.

Here is
the code
for the more modular client code and more extensive tests.

Some of the responsibilities of a web server require asynchronous
operations.  If a browser sends a request to the web app for the
URL "/", it gets back the contents of
the index.html file.  To make this happen, the file needs
to be read from disk asynchronously and the contents sent to the
client once they have been read.  Similarly, if the browser requests
the URL "/client.js", it gets back the contents of
the client.js file.

These are the naïve tests I wrote to check that both cases are handled
correctly.

But here is the output when I run these tests:

An exception is thrown, yet there are two periods indicating two
passed tests.  Something is wrong.

In the first test, response.end() is mocked with a
function that checks that  "<!doctype" is sent to
the user. Next, requestHandler() is called, requesting
the URL "/".  requestHandler() starts
reading index.html from disk.  While the file is being
read, the test framework presses on with its work.  Uh oh.  That is,
the framework prints a period and starts the second test, though
the response.end() mock has not asserted the value of the
response.  response.end() is re-mocked with a function
that checks that ";(function" is sent to the user.
Double uh oh.  requestHandler() is called by the second
test.  It requests the
URL "/client.js".  requestHandler() starts
reading client.js from disk.  The framework prints
another premature period.

At some point later, index.html is read from disk.  This
means that the callback in requestHandler() is called and
it calls response.end() with the contents
of index.html.  Unfortunately, by this
time, response.end() has been mocked with a function
expecting ";(function". The assertion fails.

This problem can be solved by running tests serially.  A test is run.
It signals it has finished.  The next test is run.

This may seem pedantic.  Shouldn’t tests that are testing asynchronous
behaviour be able to cope with with the dangers of asynchrony? Well,
yes and no.  They should certainly test the asynchronous behaviours
of requestHandler().  But they should not have to cope
with other tests messing about with their execution environment part
way through their execution.

(It would be possible to go further and make the tests completely
functionally pure.  This could be done in a fundamentalist way: the
test framework resets the execution context before each test.  Or it
could be done in a pragmatic way: each test undoes the changes it made
to the execution environment.  Both ways are outside the scope of this
essay.)

I rewrote the testing framework to run asynchronous tests serially.
Each asynchronous test binds a done callback parameter.
It calls this when it has made all its assertions.  The testing
framework uses the execution of this callback as a signal to run the
next test.  Here are the rewritten tests.

Below is the code for the asynchronous testing framework.

Look at runTests().  It takes userTests, an
array that contains the test functions to be run.  If that array is
empty, the tests are complete and the program exits.  If it is not
empty, it looks at the length attribute of the next test
function.  If the attribute has the value 1, the test
expects one argument: a done() callback.  It
runs testAsync(), passing the test function and a
callback that prints a period and recurses on runTests()
with the remaining test functions.

testAsync() creates a timeout that will fire in one
second.  It runs the test function, passing a done()
callback for the test to run when it is complete.  If the callback
gets run, the timeout is cleared and testDone() is called
to indicate that the next test can run.  If the done()
callback is never run by the test function, something went wrong.  The
timeout will fire and throw an exception, and the program will exit.

If the length attribute of the test function has the
value 0, the function is run
with testSync().  This is the same
as testAsync(), except there is no timeout and
the testDone() callback is called as soon as the test
function has completed.

Here is
the code
for the asynchronous testing framework and the new server tests.

Now that it is possible to write asynchronous tests, I can write the
tests for the server.  Or, rather: you can.

If you are not sure where to start, try refactoring the server so the
code is more modular.  Write a function that sends the passed string
with the passed Content-Type to the client.  Write a
function that reads a static file from disk and responds with the
contents.  Write a function that converts the current date
into "day" or "night".  Write a function
that takes a request for a certain URL and sends the right response.

Once your refactor is complete, or maybe while it is in progress, you
can write your tests.

I wrote a simple web app.  I wrote tests for it and discovered that I
could mock the pieces I didn’t want to run when I ran the tests.  I
discovered that scary things like Ajax and the canvas API really
aren’t so scary when I wrote skeletal versions of them.  I realised
that the mocks I had written were quite verbose.  I refactored the web
app code to make it more modular.  This made the code better and
easier to change in the future.  It meant I could mock the interfaces
I had written, rather than those invented by other people.  This meant
the mocks became simpler or unnecessary.  This made it easier to write
tests, so I could write more of them and test the web app more
extensively.

I wrote two tests for the server.  I discovered that the test
framework ran them in parallel, which meant they interfered with each
other.  I rewrote the test framework to run tests serially.  I
modified the tests to signal when they were finished.  I handed over
the rest of the job to you.


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is The Power of Two Random Choices: A Survey of Techniques
and
Results
by Michael Mitzenmacher, Andréa W.
Richa and Ramesh
Sitaraman. It was published
in 2001 as part of the book Handbook of Randomized Computing.

This week’s paper was submitted by Hacker School alum Dan Luu, who shared the following:

I like this paper because it’s a really simple idea that’s quite powerful and
generally applicable. It’s so simple I can even describe the key intuition in
my summary. If you randomly throw n balls into n bins, the maximum number
of balls in a single bin is approximately O(log n), with high probability.
But if you take two random choices and place the ball in the bin with fewer
balls, the maximum drops to O(log log n). The balls into bins model is a
natural fit for scheduling / load balancing, hashing, and a number of other
common problems. As a result, two random choices often turns out to be really
effective despite its simplicity.

It turns out this is also applicable to a wide variety of problems that don’t
obviously map to balls / bins, like circuit routing and random
graphs
(although applying it to things that aren’t “obviously” balls/bins problems
isn’t always simple).

This week’s paper doesn’t have an abstract, so here’s the introduction:

To motivate this survey, we begin with a simple problem that demonstrates a
powerful fundamental idea. Suppose that n balls are thrown into n bins,
with each ball choosing a bin independently and uniformly at random. Then the
maximum load, or the largest number of balls in any bin, is approximately log
n / log log n with high probability. Now suppose instead that the balls are
placed sequentially, and each ball is placed in the least loaded of d ≥ 2
bins chosen independently and uniformly at random. Azar, Broder, Karlin, and
Upfal showed that in this case, the maximum load is log log n / log d +
Θ(1) with high probability.

The important implication of this result is that even a small amount of choice
can lead to drastically different results in load balancing. Indeed, having
just two random choices (i.e., d = 2) yields a large reduction in the maximum
load over having one choice, while each additional choice beyond two decreases
the maximum load by just a constant factor. Over the past several years, there
has been a great deal of research investigating this phenomenon. The picture
that has emerged from this research is that the power of two choices is not
simply an artifact of the simple balls-and-bins model, but a general and robust
phenomenon applicable to a wide variety of situations. Indeed, this two-choice
paradigm continues to be applied and refined, and new results appear
frequently.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), and email
us
a link to what you made by noon Eastern Time next Monday.

There weren’t any submissions for last week’s paper. We’re excited to get some good ones next week.

Happy reading!


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Notation as a Tool of
Thought by
Kenneth Iverson. Iverson
originally presented this paper as his Turing Award Lecture in 1979. It was
published in the August 1980 issue of Communications of the ACM. The paper
serves both as a primer on Iverson’s ideas about notation and an introduction
to the APL programming language.

If you’re living in the United States, this is a perfect paper to read on your
trip home for Thanksgiving. If you’re not living in the US, it’s a perfect
paper to read any time this week.

Notation as a Tool of Thought was submitted by Hacker School resident
R0ml, who shared the following:

The paper argues for the importance of constructing a more sophisticated form
of programming language than any of the ones which have achieved popularity.
The paper is easily a hundred years ahead of its time – in that after reading
this paper, you look at existing programming languages and realize how crude
they are compared to the ones which will have to be developed in order to
synthesize the mathematical and linguistic aspects of programming. Mathematica
(or the Wolfram Language) is the only programming language in use today which
implements these ideas.

Iverson’s paper doesn’t have an abstract, so here’s an excerpt from the introduction:

The importance of nomenclature, notation, and language as tools of thought has
long been recognized. In chemistry and in botany, for example, the
establishment of systems of nomenclature by Lavoisier and Linnaeus did much to
stimulate and to channel later investigation. Concerning language, George Boole
in his Laws of Thought asserted “That language is an instrument of human
reason, and not merely a medium for the expression of thought, is a truth
generally admitted.”

Mathematical notation provides perhaps the best-known and best-developed
example of language used consciously as a tool of thought. Recognition of the
important role of notation in mathematics is clear from the quotations from
mathematicians given in Cajori’s A History of Mathematical Notations. They
are well worth reading in full, but the following excerpts suggest the tone:

By relieving the brain of all unnecessary work, a good notation sets it free to
concentrate on more advanced problems, and in effect increases the mental power
of the race.—A.N. Whitehead

The quantity of meaning compressed into small space by algebraic signs, is
another circumstance that facilitates the reasonings we are accustomed to carry
on by their aid.—Charles Babbage

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), and email
us
a link to what you made by noon Eastern Time next Monday.

Last week’s paper, The Power of Two Random Choices: A Survey of
Techniques and Results, was submitted by Hacker
School alum Dan Luu. This week, Dan submitted a Read
Along to his own submission about cache eviction and random
choice.

You might notice that Dan wrote his submission before last week’s PotW was
published. We think that’s great! If you’ve made something in the past that’s
based on one of our papers, we’d love to see your submission too.

Happy Thanksgiving (and happy reading)!


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Statecharts: A Visual Formalism for Complex Systems by David Harel, a professor of computer science and applied mathematics at the Weizmann Institute of Science. It was published in the June 1987 issue of Science of Computer Programming.

This week’s paper was submitted by Hacker School resident Kevin Lynagh, who shared the following:

Harel’s Statecharts are a visual formalism for specifying the behavior of
systems. They’re basically finite state machines, but with notions of hierarchy
and concurrency.

The paper is very readable: Harel reverse engineers his digital wristwatch and
draws the statechart specifying its behavior. It’s extremely fruitful to
internalize the larger idea: That you can (and should!) think rigorously about
the desired behavior of an artifact before diving straight into the code.

Here’s the abstract from the paper:

We present a broad extension of the conventional formalism of state machines
and state diagrams, that is relevant to the specification and design of complex
discrete-event systems, such as multi-computer real-time systems, communication
protocols and digital control units. Our diagrams, which we call statecharts,
extend conventional state-transition diagrams with essentially three elements,
dealing, respectively, with the notions of hierarchy, concurrency and
communication. These transform the language of state diagrams into a highly
structured and economical description language. Statecharts are thus compact
and expressive—small diagrams can express complex behavior—as well
as compositional and modular. When coupled with the capabilities of
computerized graphics, statecharts enable viewing the description at different
levels of detail, and make even very large specifications manageable and
comprehensible. In fact, we intend to demonstrate here that statecharts counter
many of the objections raised against conventional state diagrams, and thus
appear to render specification by diagrams an attractive and plausible
approach. Statecharts can be used either as a stand-alone behavioral
description or as part of a more general design methodology that deals also
with the system’s other aspects, such as functional decomposition and data-flow
specification. We also discuss some practical experience that was gained over
the last three years in applying the statechart formalism to the specification
of a particularly complex system.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), and email
us
a link to what you made by noon Eastern Time next Monday.

Sadly, we didn’t receive any Read Along submissions for Notation as a Tool of Thought. We’re looking forward to your submissions for this week’s paper.

Happy reading!


Allison

Zach

We’re thrilled to announce that Allison Kaptur and Zach Allaun have agreed to join us as Hacker School facilitators!

Zach and Allison were both students in our summer batch, where they blew us away with their love of programming and how quickly and voraciously they learned. They’re exceptionally friendly people, with phenomenal social and communication skills. They also have a penchant for always going deeper, whether they’re hacking on the ClojureScript internals or studying the subtleties of C pointers. Plus, they’re just really fun people to work with.

Allison studied astrophysics at Yale, and then went to Wall St., where she built bank models and tried to wrangle Excel into doing large-scale time series analysis. Thankfully for us, she later fell in love with programming, and has since ditched finance to spend her days coding Python and C. 

Zach went to college expecting to study political science, but quickly found computer science much more to his liking. After exhausting most of the CS classes his university offered, he decided to leave to study programming on his own. He’s since taken off like a rocket, and has already coauthored an essential piece of Hacker School infrastructure (a TrueSkill implementation in Clojure, which we use for our ping-pong tournaments.

We are unbelievably lucky to have found Allison and Zach, and we couldn’t be happier to have them as part of the team.

– Hacker School
(Nick, Dave, Sonali, Alan, Tom, Allison, and Zach)


One of the best ways to get a sense of what Hacker School is actually like is to read first-hand accounts of people who have done it. Fortunately, many alumni and residents have blogged about their experiences at Hacker School. Unfortunately, these posts are scattered across the web and can be hard to find. We’ve collected many of these blog posts here.

The posts below were written by current Hacker Schoolers or alumni, either during or after their batches. This is just a sampling of the posts folks have written about their experiences at Hacker School, and is presented in no particular order and in no way intended to be comprehensive.

The posts below were written by residents, who visit Hacker School in one- or two-week stints.


The Hacker School community has its share of prolific writers. Shortly after I started working here and reading everyone’s blogs, I realized that there was an opportunity to share the work of Hacker Schoolers, residents and alumni with a broader community of programmers. When I mentioned this to Sonali, she put me in touch with Sean Murphy (W'14), who had had much the same idea a few months earlier.

After a slew of meetings to figure out what Code Words was going to be, we came to a consensus: we wanted to create a quarterly journal to collect the work of folks in our community and share the joyful approach to programming and learning that typifies Hacker Schoolers. Like Hacker School itself, we want to make Code Words accessible and useful to both new and seasoned programmers.

We decided to see if there was any greater interest in the project, and the emphatic response to a call for submissions and editors confirmed that there was. With help and sage advice from several members of our community including Peter Seibel, Sumana Harihareswara, and Sasha Laundy, we put together contracts for our writers (we’re using the Creative Commons CC BY-NC-SA 4.0 license), a style guide, an editor’s manual and an editorial calendar. We edited the first issue on GitHub.

The process was not without hiccups. And in typical Hacker School fashion, there was also plenty of improvisation. But thanks to the work of the Hacker School community, some great design and development work from Sonali and Zach, and one of the greatest 404 pages of all time thanks to Alan and Dave, Issue One of Code Words is finally here.

We’re excited to share it with you, and to hear what you think.


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Structural Regular Expressions by Rob Pike, one of the creators of the Go programming language and the Plan 9 operating system. It was published in Proceedings of the EUUG Spring 1987 Conference.

This paper is all about picking the right abstraction. Sometimes a small change to the abstraction you’re using can dramatically simplify your code, or allow you to express a larger set of ideas. Structural Regular Expressions has a particularly good example of this. With one small change to how traditional regular expressions match, Pike shows how a number of common tasks become easier to express. The paper is accessible and short, and the examples are elegant and easy to read.

Structural Regular Expressions was suggested by Hacker Schooler Travis McDemus, who shared the following:

I benefited in a few ways from reading this concise, accessible paper: 1)
Observing some of the biases inherent throughout Unix. 2) Greater understanding
of regular expressions as a whole (which can help with daily practical usage of
vim, ed, sed, awk). 3) Understanding some of the philosophy that went into
designing Plan 9’s tools, golang, etc.

Here’s the abstract:

The current UNIX® text processing tools are weakened by the built-in concept of a
line. There is a simple notation that can describe the ‘shape’ of files when the typical
array-of-lines picture is inadequate. That notation is regular expressions. Using regular
expressions to describe the structure in addition to the contents of files has interesting
applications, and yields elegant methods for dealing with some problems the current tools
handle clumsily. When operations using these expressions are composed, the result is
reminiscent of shell pipelines.

Read Along is a way for you to participate in Paper of the Week. If you want
to take part, all you have to do is read the paper, make something small in
response (code or prose), and email
us
a link to what you made by noon Eastern Time next Monday.

We didn’t get any Read Along submissions for Statecharts: A Visual Formalism for Complex Systems :(. We’re looking forward to your submissions for this week’s paper.

If you’re looking for even more things to read, check out the first issue of Code Words, our new quarterly publication about programming.

Happy reading!




We’re excited to have Michael Lee in residency at
Hacker School this week!

Michael is a fifth year Ph.D. student at UT Austin studying security and
operating systems. He works on improving and changing the security properties
of commodity operating systems and research into creating practical crypto
protocols and systems. He has also collaborated with researchers at Columbia
University and Sandia National Labs.

Michael has already given a seminar on
Anon-Pass, an anonymous
subscription system, and is in the middle of giving another on the guts of the
Linux kernel with an eye towards security.

If you want to program with residents like Michael, you should apply to Hacker School. We’ll be announcing more
residents in the next few weeks.


Here’s a theory for why there are so many negative comments on the Internet: We train people to write them.

By negative comments, I don’t mean purely nasty comments like those on YouTube. I mean the comments that are common on Hacker News. These comments are reasonably well-written but boil down to “here is why X is wrong” in the best cases and “X is stupid” in the worst. These comments are negative in the traditional sense of the word: They aim to deny a point, or disagree.1

Learning how to disagree with and challenge ideas was a core part of many of my college classes. To this day, when I read something my mind immediately starts searching for contradictions and errors, trying to find everything it can to challenge. This is habitual for me, and is more a reflex than a conscious decision.

Indeed, Western culture trains us to disagree as part of learning to be critical thinkers. Critical thinking in its current form was first championed by the great progressive educator John Dewey, but its roots date all the way back to the Greeks, when Socrates spoke about the importance of critical self-examination to find errors in our thinking.

There’s a legitimate danger to uncritically consuming ideas floating around us. Without a critical eye, it’s easy to start believing things we’re taught unthinkingly, and I am a huge believer in the importance of critical thinking skills. But I fear emphasis has shifted from critically reflecting on and examining our own beliefs to simply criticizing and pointing out errors in other people’s work.

This shift is understandable because it’s so much easier to challenge other people’s thinking than our own. Finding errors in our own thinking is hard: First because it means discovering our personal blind spots, and second because it means admitting we’re wrong. In contrast, writing negative comments feels good: It exercises our critical thinking skills without challenging anything we hold dear.

The cynical explanation for this is that people write negative comments to show off how clever they are or how much they know. But I don’t think that’s enough to explain how dedicated many commenters are to posting negative feedback. Instead, I think people do it because they believe it’s the right thing. Our cultural obsession with critical thinking compels us to point out errors when we perceive them; errors are injustices that we must right.2 Someone is wrong on the internet, and duty calls.

But pointing out all the places other people are wrong rarely teaches us anything. So next time you read something, try this: Instead of looking for the parts you can prove are false, try to find pieces you can learn from.

Incidentally, I think this in part explains why the Hacker School community is so much more positive than the world at large: People come here firstly to learn new things, not to dispute them. This suggests an interesting question: Could you build a site like Hacker News with a community focused on learning above all else?

Negative comes from the Latin negativus, meaning “that which denies.” A negative comment is a comment that denies (or disagrees with) a part of what it’s responding to.↩


Some errors are injustices and should be corrected, but most are not. Worse, many “corrections” in comments are themselves wrong, and suggest a preference for finding things to dispute over understanding what an author is trying to say.↩



This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Open, extensible object models by Ian Piumarta and Alessandro Warth and published in 2008 in the book Self-Sustaining Systems.

This paper describes a small, flexible object model that implements method
lookup using a prototype-like system similar to JavaScript. It’s more
interesting than it sounds though: method lookup itself is defined in terms of
sending messages to objects, so you can change how method lookup works without
having to change the underlying implementation. This means that you can
implement prototypes, classes, multiple inheritance, traits, and anything else
you can dream up, in one program without digging into the internals of the
language.

What makes this even cooler is how small it is. To support all this, you only
need three object types and five methods, making this as close to a Maxwell’s
equations for objects as I’ve seen. There’s even a standalone implementation in
230 lines of C at the end of the paper.

Here’s the abstract:

Programming languages often hide their implementation at a level of abstraction
that is inaccessible to programmers. Decisions and tradeoffs made by the
language designer at this level (single vs. multiple inheritance, mixins vs.
Traits, dynamic dispatch vs. static case analysis, etc.) cannot be repaired
easily by the programmer when they prove inconvenient or inadequate. The
artificial distinction between implementation language and end-user language
can be eliminated by implementing the language using only end-user objects and
messages, making the implementation accessible for arbitrary modification by
programmers. We show that three object types and five methods are sufficient to
bootstrap an extensible object model and messaging semantics that are described
entirely in terms of those same objects and messages. Raising the
implementation to the programmers’ level lets them design and control their own
implementation mechanisms in which to express concise solutions and frees the
original language designer from ever having to say “I’m sorry.”

Read Along is a way for you to participate in Paper of the Week. All you have
to do is read the paper, make something small in response (code or prose), and
email us
a link to what you made by noon Eastern Time next Monday.

This week, Thomas Smith submitted a partial implementation of Rob Pike’s Structural Regular Expressions. Thanks, Thomas!

Happy reading!


New Hacker Schoolers are often surprised by just how unstructured Hacker School is.  During Hacker School, participants are free to get better as programmers using whatever strategies work best for them, covering whatever topics they’re most interested in. This is a very different environment from most schools and workplaces, and it often takes time to adjust to. 

Hacker Schoolers are responsible for their own learning experiences.  While facilitators are available to support Hacker Schoolers and help them make the most of this unusual environment, we never coerce Hacker Schoolers into projects, topics, or strategies that aren’t effective or enjoyable for them.  Since ultimate responsibility to succeed lies with Hacker Schoolers, they’re also free to fail—to make little progress or be unproductive.

This post discusses four of the most common pitfalls we’ve seen Hacker Schoolers struggle with, particularly at the beginning of their batches. The goal is to help Hacker Schoolers identify when they’re in one of these failure modes and quickly fix the problem. The post doesn’t discuss solutions to these problems. For one thing, the solutions are more individualized than the problems. More importantly, we believe that it’s useful just to help people recognize and name something they may be struggling with.

The first failure mode is hiding, or not being public. By “public” I mean being visible to others in some way. This includes pairing, blogging, talking at weekly presentations, giving a small-group seminar, conducting or receiving code review, and talking on our internal chat system. Nothing at Hacker School forces you to do any of these things, but your experience will be much better if you do them. Being public allows you to learn from your peers, to discover your blind spots, and to leverage others’ experience to move faster. Being public is a prerequisite for getting feedback, and feedback is a great way to grow.

The second failure mode is too much task-switching.  It’s hard to decide what to work on. This is something that people who’ve had traditional educational experiences or traditional jobs tend to really struggle with at first. As a student, you make only a handful of decisions per semester—which classes to take, maybe which topic to write a paper about, and that’s it. All the rest is time-management, deciding which of your mandatory tasks you should do in which timeslot. Similarly, as an employee of a hierarchical company, your boss might set your priorities and your deadlines. Going from this model to one where you decide which things are most important in the absence of external deadlines is a significant change. It takes practice to master this skill.

This failure case emerges when Hacker Schoolers refuse to prioritize at all, or worry excessively about their prioritization. The results of these two attitudes are the same: constant task-switching between everything that seems even minutely important.

The Hacker Schooler who won’t prioritize at all won’t say “no” to a project—or even “not now.”  They end up with a day cut into one-hour chunks of study groups, reading, pairing, following tutorials, and working independently, all on different topics and in different languages. This is a very difficult way to make progress. Most people underestimate the cost they pay from switching contexts.

The Hacker Schooler who worries too much about their prioritization wastes cycles. They tend to doubt their prioritization the most at exactly the moment that their project gets hard. Because they’re not committed to the project, they’re less likely to seek help, more likely to tab over to Twitter when they’re stuck, and more likely to give up without learning anything interesting.

The third failure mode, impostor syndrome, is a bit more tricky.   There are three problems with impostor syndrome at Hacker School.  First, people who would be great Hacker Schoolers don’t apply because they don’t think they’ll get in. Second, Hacker Schoolers don’t try hard things, because they’re afraid they’ll fail at them and everyone will know what frauds they are.  Third, Hacker Schoolers don’t publish their work or otherwise aren’t willing to be public.

Impostor syndrome is scary.  It’s particularly harmful at Hacker School because Hacker School relies on the individual to push themselves and to take risks. As mentioned above, the Hacker School faculty won’t coerce people into tasks or projects.  If you stay in your comfort zone and only work on things you know you can succeed at, you’re removing much of the opportunity for exceptional personal growth.

The flip side of this is that Hacker School has no consequences for “failing” at a project.  You may work on something for several weeks before deciding it’s impossible, not consistent with your learning goals, or just not useful for you anymore. There’s little downside to not finishing something at Hacker School.  This is very different than most jobs, college courses, and PhD research projects, and we encourage Hacker Schoolers to take full advantage of this environment by attempting things that they aren’t sure they’ll be able to do.

A final thing that Hacker Schoolers struggle with is job-hunting. Job-hunting is not only time-consuming and distracting, it also shifts Hacker Schoolers’ motivations. Hacker School relies intensely—even to a fault—on intrinsic motivation. Job-hunting, by contrast, encourages Hacker Schoolers to start thinking about what parts of their work would be considered impressive, or how they can make their projects seem shiny. People often end up plodding through projects they don’t enjoy because they think someone, somewhere, will be impressed. In reality, it’s very hard to do great work on something you hate.

Earlier in Hacker School’s history, we told people not to think about jobs at all during Hacker School. This wasn’t a good idea either, as discussed in Mistakes We’ve Made.  Now, we try to help Hacker Schoolers strike a balance by having separate, optional interview preparation sessions outside of Hacker School’s official hours.

If you’re a Hacker Schooler who’s wrestling with one or more of these failure modes during your batch, you should know that it’s common to feel this way, and it’s also common to feel more comfortable as time passes and you experiment with different strategies. To use Kathy Sierra‘s construction, these problems are typical and temporary. Quickly recognizing when you’re in one of these failure modes and changing your habits will help you make the most of the opportunity you have before you.

Allison is a Hacker School alum and was a facilitator for over two years. She’s now a software engineer at Dropbox.


We’re excited to announce eight new Hacker School residents for 2015! If you’d like to work with any of these residents, apply to Hacker School for a 2015 batch.

 Perennial resident Mel Chua will be in residence from 1/7 – 1/9. Mel is a contagiously enthusiastic hacker, writer, and educator. Her Engineering Education research at Purdue focuses on how hackers learn and how engineers are taught. You may know her from the Ada Initiative, Red Hat’s Community Leadership Team, Fedora, Sugar Labs, One Laptop Per Child, the MIT Media Lab, Design Continuum, Appropedia, or OpenPlans, among other places.

 Scott Vokes will be in residence the week of 1/26 – 1/29. He is a consultant at Atomic Object, where he builds embedded and distributed systems. Outside of work, his research interests include information retrieval—recent open source contributions include a data compression library for hard real-time systems, testing tools for C, and a content-addressable store. Scott is also the creator of @ghost_things, a byproduct of his love for wordplay.

 Sam Tobin-Hochstadt will be in residence the week of 2/2 – 2/6. Sam is an Assistant Professor in the School of Informatics and Computing at Indiana University.  He has worked on dynamic languages, type systems, module systems, and metaprogramming, including creating the Typed Racket system and popularizing the phrase “scripts to programs.”  He is a member of the ECMA TC39 working group responsible for standardizing JavaScript, where he co-designed the module system for ES6, the next version of JavaScript. He received his PhD in 2010 from Northeastern University under Matthias Felleisen.

 Chris Granger and Jamie Brandon will be in residence for the weeks of  2/23 – 3/6.
Chris grew up as part of the Nintendo generation, having learned the parts of a computer at the age of two and later learning numbers and colors from a Sesame Street game on the NES. He started programming at the age of ten and took his first paid development gig at 17. Since then he’s built websites large and small, written frameworks and libraries used by thousands, taught developers around the world, and helped envision the future of development at Microsoft. These days, he’s the co-founder and CEO of Kodowa, where they built the next generation code editor Light Table and now Eve, a new vision for putting computation in the hands of everyone.

 Jamie spent years travelling the world as a consulting computer scientist. He has seen everything from finance and gaming to the depths of corporate IT and is now pretty sure we are doing it wrong. Currently he is working on rethinking programming with Eve and hoping to do it at least slightly less wrong this time around. Jamie’s residency also marks the first time a Hacker School alumnus has returned as a resident, and we’re excited to have him back!

Chris and Jamie’s residency will be a bit different from our others. You can learn more about their plans for their residency and their project Eve in this blog post!

 Patrick Dubroy will be in residence for the week of 3/9 – 3/12. Pat is a programmer and art school dropout.He currently works with the Viewpoints Research Institute and the Communications Design Group at SAP Labs, developing languages and tools to make programming better. Previously, he worked at Google as a software engineer on Chrome and Android, and at BumpTop as a programmer and interaction designer. Originally from Canada, he now lives in Munich (and yes, he owns a pair of Lederhosn).

 Neha Narula will be in residence for one week in April 2015. She works on distributed systems and makes multicore databases go faster. She has worked on a system for executing queries on a sharded database called Dixie, an in-memory cache with materialized views called Pequod, and a multicore database that leverages commutativity called Doppel.  In a previous life she was a software engineer at Google where she worked on Google Shopping, Blobstore, and Native Client.

 Robert Lefkowitz (a.k.a. r0ml) will be returning to Hacker School for another residency for the week of 4/6 – 4/9. R0ml is a programming language enthusiast who enjoys obscure programming languages. He is a collector of programming techniques for improving clarity, increasing reliability, and maximizing brevity. He is a frequent speaker on the effects of the late Middle Ages and early Renaissance on the art of programming. His first programming project was on an Olivetti-Underwood Programma 101. He is an ACM Distinguished Engineer. Photo by Amanda Thomas.


As we recently announced, we’re thrilled to have Chris Granger and Jamie Brandon coming to Hacker School this February for a two-week residency. Chris is the co-founder and CEO of Kodowa, and Jamie is a Hacker School alum who works at Kodowa with Chris.

We are especially excited because this will be an experiment for us: Chris and Jamie’s residency will be different from those in the past because they will be coming with an explicit focus on sharing and continuing their work and research on Eve with Hacker Schoolers.

Eve is an ambitious project to make computation widely accessible by re-imagining how we interact with computers. As such, it hits on fundamental and exciting questions of computer science and programming. Like Chris and Jamie’s previous project, Light Table, Eve will be released as open source.

Eve is still early in its development, and has many open research questions. Jamie tells us these include everything from technical problems, like query planning and incremental view updates, to people problems, like managing the system’s learning curve. Beyond these questions, Chris and Jamie are interested in collaborating with Hacker Schoolers on anything that involves rethinking part of the programming process. You can read more in the Eve dev diary.

This residency will be a small step in a direction we hope to ultimately go much further: Supporting and encouraging programming research at Hacker School.


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

After an extended New Year’s break, Paper of the Week is back! This week’s paper is Xen and the Art of Virtualization by Paul Barham from Microsoft Research, Boris Dragovic, Keir Fraser, Steven Hand, Tim Harris, Alex Ho, Ian Pratt, and Andrew Warfield from the University of Cambridge Computer Laboratory, and Rolf Neugebauer from Intel Research. It was presented at the 2003 ACM Symposium on Operating Systems Principles.

This paper introduces Xen, a virtual machine monitor, or hypervisor, that allows you simultaneously and efficiently run multiple operating systems on a single piece of hardware. Twelve years after this paper was published, Xen is now a critical piece of Internet infrastructure and powers many services, including Amazon EC2. Even this blog is run on top of Xen.

Xen and the Art of Virtualization was recommended by Hacker School resident Michael Lee, who shared the following:

Part of what I like about this paper comes from impact: Xen is wildly successful and deployed all over the place. Part of it comes from the clever use of ring 1 as a way to deprivilege the guest OS. And part of it comes from the great performance they’re able to get out of the system. In my opinion, one of the key insights is realizing when it is alright to ask the developer to modify their system. In the case of Xen, they only ask the OS developer to make modifications and ensure compatibility for the wider legacy software. In doing so, they were able to attain much better performance, side step many of the difficulties presented when virtualizing x86, and even make some of the hardware interfaces cleaner for the OS developers to help ease the transition.

Here’s the abstract:

Numerous systems have been designed which use virtualization to subdivide the ample resources of a modern computer. Some require specialized hardware, or cannot support commodity operating systems. Some target 100% binary compatibility at the expense of performance. Others sacrifice security or functionality for speed. Few offer resource isolation or performance guarantees; most provide only best-effort provisioning, risking denial of service.

This paper presents Xen, an x86 virtual machine monitor which allows multiple commodity operating systems to share conventional hardware in a safe and resource managed fashion, but without sacrificing either performance or functionality. This is achieved by providing an idealized virtual machine abstraction to which operating systems such as Linux, BSD and Windows XP, can be ported with minimal effort.

Our design is targeted at hosting up to 100 virtual machine instances simultaneously on a modern server. The virtualization approach taken by Xen is extremely efficient: we allow operating systems such as Linux and Windows XP to be hosted simultaneously for a negligible performance overhead — at most a few percent compared with the unvirtualized case. We considerably outperform competing commercial and freely available solutions in a range of microbenchmarks and system-wide tests.

Read Along is a way for you to participate in Paper of the Week. All you have
to do is read the paper, make something small in response (code or prose), and
email us
a link to what you made by noon Eastern Time next Monday.

The last Paper of the Week was Open, extensible object models by Ian Piumarta and Alessandro Warth. Here are this week’s Read Alongs:

Happy reading!


Last time, Alan showed how to use GDB as a tool to learn C. Today I want to go one step further and use GDB to help us understand assembly as well.

Abstraction layers are great tools for building things, but they can sometimes get in the way of learning. My goal in this post is to convince you that in order to rigorously understand C, we must also understand the assembly that our C compiler generates. I’ll do this by showing you how to disassemble and read a simple program with GDB, and then we’ll use GDB and our knowledge of assembly to understand how static local variables work in C.

Note: All the code in this post was compiled on an x86_64 CPU running Mac OS X 10.8.1 using Clang 4.0 with optimizations disabled (-O0).

Let’s start by disassembling a program with GDB and learning how to read the output. Type the following program into a text file and save it as simple.c:

Now compile it with debugging symbols and no optimizations and then run GDB:1

Inside GDB, we’ll break on main and run until we get to the return statement. We put the number 2 after next to specify that we want to run next twice:

Now let’s use the disassemble command to show the assembly instructions for the current function. You can also pass a function name to disassemble to specify a different function to examine.

The disassemble command defaults to outputting instructions in AT&T syntax, which is the same syntax used by the GNU assembler.2 Instructions in AT&T syntax are of the format mnemonic  source, destination. The mnemonic is a human readable name for the instruction. Source and destination are operands and can be immediate values, registers, memory addresses, or labels. Immediate values are constants, and are prefixed by a $. For instance, $0x5 represents the number 5 in hexadecimal. Register names are prefixed by a %.

It’s worth taking a quick detour to understand registers. Registers are data storage locations directly on the CPU. With some exceptions, the size, or width, of a CPU’s registers define its architecture. So if you have a 64-bit CPU, your registers will be 64 bits wide. The same is true of 32-bit CPUs (32-bit registers), 16-bit CPUs, and so on.3 Registers are very fast to access and are often the operands for arithmetic and logic operations.

The x86 family has a number of general and special purpose registers. General purpose registers can be used for any operation and their value has no particular meaning to the CPU. On the other hand, the CPU relies on special purpose registers for its own operation and the values stored in them have a specific meaning depending on the register. In our example above, %eax and %ecx are general purpose registers, while %rbp and %rsp are special purpose registers. %rbp is the base pointer, which points to the base of the current stack frame, and %rsp is the stack pointer, which points to the top of the current stack frame. %rbp always has a higher value than %rsp because the stack starts at a high memory address and grows downwards. If you are unfamiliar with the call stack, you can find a good introduction on Wikipedia.

One quirk of the x86 family is that it has maintained backwards compatibility all the way back to the 16-bit 8086 processor. As x86 moved from 16-bit to 32-bit to 64-bit, the registers were expanded and given new names so as to not break backwards compatibility with code that was written for older, narrower CPUs.

Take the general purpose register AX, which is 16 bits wide. The high byte can be accessed with the name AH, and the low byte with the name AL. When the 32-bit 80386 came out, the Extended AX register, or EAX, referred to the 32-bit register, while AX continued to refer to a 16-bit register that made up the lower half of EAX. Similarly, when the x86_64 architecture came out, the “R” prefix was used and EAX made up the lower half of the 64-bit RAX register. I’ve included a diagram below based on a Wikipedia article to help visualize the relationships I described:

This should be enough information to start reading our disassembled program.

The first two instructions are called the function prologue or preamble. First we push the old base pointer onto the stack to save it for later. Then we copy the value of the stack pointer to the base pointer. After this, %rbp points to the base of main‘s stack frame.

This instruction copies 0 into %eax. The x86 calling convention dictates that a function’s return value is stored in %eax, so the above instruction sets us up to return 0 at the end of our function.

Here we have something we haven’t encountered before: -0x4(%rbp). The parentheses let us know that this is a memory address. Here, %rbp is called the base register, and -0x4 is the displacement. This is equivalent to %rbp + -0x4. Because the stack grows downwards, subtracting 4 from the base of the current stack frame moves us into the current frame itself, where local variables are stored. This means that this instruction stores 0 at %rbp - 4. It took me a while to figure out what this line was for, but it seems that clang allocates a hidden local variable for an implicit return value from main.

You’ll also notice that the mnemonic has the suffix l. This signifies that the operands will be long (32 bits for integers). Other valid suffixes are byte, short, word, quad, and ten. If you see an instruction that does not have a suffix, the size of the operands are inferred from the size of the source or destination register. For instance, in the previous line, %eax is 32 bits wide, so the mov instruction is inferred to be movl.

Now we’re getting into the meat of our sample program! The first line of assembly is the first line of C in main and stores the number 5 in the next available local variable slot (%rbp - 0x8), 4 bytes down from our last local variable. That’s the location of a. We can use GDB to verify this:

Note that the memory addresses are the same. You’ll notice that GDB sets up variables for our registers, but like all variables in GDB, we prefix it with a $ rather than the % used in AT&T assembly.

We then move a into %ecx, one of our general purpose registers, add 6 to it and store the result in %rbp - 0xc. This is the second line of C in main. You’ve maybe figured out that %rbp - 0xc is b, which we can verify in GDB:

The rest of main is just cleanup, called the function epilogue:

We pop the old base pointer off the stack and store it back in %rbp and then retq jumps back to our return address, which is also stored in the stack frame.

So far we’ve used GDB to disassemble a short C program, gone over how to read AT&T assembly syntax, and covered registers and memory address operands. We’ve also used GDB to verify where our local variables are stored in relation to %rbp. Now we’re going to use our newly acquired skills to explain how static local variables work.

Static local variables are a very cool feature of C. In a nutshell, they are local variables that only get initialized once and persist their values across multiple calls to the function where they are defined. A simple use case for static local variables is a Python-style generator. Here’s one that generates all of the natural numbers up to INT_MAX:

When compiled and run, this program prints the first three natural numbers:

But how does this work? To understand static locals, we’re going to jump into GDB and look at the assembly. I’ve removed the address information that GDB adds to the disassembly so that everything fits on screen:

The first thing we need to do is figure out what instruction we’re on. We can do that by examining the instruction pointer or program counter. The instruction pointer is a register that stores the memory address of the next instruction. On x86_64, that register is %rip. We can access the instruction pointer using the $rip variable, or alternatively we can use the architecture independent $pc:

The instruction pointer always contains the address of the next instruction to be run, which means the third instruction hasn’t been run yet, but is about to be.

Because knowing the next instruction is useful, we’re going to make GDB show us the next instruction every time the program stops. In GDB 7.0 or later, you can just run set disassemble-next-line on, which shows all the instructions that make up the next line of source, but we’re using Mac OS X, which only ships with GDB 6.3, so we’ll have to resort to the display command. display is like x, except it evaluates its expression every time our program stops:

Now GDB is set up to always show us the next instruction before showing its prompt.

We’re already past the function prologue, which we covered earlier, so we’ll start right at the third instruction. This corresponds to the first source line that assigns 1 to a. Instead of next, which moves to the next source line, we’ll use nexti, which moves to the next assembly instruction. Afterwards we’ll examine %rbp - 0x4 to verify our hypothesis that a is stored at %rbp - 0x4. 

They are the same, just as we expected. The next instruction is more interesting:

This is where we’d expect to find the line static int b = -1;, but it looks substantially different than anything we’ve seen before. For one thing, there’s no reference to the stack frame where we’d normally expect to find local variables. There’s not even a -0x1! Instead, we have an instruction that loads 0x100001018, located somewhere after the instruction pointer, into %eax. GDB gives us a helpful comment with the result of the memory operand calculation and a hint telling us that natural_generator.b is stored at this address. Let’s run this instruction and figure out what’s going on:

Even though the disassembly shows %eax as the destination, we print $rax, because GDB only sets up variables for full width registers. 

In this situation, we need to remember that while variables have types that specify if they are signed or unsigned, registers don’t, so GDB is printing the value of %rax unsigned. Let’s try again, by casting %rax to a signed int:

It looks like we’ve found b. We can double check this by using the x command:

So not only is b stored at a low memory address outside of the stack, it’s also initialized to -1 before natural_generator is even called. In fact, even if you disassembled the entire program, you wouldn’t find any code that sets b to -1. This is because the value for b is hardcoded in a different section of the sample executable, and it’s loaded into memory along with all the machine code by the operating system’s loader when the process is launched.4

With this out of the way, things start to make more sense. After storing b in %eax, we move to the next line of source where we increment b. This corresponds to the next two instructions:

Here we add 1 to %eax and store the result back into memory. Let’s run these instructions and verify the result:

The next two instructions set us up to return a + b:

Here we load a into %eax and then add b. At this point, we’d expect %eax to be 1. Let’s verify:

%eax is used to store the return value from natural_generator, so we’re all set up for the epilogue which cleans up the stack and returns:

Now we understand how b is initialized, let’s see what happens when we run natural_generator again:

Because b is not stored on the stack with other local variables, it’s still zero when natural_generator is called again. No matter how many times our generator is called, b will always retain its previous value. This is because it’s stored outside the stack and initialized when the loader moves the program into memory, rather than by any of our machine code.

We began by going over how to read assembly and how to disassemble a program with GDB. Afterwards, we covered how static local variables work, which we could not have done without disassembling our executable.

We spent a lot of time alternating between reading the assembly instructions and verifying our hypotheses in GDB. It may seem repetitive, but there’s a very important reason for doing things this way: the best way to learn something abstract is to make it more concrete, and one of the best way to make something more concrete is to use tools that let you peel back layers of abstraction. The best way to to learn these tools is to force yourself to use them until they’re second nature.


            You’ll notice we’re using Make to build `simple.c` without a makefile. We can do this because Make has implicit rules for building executables from C files. You can find more information about these rules in the [Make manual](http://www.gnu.org/software/make/manual/make.html#Implicit-Rules). ↩



            You can also have GDB output Intel syntax, which is used by NASM, MASM, and other assemblers, but that’s outside the scope of this post. ↩



            Processors with SIMD instruction sets like MMX and SSE for x86 and AltiVec for PowerPC will often contain some registers that are wider than the CPU architecture.↩



            A discussion of object formats, loaders, and linkers is best saved for a future blog post.↩



This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is The Evolution of the Unix Time-sharing
System by Dennis
Ritchie. It was presented at the 1979
Language Design and Programming Methodology conference in Sydney, Australia.

This paper describes the early history of Unix, which was created in 1969. It’s
fun to see what’s been the same since the beginning (IO redirection), what’s
changed (there weren’t any path names!), and how things got to be the way they
are today. As supplemental reading, you may also enjoy Ritchie’s short writeup
of Space Travel, the game
for the PDP-7 that preceded Unix. If you’re feeling ambitious this weekend,
building a modern version of Space Travel might be a fun exercise (and a great
Read Along submission).

The Evolution of the Unix Time-sharing System was recommended by Hacker School resident Michael Lee.

Here’s the abstract:

This paper presents a brief history of the early development of the Unix
operating system. It concentrates on the evolution of the file system, the
process-control mechanism, and the idea of pipelined commands. Some attention
is paid to social conditions during the development of the system.

Read Along is a way for you to participate in Paper of the Week. All you have
to do is read the paper, make something small in response (code or prose), and
email us
a link to what you made by noon Eastern Time next Monday.

Hacker School alum Oskar Thorén submitted a tweet that he claims gets close to the essence of Error Detecting and Error Correcting Codes. Thanks Oskar!

Happy reading!


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Literate Programming by Donald Knuth. It was published in the May 1984 issue of The Computer Journal.

In this paper, Knuth introduces literate programming, a programming style where
computer programs are written like essays with prose interleaved with code.
Literate programming probably hasn’t caught on like Knuth had hoped when he
wrote this, but it has a small, extremely dedicated following.

Literate Programming was submitted by Hacker Schooler Waldemar Quevedo who shared the following:

I like this paper a lot not only because it is written by Knuth and because
it has one of the coolest quotable opening phrases I’ve seen: (“I believe that
the time is ripe for significantly better…”) but also because it really shows
what practicing literate programming does to you if you are to practice it.

In this paper, Knuth announces (maybe a bit too prematurely) about better
times which are coming to the practices of software development based on his
experiences of using the WEB system to craft his software.

By the end of the writing, Knuth shares how literate programming has consumed
most of his workflow to the point that he sees little benefit of not using
literate programming for any of his development.

As an Org mode user, I was surprised how literate programming with Org Babel
gradually became the development environment I felt the most comfortable
working with.

The abstract below doesn’t do justice to Knuth’s enthusiasm for literate
programming, nor the humor and clarity with which the paper is written. If
you’re not convinced, spend 3 minutes reading through the introduction. You
won’t be disappointed.

The author and his associates have been experimenting for the past several years with a programming language and documentation system called WEB. This paper presents WEB by example, and discusses why the new system appears to be an improvement over previous ones.

Read Along is a way for you to participate in Paper of the Week. All you have
to do is read the paper, make something small in response (code or prose), and
email us
a link to what you made by noon Eastern Time next Monday.

There were no Read Along submissions to last week’s paper. We’re looking forward to seeing the literate programs you write this week!

Happy reading!


This is part of our “Paper of the Week” series. For more info, check out our
introductory blog post.

This week’s paper is Compositing Digital
Images by Thomas Porter
and Tom Duff (of Duff’s
device). It was published in
the July 1984 issue of Computer Graphics. Porter and Duff had worked together
at Lucasfilm’s Graphics Group (which later became Pixar), though Duff was
working at Bell Labs at the time of the paper’s publication.

Compositing Digital Images is a very cool piece of history that describes a
method of compositing—combining a number of source images into one output
image—that we still use virtually unchanged 30 years later. The paper
introduces two ideas: an alpha channel for storing per-pixel opacity
information (the A in RGBA) and a set of operations for combining two images
that Porter and Duff call a compositing algebra.

Using an alpha channel to track opacity was not a new idea when the paper was
written, but this may have been the first time the idea was presented to the
wider world. The compositing algebra, on the other hand, was brand new and is
especially elegant.

This paper was my first rigorous introductions into the world of computer
graphics, but reading it felt familiar. Its ideas seem to pop up again and
again, whether I’m building websites, programming simple games, or messing
around in Photoshop. If you’re looking for an introduction to computer
graphics, this is a great place to start.

Here’s the abstract:

Most computer graphics pictures have been computed all at once, so that the
rendering program takes care of all computations relating to the overlap of
objects. There are several applications, however, where elements must be
rendered separately, relying on compositing techniques for the anti-aliased
accumulation of the full image. This paper presents the case for four-channel
pictures, demonstrating that a matte component can be computed similarly to the
color channels. The paper discusses guidelines for the generation of elements
and the arithmetic for their arbitrary compositing.

Read Along is a way for you to participate in Paper of the Week. All you have
to do is read the paper, make something small in response (code or prose), and
email us
a link to what you made by noon Eastern Time next Monday.

There were no Read Along submissions to last week’s paper. If you’re looking for a project for this week, we
think a minimal JavaScript implementation of the compositing algebra described
in this paper could be a lot of fun.

Happy reading!


Applicants commonly ask what a typical day at Hacker School is like. Hacker School is very self-directed, so there isn’t a simple answer. People allocate their time differently, both person by person and day by day, but there are a few buckets into which most activities fall.

The primary constant is checkins. The official start of the Hacker School day is 10:30am1, when we have morning checkins. We do checkins in groups of four to six people, and the groups change every week.2 Checkins serve several purposes. First, they help make Hacker School an intentional community by delineating a clear start of the day. Second, they provide a form of lightweight social accountability: They help folks set goals for themselves and stick to them. Third, they help people hear about what others are working on, and possibly pair up. Lastly, they provide an easy way to ask for help. Checkins usually last between five and fifteen minutes.

On Thursdays, we have weekly presentations at the end of the day. Presentations are entirely optional: You can choose whether or not to attend, and you are welcome to present or just watch. Presenters also choose how long they want to talk for, usually between one and five minutes. Attending is a fun way to hear what others are working on, find potential collaborators, and be exposed to a wide range of ideas and programming topics. Presenting is a great way to practice and improve talking about code and technical ideas to a friendly audience of peers.

On Monday nights, we have dinner and a technical talk. The talks are typically given by residents or other invited speakers, and are meant to be accessible and interesting to a wide range of programmers (i.e., they don’t assume any specific domain expertise). Our format is a 20 to 30-minute talk with no questions, followed by a 90-second break when it’s socially acceptable to leave, followed by an extended Q&A period for those who choose to stick around. We don’t have questions during our talks because we want them to remain short. We have a break before Q&A begins because we want people to have a polite opportunity to leave if they’d like.

Checkins, Monday night dinners, and Thursday presentations only make up a small part of Hacker School. Most of Hacker School is unstructured by design: We believe in giving people the freedom to use their time and opt into the structure that will be most effective for them. What people choose to do at Hacker School is typically a combination of the following:

Pairing. We encourage people to spend at least some of their time pair programming. Pairing is one of the best and most common ways to take advantage of the incredible group of people Hacker School brings together.

Working independently. While pairing is great, most Hacker Schoolers also choose to spend a good chunk of their time coding or studying on their own.

Getting or giving code review. Code review is an excellent way to get feedback on your code. We encourage people to get (and give!) regular code reviews as an effective way to write better code and track their own progress.

Attending or running short workshops or seminars. Current Hacker Schoolers, alumni, facilitators, and residents all occasionally run small workshops and seminars. Some of these are organized far in advance and many are fully ad hoc. Recent sessions have included a deep dive into how Git’s internals work, operating systems research, and how to effectively read Haskell code.

Participating in book or other small working groups. Hacker Schoolers organize one-off and ongoing groups for all kinds of things. A perennial favorite are SICP work groups, where a handful of people agree to meet regularly (e.g., “Tuesdays and Thursdays at 11am”) to go over their solutions to the book’s exercises.

Doing office hours. Hacker Schoolers can always grab a free facilitator to discuss their goals, code, or anything else. Additionally, we have a office hour system so people can book time with facilitators in advance.

Looking back over this post, it successfully conveys the mechanics of Hacker School, but fails to capture its essence. That’s because many of the best parts of Hacker School are unplanned, or at least not planned directly. The value of Hacker School is ultimately an emergent result of its base conditions: Bringing together a diverse group of friendly, intellectually curious people, providing a safe and resource-rich environment, and giving them the freedom to work on and learn about what they’re interested in. The great things this leads to are serendipitous and too numerous to enumerate.

Hacker Schoolers get 24/7 access to the space, and so some people come in much earlier, though most arrive between 10 and 10:30am. A 10:30am start time is a compromise, since past Hacker Schoolers have said their ideal start times would range from 6am to 12pm.↩


We’ve experimented with many variations for how to form and rotate groups. The current incarnation is this: Each week people choose a group from a sign-up sheet. Half of the groups are topic-based, and the first Hacker Schooler to sign up for one of those groups can set a topic (e.g., “Ruby” or “Distributed systems”). The other half of the groups are “random” – i.e., they don’t have any specific topic.↩



When you start learning to program, or working in a new language,
it’s often suggested that you build a simple program like Battleship
or Tic-tac-toe.
The games’ rules are well-defined and easy to grasp,
and you only need to read and print text to get started.
This frees you up to focus on the mechanics and ideas of the
programming language you’re learning.

To create the game’s interface in the terminal,
you end up doing a lot of string formatting: board layout,
progress bars, announcements to the user.
The length of a string is useful when formatting for 
terminals, since they usually use monospaced fonts.
For example, while writing a game of Battleship in Python
we might use the len() function explicitly for formatting math
or implicitly in convenient built-in methods like center() to
make exciting messages like the following:

However, the code above won’t always work as we expect because
the len() of text isn’t necessarily the same as its width
when displayed in a terminal.
Let’s explore three ways these numbers can differ.

Byte strings (known as “strings” in Python 2) have formatting methods like center() which assume that the displayed width of a string is equal to the number of bytes it contains.
But this assumption doesn’t always hold!
The single visible character Ä might be encoded as several bytes in a source file
or terminal.

The number of bytes in this byte string doesn’t match the number of characters
so built-in formatting operations don’t behave correctly.

Fortunately, using Unicode strings instead of byte strings solves this problem because they usually report a length equal to the number of Unicode code points
they contain.1

ANSI escape codes let us format text
by writing bytes like '\x1b[31m' to start writing in red, and '\x1b[39m'
to stop. If we build a string containing these sequences,
the calculated length of our string won’t match its
displayed width in a terminal:

The colored string reports a length larger than its displayed width, causing problems for built-in text-alignment methods.
Fortunately, there are several Python libraries that make it easier to work with
colored string-like objects that don’t include formatting characters
in their length calculations.

Clint’s colored strings have formatting methods
that produce the output you expect:

but this no longer works once two colored strings are combined into a new colored string:

My own attempt at solving this problem
uses smart string objects which know how to concatenate:

but doesn’t correctly implement every formatting method yet: above, **shipocean** has lost its color information because
a fallback implementation of center() was used.2

Formatting methods of Python Unicode strings like center() assume that the display width of a string is equal
to its character count. But this assumption doesn’t always hold!

What if we use fullwidth Unicode characters?

What about multiple Unicode code points that combine
to display a single character?3

The width of a Unicode string differs from the number of characters in it.
Fortunately, we can use the POSIX standard function wcswidth to calculate
the display width of a Unicode string.
We can use this function to rebuild our
basic formatting functionality.4

Unfortunately, for versions of Python earlier than 3.3 it’s still possible that the len() of a Unicode character like u'\U00010123' will be 2 if your Python was built to use the “narrow” internal representation of Unicode. You can check this with sys.maxunicode - if it’s a number less than the total number of Unicode code points, some Unicode characters are going to have a len() other than 1.↩

Want to fix this? Pull requests are welcome! The fix would be pretty similar to the fix for this issue about .ljust and .rjust.
  ↩

The Unicode spec calls this an extended grapheme cluster. Interestingly, the Character class in the Swift programming language represents an extended grapheme cluster and may be composed of multiple Unicode code points.
  ↩

Here we’re using a pure Python implementation for compatibility and readability.↩


This is the last post in our “Paper of the Week” series. For more info, check
out the introductory blog post.

We’ve decided to stop publishing Paper of the Week. Paper of the Week has
been fun to write, but we don’t think it’s worth continuing given the limited
response we’ve gotten and the amount of time it takes to put together. Instead,
we’re going to focus on writing other things for our blog1.

For posterity (and because our blog doesn’t have categories), here are links
to all past Papers of the Week collected in one place.

Thanks to everyone who submitted a paper, a Read Along, a suggestion, or a
comment. We hope that Paper of the Week has been enjoyable, and maybe even a
bit enlightening.

Happy reading!

If you want to get email updates when we publish a new blog post or issue of Code Words, we have a new email list that you should subscribe to.↩


Starting this month we’ll be paying alumni to interview Hacker School applicants on a part-time basis. Hacker School facilitators and founders will also continue to do interviews, but our goal is to transition to 100% alumni interviewers as soon as practical.

The only change for applicants should be a greater and more varied number of interview times available. We’ll now have interviewers across nine hours of time zones, and we hope to have more interview times available on weeknights and during weekends. We think this will make it easier for applicants to find times that fit their schedules.

Our admissions process will otherwise remain the same: A short written application, a conversational Skype interview, and a brief remote pair programming session. During the conversational interview, we typically ask questions about why people want to do Hacker School, what they hope to learn and get out of it, how they want to improve as programmers, and questions about their programming backgrounds. For the pairing interview, we use screen-sharing software to write code together, with the applicant as the primary driver. Applicants may choose to work on a task suggested by us ahead of time or their own project, and may use whatever language they’re most comfortable in.

We don’t have any trick questions or gimmicks in our admissions process. Our goal is to make our process as low-stress as possible, and ideally enjoyable. We also don’t want to surprise anyone, which is why we’re blogging about this so that applicants know ahead of time they may interview with alumni.

Since we moved to rolling admissions early last year, interview shifts have eaten up more and more facilitator time. Having alumni do interviews will free up facilitators to focus on what they do best: Making Hacker School a better experience for current Hacker Schoolers. As such, we hope that this change will both make our admissions process more applicant-friendly and improve Hacker School itself.


Today, we’re correcting one of our oldest and biggest mistakes: We’re changing our name from Hacker School to the Recurse Center.

While catchy, “Hacker School” has always been an actively bad name for us. Both words are problematic and misleading. “Hacker” is bad because so much of the world thinks of hackers as computer criminals and not clever programmers, which is the meaning we intended. And even for many people familiar with our use of the word, “hacker” can feel exclusionary. (“Hacker” was also not exactly helpful to the roughly 30% of each batch who cross the U.S. border to get here.)

“School” is bad for us because it implies the trappings of traditional schools – teachers, classes, and curricula – instead of simply a place where people learn, which is all we intended by it.

Taken together, “Hacker School” is even worse: It sounds like the name of a coding bootcamp. This was a problem we didn’t anticipate, because bootcamps weren’t a thing in 2011. But today, bootcamps are everywhere, and I can’t begin to count the number of times I’ve explained to people that we are not a bootcamp.

Despite our best efforts, the problems with our name have grown worse over time. The media and others have taken to using “hacker school” generically to refer to bootcamps, and despite our many protestations, we’ve failed to stop this. Having our name co-opted and used generically for something so different has been the source of seemingly endless confusion.

There are several downsides to changing our name. To the people familiar with us, “Hacker School” has many positive connotations. It’s memorable, playful, and easily pronounced. We own the .com. We’ve spent years building up our reputation. And even though the name has so many problems, we’re fond of it. Giving up the name “Hacker School” feels a bit like losing an old friend.

A fundamental challenge when running a business is figuring out when you should try to change the world, and when you need to change yourself instead. We believe this is a case of the latter. We concluded this by taking a long-term view. May will mark the five-year anniversary of when we quit our jobs to start building this company, and this summer is the four-year anniversary of Hacker School (or I should say, the Recurse Center). In many ways, nearly half a decade is a long time, but if we hope to build an institution that will last, our history to date will be a blip. Seen this way, it’s obvious we should change our name.

After too much deliberation, we’ve chosen the Recurse Center as our new name, primarily because:

While our name is changing, who we are and what we do is not. We hope that by calling ourselves the Recurse Center we can focus on doing the work we care about and sharing it with the world, and not explaining why our name doesn’t mean what people think it does.

Onwards!

Founded in 2011, the Recurse Center is a free, self-directed, educational retreat for people who want to get better at programming, whether they’ve been coding for three decades or three months. The retreat is free for everyone, and offers need-based living-expense grants up to $7,000 to women and people from groups traditionally underrepresented in programming.

Read more


We’re excited to announce Issue Two of Code Words, our quarterly publication about programming.

In Not everything is an expression, Michael Robert Arntzenius (RC Summer 1, 2014) presents a look at syntax classes and their importance. We especially love the ability to dynamically change the language used in the examples, as well as the careful syntax-highlighting to help explain the structure of the code.

Recurse Center facilitator Mary Rose Cook takes a deep dive into the inner workings of Git in Git from the inside out. Be sure to check out Gitlet, her JavaScript implementation of Git, after you’re done reading.

Current Recurser Jim Shields shares his experience digging into HTTP in How I learned to (stop worrying and) love HTTP, setting a great example of how to be rigorous and curious as a new programmer.

Last but not least, Nemanja Stanarevic (RC Summer 2, 2014) provides a thoughtful Introduction to reactive programming, inspired in part by Mary’s Introduction to functional programming from Code Words Issue One.

In addition to all of the writers, we’d like to thank Aki Yamada (RC Summer 2013), Rose Ames (RC Winter 2014), Erik Taubeneck (RC Summer 2013), Danielle Pham (RC Summer 1, 2014), and Jari Takkala (RC Fall 2013) for all their careful editing.

Code Words is a quarterly publication written and edited by the Recurse Center community. Like the Recurse Center itself, we aim to make Code Words accessible and useful to both new and seasoned programmers, and to share the joyful approach to programming and learning that typifies Recursers.


We’re excited to announce that Mark Dominus and Ben Orenstein will be in residence at the Recurse Center this spring and summer!

If you’d like to work with Ben, Mark or residents like them, apply to the Recurse Center.

 Mark Dominus will be in residence from 4/20 – 4/21 and 4/27 – 4/28. Mark has been programming in various capacities since around 1976. He is best-known for writing the 2005 book Higher-Order Perl, in which he adapted higher-order programming techniques widely used in Lisp, Haskell, and SML for use in Perl. His other achievements include setting up Time-Warner’s first corporate web site, developing an online catalog, recommendation, and shopping system for Estée Lauder, and bringing “The Dysfunctional Family Circus” to the Web. Mark also loves Unix system programming, mathematics, and crocuses.

 Ben Orenstein will be in residence from 7/20 – 7/24. Ben hosts the Giant Robots Podcast, runs Upcase, and co-created Trailmix.

He is a frequent teacher and speaker, and works at thoughtbot in Boston.


When we announced our residency program last month, we didn’t know what type of response we’d get. Would it be possible to get prominent progammers to take time away from their normal lives and jobs and spend a couple weeks at Hacker School?

We’re happy to say we now know the answer: Yes, it’s possible. And we’re even happier to announce our first set of Residents: Alex Payne, Peter Seibel, Jessica McKellar, David Nolen, and Stefan Karpinski. You can read all about them on our Residents page.

We’re thrilled to have such a wonderful group of Residents for our fall batch. They are all phenomenally smart and warm people, with significant expertise and passion, and are genuinely interested in helping others become better programmers.

If you’d like to hack with the creator of Julia, or write Scala with the guy who wrote the book on it, or start contributing to Twisted with its maintainer, or if you simply want to grow as a programmer in a friendly, supportive, and open environment, you should apply to Hacker School.


PyCon 2015 begins this week, and we’re excited to have many Recurse Center employees, alumni, and residents attending and presenting. We thought it would be nice to collect all the talks by Recursers in one place as a reference for our community and others interested in learning more about it.

In addition to the talks below, the Recurse Center will be at booth #718, where you will find RC employees Zach Allaun and Thomas Ballinger, as well as an ever-changing line-up of past Recursers who will be happy to answer any questions you have about RC. Come say hi!

To kick things off with a healthy dose of energy and excitement, Julia Evans (RC Fall 2013) will be giving the opening statements on Friday at 9am.

Later in the morning, long-time RC resident Jessica McKellar will be going on “a weird and wonderful compiler journey from RPython to C to JavaScript” in her talk about Python in the browser.

In the afternoon, Miriam Lauter (RC Summer 2, 2014) will be talking about how to make your own smart air conditioner using Python and a Raspberry Pi.

Amy Hanlon (RC Winter 2014) will investigate a series of Python Wats related to identify, mutability, and scope at 10:50am.

At the same time, Julia Evans will return to show how learning about systems programming and kernels can help you become more effective with your everyday Python debugging.

Directly after that, Andreas Dewes (RC Winter 2014) will talk about learning from others’ mistakes and the benefits and pitfalls of statically analyzing Python code.

Next up, Nina Zakharenko (RC Summer 2013) will talk about technical debt and review some case studies and ways to pay it down.

After lunch, Allison Kaptur (facilitator emeritus and RC Summer 2012) will dive into the CPython interpreter to track down a mysterious bug in Byterun, a Python interpreter written in Python. Allison will also be doing a second talk immediately following about understanding CPython without reading the code.

Simultaneously, past RC Resident Glyph will discuss the ethical consequences of our collective activities.

Past RC resident Brandon Rhodes will explore bytearrays and whether or not their performance gains are worth their added complexity.

Sasha Laundy (RC Winter 2013) will share advice for developing two complementary and perennially useful skills: giving and getting technical help.

Past RC resident Jacob Kaplan-Moss will help kick off the day with a keynote talk at 9:20am.

Decky Coss (RC Winter 2014) will be presenting a poster about building a Python MIDI controller during the poster session from 10am to 1:10pm.

Finally, Thomas Ballinger (facilitator and RC Winter 2012) will do some terminal whispering Sunday afternoon and will show how you can build and modify terminal-based tools and talk to your terminal from scratch.

Founded in 2011, the Recurse Center is a free, self-directed, educational retreat for people who want to get better at programming, whether they’ve been coding for three decades or three months. The retreat is free for everyone, and offers need-based living-expense grants up to $7,000 to women and people from groups traditionally underrepresented in programming.


We’re excited to announce that Frank Wang, Allison Parrish, Raquel Vélez and Jonathan Edwards will be in residence at the Recurse Center this summer!

If you’d like to work with Frank, Allison, Raquel, Jonathan or residents like them, apply to the Recurse Center.

 Frank Wang will be in residence from 6/1 – 6/4. Frank is a PhD student at MIT focusing on building secure systems. He did his undergraduate at Stanford, focusing on applied cryptography. He runs the MIT security seminar where top academics come and talk about their most recent research. He is also a member of Roughdraft Ventures, which provides small amounts of capital to early stage student startups. He is currently running a summer program for early stage security companies called Cybersecurity Factory. He has interned at the security teams at Google and Facebook as well as consulted for security companies like Qualys. When he is not busy worrying about your security, he enjoys going to art museums and being outdoors.

 Allison Parrish will be in residence from 6/8 – 6/19. Allison is a computer programmer, poet, educator and game designer who lives in Brooklyn. Her teaching and practice address the unusual phenomena that blossom when language and computers meet. Allison is currently the Digital Creative Writer-in-Residence at Fordham University and an adjunct professor and “something-in-residence” at NYU’s Interactive Telecommunications Program, where she teaches a course on writing computer programs that generate poetry.

 Raquel Vélez will be in residence from 7/20 – 7/23. Raquel is a Senior Software Developer at npm, Inc. in Oakland, CA. She has previously worked at Caltech, NASA JPL, the MIT Lincoln Laboratory, and various universities in Europe. In her off time, you can find her baking, teaching NodeBots not to fall off of tables, and speaking. Also, hanging out with her hilarious husband and two cats dressed in dog suits.

 Jonathan Edwards will be in residence from 8/24 – 8/28. Jonathan has been programming for 45 years. He was cofounder and CTO of IntraNet, Inc. where he built a document-oriented transactional replicated database in the 80’s. He learned the most about programming by having to carry a beeper for 15 years. He is currently a Research Fellow at MIT CSAIL and a member of the Communications Design Group at SAP Labs. He blogs at alarmingdevelopment.org. He specializes in being tragically ahead of his time.


Last summer and fall, Nick wrote two blog posts to answer one of the most common questions we hear from applicants: What do people actually do at the Recurse Center? We still don’t have a simple answer to that question; in fact, we hope we never will. Recursers have diverse backgrounds (we’ve had biologists, musicians, lawyers and CS grads, among many others), and work on an incredible variety of projects.

To give folks interested in applying to the Recurse Center a better sense of what to expect, we thought we’d check in with the current batches to see what they’re currently working on.

A point from Nick’s post that bears repeating is that everything written at the Recurse Center is open source, and everyone works on projects they choose for themselves based on their interests and what they want to learn.

So, without further ado, here are twelve things people are currently doing at the Recurse Center:

Develop new ways for programmers to communicate with their machines. Pam built MacVimSpeak, an OS X app that executes spoken Vim commands.

Write a language. Sarah wrote Data Monster, a domain-specific language that transpiles to d3.js.

Write a Regex Engine. Geoffrey built a simple Regex engine in Scala, and is now adding support for visualizing state machines.

Build a view engine. Michelle has been working on Prismo, a front-end templating system for JavaScript which automatically keeps track of variable dependencies and only refreshes the part of the page that’s changed.

Write a game. Noella is building a Python implementation of 2048, Aishwarya is writing Pacman in JavaScript, and Nat has been writing a variety of games in JavaScript.

Make bots (and make it easier to make bots). Zulip (our internal chat system) bots are a popular project for Recursers. Nikki and Eric built DelayBot, Agustín has built PingBot, and Andrew has built robotbotbot, a platform to make it easier to create bots.

Contribute to larger open source projects. Karthik has been working on a native remote desktop client for Guacamole, a clientless remote desktop gateway that supports standard protocols like VNC and RDP. Aditya and Ken contributed to Mozilla’s Servo browser engine project.

Find new ways to analyze and visualize data. Alex is working on a Twitter word association project which allows users to search for words and find the terms most strongly correlated with them in recent tweets. Agustín is working on a Python package that scrapes data from Excel spreadsheets.

Use programming to explore and share other interests. Cory is working on ComicGator, a webcomic aggregator. Mykola is building a live light sequencer that uses MIDI instruments to trigger LED animations, and Gonçalo is building Music Gist.

Learn a new skill or language, or deepen knowledge of an old one. Yuta read The Little Schemer, and then wrote a Scheme interpreter. Mudit took a course on Compilers, and Pietro has been working through Learning Clojure. Anthony has been taking algorithms courses and created a datalogger android app which uploads to Amazon S3.

Work with residents. Several Recursers started implementing the Paxos algorithm for solving consensus in a network of unreliable nodes after resident Neha Narula gave a talk about her work on databases and consistency. Resident Mark Dominus worked with Aditya on his Go implementation of Git and with Alex on her synthetic implementation of hashes in Python.

Reflect on and share their experiences. Lots of Recursers keep journals and blog about their experiences, like Pam, Nat, Luna and Ahmed.

If you got excited reading about the projects above or have been daydreaming about having enough time to learn a new language, design a game or work on your open source project, apply to the Recurse Center.


We’re thrilled to announce that Michael Nielsen will be spending the next year at the Recurse Center to help us launch a research lab focused on discovering better ways of making software.

As part of the launch of the research lab, we’ll also be hosting a symposium later this year, and we will be announcing new ways for researchers, industry professionals, and other kindred spirits to become part of the RC community in the coming months.

Our sole focus since we started RC four years ago has been running an educational retreat: A self-directed program in New York which brings together people from around the world for three-month stints to learn from each other and become better programmers, regardless of if they’ve been programming for a few months or a few decades. We see a research lab as a natural outgrowth of this work. The Recurse Center has always been a place where people come to learn new things. Now, we hope it will also become a place where people discover new things about the world.

Our research lab and educational retreat will be linked and mutually reinforcing. The lab will benefit from the diverse stream of programmers who come through our educational retreat, as well as the supportive, intellectual, and energizing culture we’ve grown. Our retreat will benefit from the expanded group of people who will now be able to participate in our community and the energy, ideas, and expertise they will bring with them.

Michael will be joining us for one year as a Recurse Center Research Fellow. Michael has previously worked on and written about a wide range of topics, from Lisp as the Maxwell’s equations of software to the future of science. He coauthored the canonical quantum computing textbook, and wrote the books Reinventing Discovery and Neural Networks and Deep Learning. He has also been a Research Fellow at Caltech and a senior faculty member at the Perimeter Institute.

We met Michael in 2012, when he attended the first half of our summer batch, and ever since he has impressed us with his deep intellect, unassuming demeanor, and extraordinary knack for looking at things from different perspectives and seeing connections others don’t. We are delighted to have Michael coming back to RC for a full year.

In the future, we hope to fund multiple research fellows for multiple years. In the short-term, we will be focusing on finding new ways to bring together and exchange ideas with people doing related work outside of RC. We will be sharing more about these and our symposium in the coming weeks.

In the process of figuring out how we should start this experiment, my cofounder, David Albert, has had extensive discussions with many researchers and other wise people.1 We’ve gotten a lot of conflicting feedback, but we’ve also heard some consistent themes, which have greatly informed our approach.

Fund people, not projects. Most research today is funded by writing proposals for specific projects. But what if you find a better problem to work on while doing your work? Worse, project funding is frequently tied to deliverables, which can encourage short-term thinking and discourage high-risk and potentially high-reward explorations.

Look to the edges. Much mainstream research work focuses on what is currently fashionable. Yet we believe that much of the most exciting work, what will ultimately be understood as the truly luminous ideas, are at the edges of our knowledge, currently barely visible, not yet in the mainstream. In the words of Stewart Brand, we need to “look to the edges to see where the center is going.” The fashionable fields are often important and worth funding. But if you want to make a difference with limited funding, you need to be pushing the boundary, doing edgy things, things that are not yet part of the mainstream, but with luck and imagination and daring will help create the mainstream of the future.

What we aim to produce. Much academic research is focused on publishing papers. That makes sense for some types of research, including some of the work we hope to support at RC. But in software it may make just as much sense or more to write an interactive essay, release a demo or prototype, or share the source code for a full-fledged piece of software.

Research takes time, and there aren’t enough long-term funders. Some people said they thought the lower-bound for useful work was two or three years, and others said it was at least 10. Regardless, we know we need to fund people for more than a year at a time, and we will be doing this as soon as it’s possible and responsible for us to do so.

We’d like to thank Sam Altman, Greg Brockman, Will Byrd, David Dalrymple (aka Davidad), Patrick Dubroy, Evelyn Eastmond, Jonathan Edwards, Matthias Felleisen, Dan Friedman, Chaim Gingold, Adele Goldberg, Philip Guo, Laura Hill, Ken Kahn, Alan Kay, Lindsey Kuper, Robert Lefkowitz (aka r0ml), Chris Martens, Matt Might, Henry Minsky, Margaret Minsky, Marvin Minsky, David Nolen, Peter Norvig, Ken Perlin, Cynthia Solomon, Oliver Steele, Bret Victor, and Jean Yang for providing their time, expertise, and advice for starting a research lab.

More than a decade ago, Alan Kay wrote:

There is nothing in [software engineering] that is like the construction of the Empire State building in less than a year by less than 3000 people: they used powerful ideas and power tools that we don’t yet have in software development. If software does “engineering” at all, it is too often at the same level as the ancient Egyptians before the invention of the arch (literally before the making of arches: architecture), who made large structures with hundreds of thousands of slaves toiling for decades to pile stone upon stone: they used weak ideas and weak tools, pretty much like most software development today. 

We believe this is still true, and over the long run RC’s lab will aim to expand the set of “powerful ideas and power tools” we have in the world of software. To use Alan Kay’s metaphor, we will aspire to discover, understand, and build new types of arches.

That goal is intentionally broad. Many people have advised us that a research focus should be specific enough to attract people to work together towards a shared vision and also broadly interpretable, so promising paths of inquiry aren’t off-limits.

To give some flavor for the types of work we’re excited by, here’s a small sampling of things that inspire us: VPRI’s STEPs project, Plan 9, Ken Perlin’s experiments with visual grammars, Vi Hart’s videos, Mirage, Livegrep, Growing a Language, functional composition, Systems Software Research is Irrelevant, and how Eve is making programming more declarative and Elm is making it more observable. Additionally, we’ve been inspired and informed by a number of books, most notably Seymour Papert’s Mindstorms, Jane Jacob’s The Death and Life of Great American Cities, Richard Hamming’s The Art of Doing Science and Engineering, Mitchell Waldrop’s The Dream Machine, and Jon Gertner’s The Idea Factory.

RC has been sustained the past four years by recruiting fees from partner companies who hire our alumni. Late last year, we reached a tipping point, and finally became convinced that we could sustainably run our educational retreats for free to all participants based purely off recruiting revenue. 

One of the many open questions about this experiment is whether it’s possible to sustainably fund research off recruiting fees alone. We believe it is. Our bottom line, and thus ability to fund the lab, is ultimately dependent on our ability to attract great people who someday choose to take a job through us. We believe our research lab will have a halo effect, attracting even more great people to our educational retreat, and that some of them will choose to take jobs through us, thereby funding both the retreat and research.

We know that in the world of research, a year is the blink of an eye. We see today as a small step in a long path to building a full lab and doing meaningful research. Fortunately or not, we have limited capital and a tight cash flow: We are simply not yet able to fund, for example, multiple people for decade-long fellowships. This limits our short-term options but not our long-term ambition. Our constraints also bring some benefits: They force us to focus, and ensure that if we do build a successful lab, it will be financially sustainable.

Like most things we do, this will be an experiment, and we expect to make many mistakes and adjustments as we go. Nevertheless, we are committed to supporting research at RC, both because we think it will make RC significantly better, and because we think it is a good and interesting thing to attempt.

Some of the notes from these discussions are so good that I’m convinced they should be edited and compiled into a long blog post or a short book.↩


We’re hiring for a new role: A jobs person. In this post I’ll describe what this role involves, what we’re looking for in candidates, and what to expect in our interview process. I’ll also share some background information about our business and some reasons you may or may not want to apply for this job.

The Recurse Center is an educational retreat and programming community based in New York City. People come from around the world to spend three months focusing on becoming better programmers in a self-directed, supportive, and energizing environment. Our goal is to build the best place to become a better programmer. We’ve been in operation since 2011 and have an alumni network of about 600 people.

We are free to attend, and we make money by recruiting. We work with employers ranging from small startups to public tech companies, and these companies pay us a fee when they hire our alumni.

Given our business model, you might assume that RC is a kind of jobs-training program or is otherwise focused on employment. In fact, the opposite is true: We go to great lengths to make sure that RC is not focused on jobs. We don’t run RC so we can recruit; we recruit so we can run RC. Additionally, we do not base our admissions decisions on whether someone wants or can get a job. We focus exclusively on getting the best people we can, regardless of whether they want jobs.

There are two closely related parts of this role. The first part is helping members of our community (called Recursers) who are open to new jobs find ones they’ll enjoy.  This involves a number of things, including:

The other half of this role is working with our partner companies to help them hire Recursers. This includes:

This is not an internal recruiting role. You won’t be doing hiring for RC itself, and this job doesn’t involve “sourcing” candidates (i.e., finding people and convincing them to interview), since you will only work with existing members of our community.

Every job has downsides, and this one is no exception. People usually learn about these things after they join a company, but we think it’s important to highlight them in advance:

Thankfully, we think this job has many more good things going for it:

Where (and whether) you’ve previously worked or gone to school isn’t important to us. The following, however, is important:

Additionally, it would be fantastic if you have a programming background or are familiar with the technology industry. The ideal candidate is someone who has programmed previously (either professionally or as a hobby) but who isn’t interested in working as a programmer. However, this isn’t a requirement, and we care much more that you have the characteristics listed above than any specific technical knowledge or experience in the industry.

This is not a good job for someone who’s interested in transitioning into a programming role.

As we’ve said previously, we think most interviews are poor proxies for the jobs they’re meant to screen for. This is why we try to make our interviews as much like the actual jobs we’re hiring for as possible.

Here’s the outline of the process:

Our on-site interviews will consist of a series of about four 30 to 60-minute discussions and mock working sessions. Each will be with one or two RC employees or alumni, and will be structured to be as similar to the actual work you’d be doing as possible. You’ll also get a chance to go to out to lunch or coffee with a few RC employees, and you’ll have lots of opportunities to ask us questions. Our goal is to give you an accurate impression of what the role entails and what our company is like so you too can assess whether we’re a good fit or not.


We’re excited to announce that Nathan Marz, Kate Heddleston, Haoyi Li, Martin Kleppmann, and Prabhakar Ragde will be  joining us at the Recurse Center as residents this summer and fall!

If you’d like to work with Nathan, Kate, Haoyi, Martin, Prabhakar, or residents like them, apply to the Recurse Center.

 Nathan Marz will be in residence from 6/22 – 6/25. Nathan created the Apache Storm and Cascalog projects and wrote Big Data: Principles and best practices of scalable realtime data systems. He was the lead engineer of BackType which was acquired by Twitter in 2011, and he is currently working on a new startup. When not programming, you’ll often find him flying overhead enjoying the beautiful views at 5500 feet.

 Kate Heddleston will be in residence from 7/27 – 8/6. Kate is a software engineer from San Francisco who builds web applications using Python and Flask. She received her Bachelor’s degree in Communication: Human-Computer Interaction and her Master’s degree in Computer Science: Human-Computer Interaction from Stanford. She enjoys using open source tools to build web applications and especially likes building portions of the product that interface with the user. When she is not programming, Kate is involved with organizations like Hackbright Academy, PyLadies, and Raphael House. Kate is currently traveling the world and working on personal projects.

 Haoyi Li will be in residence from 8/24 – 8/27. Haoyi is a software engineer at Dropbox who works on Dropbox’s web stack during the day and open-source Scala projects at night. At Dropbox, he’s known for building the tools, libraries and systems that make web developers more productive. In the open source world he’s most well known for his work on building out the Scala.js community and ecosystem.

 Martin Kleppmann will be in residence from 9/28 – 10/8. Martin is attempting to straddle the gap between research and industry in the area of data systems. He is currently writing Designing Data-Intensive Applications for O'Reilly, which explores the fundamental algorithms, architecture choices and trade-offs in databases and other data systems. He gives lots of talks and contributes to various open source projects including Apache Samza. He previously co-founded a startup, Rapportive, which was acquired by LinkedIn in 2012. You can find him on Twitter at @martinkl.

 Prabhakar Ragde will be in residence from 10/12 – 10/15. Prabhakar has been a Professor in the Cheriton School of Computer Science within the Faculty of Mathematics at the University of Waterloo since 1988. Much of his research has been in the areas of algorithms and complexity, but he has recently become captivated by functional programming and type theory, and has developed curricula in the area ranging from introductory to senior graduate level. His favorite programming languages are Racket, ML, Haskell, and Coq.


We’re excited to announce that Issue Three of Code Words, our quarterly publication about programming, is now online! This issue features writing from five current and past Recursers:

Aditya Mukerjee (RC Spring 1, 2015) illuminates the world of Git packfiles in Unpacking Git packfiles.

Michelle Steigerwalt (RC Spring 1, 2015) demonstrates a way to design more straightforward APIs without sacrificing performance in Pseudosynchronous JavaScript.

Current Recurser and former site reliability engineer Nat Welch (RC Spring 2, 2015) explores denial-of-service attacks and how to protect against them in DDoS and you.

Decky Coss (RC Winter 2014) introduces Lass, her Lua framework for modular game programming in Making modular videogames.

And finally, in The algebra (and calculus!) of algebraic data types, Joel Burget (RC Spring 1, 2015) explores the connection between traditional algebra and algebraic data types.

In addition to all of the writers, we’d like to thank Aki Yamada (RC Summer 2013), Dan Luu (RC Winter 2013), Stephanie Losi (RC Summer 2, 2015), Darius Bacon (RC Fall 2012), Danielle Pham (RC Summer 1, 2014), Jari Takkala (RC Fall 2013), Travis McDemus (RC Summer 2013), and Mike Walker (RC Fall 2013) for all their careful editing.

Code Words is written and edited by the Recurse Center community. Like the Recurse Center itself, we aim to make Code Words accessible and useful to both new and seasoned programmers, and to share the joyful approach to programming and learning that typifies Recursers.

I’d also like to share a bit more about our process. Code Words exists because of the hard work of members of our community, and it is important to us that they are compensated for their work. And so I am excited to announce that starting with this issue, we are now paying writers and editors a stipend for each piece they work on for Code Words.

Code Words contributors retain the copyrights to their work, and provide their essays under the terms of the Creative Commons BY-NC-SA 4.0 license.

If you’d like to receive updates about new issues and news about the Recurse Center, sign up for our mailing list.


We do our best to share what makes the environment at the Recurse Center special on our blog, our mailing list and our Twitter. But we realize that the experience of attending RC is hard to put in to words, so we’re hosting our first open house on Wednesday, July 29th from 7 pm - 9 pm.

We’re hoping this event gets you excited to apply for a batch, whether you’ve never considered applying before or if you have been thinking about it for years.

The open house will begin with a short welcome talk, followed by presentations from current and past Recursers about what they’ve been working on, and a Q&A session. Food and drinks will be served.

If you’d like to attend the open house, RSVP no later than this Friday, July 24th. Please note that space is limited, and we may need to close RSVPs.


We frequently describe the Recurse Center as being like a writer’s retreat, but for programming. What does that really mean, and why do people choose to uproot their lives and families to move to New York to do RC? In this post, I’ll try to answer that question, but instead of describing what RC is (which we’ve done elsewhere), I’ll share a few reasons why people should consider applying to RC, as well as a few reasons why we might not be a good fit.

You’re a professional programmer, and you’re not growing as quickly as you’d like in your current job. Good programming jobs provide lots of challenges and opportunities for growth, but even great jobs can become monotonous, and most companies understandably prioritize building useful features and fixing bugs over employees’ growth and education. If you’re not growing as much as you’d like (or worse, you’re stagnating) where you currently are, considering coming to RC. You’ll have three months to focus on becoming a better programmer —not deadlines, company politics, or shipping code.

You’ve never worked as a programmer, but you enjoy it, and would like to get way better. Perhaps you’ve just discovered programming in the last few months, or perhaps it’s been a hobby for years. Regardless, RC is designed to help you get the support, guidance, and resources you need to become a better programmer.

You have a project, area of interest, or programming skill you’d like study or work on deeply for three months. Maybe you want to learn about distributed systems, or become a more effective debugger, or build your first substantial project in a statically typed language. RC is a fantastic place to do any of these things, since it gives you the freedom to focus on what you want, the time to make real progress, and a large network of friendly, helpful, motivated, and intellectually curious people with expertise in almost any area of programming you can think of.

And for good measure, here are three reasons why the Recurse Center might not be a fit for what you’re looking for:

RC isn’t a good fit for people who don’t like managing their own time or setting their own goals. We do everything we can to make RC a supportive environment, and there are lots of people to draw on for advice and help, from facilitators to residents to fellow Recursers and alumni. But at its core, RC is self-directed, and most of the structure we do have is opt-in, not mandatory. There isn’t anyone at RC to tell you what you must learn or must work on, and while there are plenty of people available to provide support, it is ultimately up to you to decide what you want to focus on here.

RC isn’t a good fit for people who only want to work on their own. While everyone at RC spends some of their time here quietly working and learning on their own, a huge part of RC’s value comes from interacting with other people. And while we do our best to make RC conducive to focused, solitary work (for instance, we have two dedicated quiet rooms), we’re still not as good as a library or private office for this.

RC isn’t a fit for people who just want to make something that works, and don’t particularly care how it does. All of us fall into this category sometimes: We’re trying to build something, and we just want to make it work and don’t care if we understand how it does. In many ways, that’s the point of programming: To make things that actually work. But RC’s focus is education, not just making things run. That doesn’t mean we don’t value building things, but it does mean that RC is probably not a good fit for you if your current priority isn’t becoming a better programmer.

If you’d like to spend three months programming and learning alongside friendly, smart, motivated, and intellectually curious people, consider applying to the Recurse Center.


We’re excited to announce that David Turner, Ranjit Bhatnagar, Stephen Tu and James Coglan will be joining us at the Recurse Center as residents in the next few months!

If you’d like to work with David, Ranjit, Stephen, James, or residents like them, apply to the Recurse Center. Keep an eye on our blog for more resident announcements!


James has been working on the web for nearly a decade, mostly in Ruby and JavaScript across many parts of the stack. He maintains a number of open-source side-projects, including Faye, Canopy and jstest, and last year published JavaScript Testing Recipes. He currently works at FutureLearn and is trying to work on his coaching skills. He’d like to know more about functional programming and building languages. James will be in residence from September 14th - September 17th.


Ranjit Bhatnagar is a sound artist who works with technology, language, and found materials to create interactive installations and musical instruments.  His works have been exhibited across the United States and Europe. Ranjit recently worked with the art collectives, Flux Factory and Rabid Hands, to build a large-scale musical installation at Palais de Tokyo in Paris.  His interactive sound work, Singing Room for a Shy Person, commissioned by Amsterdam’s Métamatic Research Initiative, previewed at NYC’s Clocktower Gallery in 2013 and moved to Museum Tinguely in Basel for the Métamatic Reloaded exhibition. Ranjit will be in residence from August 30th through September 3rd.


Stephen Tu is a graduate student at UC Berkeley in the EECS department. His research interests include both theoretical and practical aspects of optimization and machine learning. He has worked on various open source contributions including developing various probabilistic models for data-microscopes, implementing semidefinite program solvers in mlpack, and various contributions to a previous version of Facebook’s HipHop compiler. He still dreams of one day building his own programming language, despite a failed attempt many years ago. Stephen will be in residence from August 30th through September 3rd.


David Turner hacks on git and Pants at Twitter.  He enjoys recursive backtracking, Unix, Free Software, and board games. David will be in residence from August 17th through August 20th.


With Thanksgiving nearly upon us, we want to take a moment to thank some people who have been instrumental to making Hacker School a reality.

But first, a brief story.

We opened applications for our fifth batch of Hacker School in the beginning of August. When we announced the batch, Etsy had already generously agreed to sponsor 10 grants for female programmers. We were also in talks with several other companies to provide additional scholarships, and we were confident that they would come through.

But as anyone who’s ever tried to make a business deal knows, nothing is final until it’s final, and things can fall apart at any moment. And that’s exactly what happened. A couple companies wanted to attach strings to their grants, like requiring that students intern for them or otherwise prioritize them after Hacker School. That didn’t fit with the spirit of Hacker School, and so those deals fell through. First one, then another.

By then, we were well into September. We were in the middle of sending out acceptances, and we were all out of grants. We had qualified women who were ready and excited to do Hacker School, but who couldn’t up and leave for New York without financial assistance. The batch was only a few weeks away, and they needed an answer.

Thankfully, that’s when GitHub and Palantir stepped up to provide additional grants. They were responsive, helpful, and most importantly just cared about helping more female programmers do Hacker School.

We want to personally thank Scott Chacon at GitHub and Ari Gesher at Palantir for coming through for us.

Thank you.


Today, as the result of an ambitious Dropbox Hack Week project, Zulip, the real-time group chat app acquired by Dropbox last year, is being released as open source software.  We use Zulip every day at RC, and with today’s release, we’re excited to kick off a few experiments in collaboration with the original Zulip team and Dropbox in order to help build a sustainable open source community around the project. As part of that effort, Zulip cofounder and current Dropboxer Tim Abbott will be spending a week at RC early next month.

We switched to Zulip from IRC both for our internal company communications and for the whole RC community nearly three years ago, and it’s since grown into an indispensable part of RC. We now have about 700 people on our internal Zulip realm, and they log in from all over the globe. Zulip has allowed RC alumni who live in other countries and timezones to ask and answer technical questions, get and give advice, and stay connected to the community long after their time at RC has ended. And we strongly prefer Zulip to other options for several reasons – its message threading being a key one. It’s not an exaggeration to say Zulip has made RC a stronger community and a much better place to get programming help and advice.

We’re especially excited about this announcement because we think RC is in a unique position to help build a healthy open source community around Zulip. Zulip is institutionally important to us, and we have an alumni network of hundreds of programmers who use it regularly, many of whom are excited to make it better.

A perennial challenge of nearly all open source projects is finding and on-boarding contributors. Below are three things RC and Dropbox are doing to help Zulip get off the ground as an open source project.

First, Dropbox flew two RC alumni, Nemanja Stanarevic and Jonathan Dahan, out for their Hack Week last month. Nemanja and Jonathan joined Neeraj Wahi (an RC alum and new Dropboxer) and a team of Dropbox employees to help prepare Zulip for release as open source. Our alumni were among the nine guests, including folks from several other Zulip customers, who Dropbox hosted for the week and who contributed to open sourcing Zulip. In the process, Nemanja and Jonathan also began learning Zulip’s architecture and code base, and I’m happy to say they both plan to continue working on the project going forward.

Second, Zulip cofounder and chief architect Tim Abbott will be in residence at RC for the week of October 12th. During his time here, Tim will be giving a technical overview of Zulip’s architecture, live-coding a new feature, and preparing a list of high-value projects for people interested in contributing. Tim’s goal in coming to RC is to help spread knowledge of Zulip’s internals beyond the handful of Dropbox employees currently familiar with them.

Lastly, RC facilitator and alumna Allie Jones plans to hack on Zulip at RC, both on her own and with interested Recursers. Allie already has a local build running, and has begun making experimental changes to speed up parts of the interface.

Keeping an open source project alive and healthy requires good documentation, instructions for setting up and running the code, and people willing to help build a community around it. We’re thrilled that Dropbox and the Zulip team have invested the time and energy needed to release Zulip in a thoughtful and responsible way, and we’re excited to do our part in making it a successful open source project.

We would like to thank Leo Franchi (F'12), Jessica McKellar, Tim Abbott, Jeff Arnold, and Waseem Daher at Dropbox for all their work on Zulip and support of RC over the years.


Issue Four of Code Words, our quarterly publication about programming, is now online! Well, partially online.

We’re taking a different approach to publishing this issue. Rather than publish all of it at once, we’re going to spread publication of the pieces in Issue Four over the next two weeks. We’re doing this for a few reasons:

Our team is small and far-flung. The folks who write and edit the pieces are mainly alumni and current Recursers. They put an amazing amount of effort into each piece they work on, but we recognize that they all have busy lives and live in different time zones. For some folks it can be hard to coordinate the work, and we’d like to have a model that allows for as many folks to contribute as possible while removing some of the deadline stress.

A more spread out publication schedule will give everyone more flexibility. We’ve found that in publishing issues of Code Words we often have a piece or two that’s ready early or on time, and a piece or two that needs another week to make it great. There’s also a lot of work to be done after all the pieces are ready for publication, and delays happen at that point in the process, too. We’d like to have that time built in to our publication schedule in a better way than having padded deadlines. We also know that sometimes writers and editors can’t complete an article on time or at all due to events beyond their control, and we’d like to have a process that allows for these possiblities (this happened twice in Issue Four) while also allowing us to publish on time.

We want Code Words to be as awesome as possible. With this issue we were faced with the choice of publishing a full issue on time, or holding off a bit and giving the authors and editors time to make changes and additions to the articles that would make them better. We decided that the second option was better.

We’ve just published the first article of Issue Four: Hack the derivative by Erik Taubeneck (RC Summer 2013), which presents an interesting result in computational science, involving a clever use of complex analysis to give an efficient way to compute estimates of derivatives.

The issue will also include writing from Darius Bacon (RC Fall 2, 2015 and Fall 2012) and Mudit Ameta (RC Spring 2, 2015). In addition to all of the writers, we’d like to thank Joel Burget (RC Spring 1, 2015), Alan O'Donnell (RC Summer 2011 and facilitator emeritus), and Leo Martel (RC Summer 2, 2015) for all their careful editing and help. Special thanks to Gonzalo Bulnes, James Keene, and Mudit Ameta for the help and sympathetic eyebrow-furrowing they lent us in fixing a last-minute bug. New pieces will be published mid-next week, and the week after next. We’ll start publishing Issue Five in mid-December, and will maintain a quarterly publication schedule.

As a preview of Issue Four, here’s a line from Darius’s piece which I loved, and which I believe captures the mission of Code Words nicely:

…try to work out the basics of a subject for yourself: simple ideas are still out there undiscovered or forgotten, waiting to be put together.

Code Words is written and edited by the Recurse Center community. Like the Recurse Center itself, we aim to make Code Words accessible and useful to both new and seasoned programmers, and to share the joyful approach to programming and learning that typifies Recursers. Code Words contributors retain the copyrights to their work, and provide their essays under the terms of the Creative Commons BY-NC-SA 4.0 license.

If you’d like to receive updates about new issues and news about the Recurse Center, sign up for our mailing list.


We’re excited to announce that we have Star Simpson in residence this week, and that Tim Abbott and Marijn Haverbeke will be joining us at the Recurse Center as residents later this fall!

If you’d like to attend the Winter 1 batch to work with Marijn and other residents like Star and Tim, apply to the Recurse Center. Keep an eye on our blog for more resident announcements!


Star is a currently unafilliated electronics hacker and aviation enthusiast with a passion for the potential transformative power of applications for drone technologies. She was fed Perl as a baby before discovering embedded programming and has been trying to unlearn habits learned therein ever since. She’s currently in residence (10/5 - 10/8) at the Recurse Center, and is working with folks on Haskell and Swift projects.


Tim was the CTO and co-founder of Ksplice, which developed technology for updating a running Linux kernel without rebooting that was running on over 100,000 production servers when it was acquired by Oracle in 2011.  After Oracle, he co-founded Zulip, a powerful group chat application, which was acquired by Dropbox in 2014.  Tim is currently the technical lead for Dropbox’s main server platform.  In his spare time, he advises startups, enjoys hiking, cooking, and board games, and leads the Zulip open source project. He will be in residence at the Recurse Center next week (10/12 - 10/16), working with folks on Zulip.

 Marijn is the author of Eloquent JavaScript. His technical interests range from programming languages to distributed systems to databases. He runs a small lifestyle business around his open-source projects, such as Tern, CodeMirror, and ProseMirror. He’s made important contributions to the Rust compiler. He will be in residence at the Recurse Center from 11/16 - 11/19.


Michael Nielsen, our first research fellow, started working at the Recurse Center one month ago. This is an email I wrote to RC faculty and staff last week about research at RC. The goal was to communicate the business case for having a research lab at RC. This means it doesn’t address a lot of important questions like what sort of research we will be doing, and how our research lab will fit with the rest of RC. We’re still figuring out the answers to these questions, and I’m going to write more about them in the future as we make progress. The email has been slightly modified to remove some personal information.

Now that Michael has had some time to settle in, it’s worth revisiting why we have research at RC. The last time we talked about this was at an offsite in the spring, before several of you had joined the company.

We’re running a research lab for three reasons: We think it will make RC a better learning environment, we think it will attract more great people to RC, and we think it’s an interesting thing worth doing in its own right.

I think Michael’s presence has already made RC a better learning environment: He’s given seminars that have been well received,1 and worked with a couple of Recursers on projects related to his research. One experienced alum cited Michael’s presence as a reason for coming back to RC to do another batch.

It’s less certain whether the research lab will convince more people to apply to RC. Good research takes time and is often not flashy. Frequently there is tension between good research and good marketing, and good research is our priority. Figuring out how to use the lab to convince more people to apply to RC without negatively impacting our research will not be easy and requires balance, taste, and patience.

We think research fits well with RC’s mission of building the best place for people to become better programmers. One of my favorite parts of our blog post announcing our research lab is the idea of discovering new abstractions or “power tools” that let people build more impressive, intricate, and beautiful software in less time. At RC, we spend a lot of time helping people become better programmers as individuals. It seems logical that we should also be working to help all programmers become better by giving them more powerful tools to express themselves.

We think we’re well positioned to run a research lab. We’re not part of a university, so we can sidestep the problems generally associated with research in academia (pressure to publish regularly, constant grant writing). Because we’re not building our business around the specifics of the research done at RC, we have much more freedom than most industrial labs. We also have a unique environment full of people with a wide range of backgrounds and ideas, a fantastic alumni community, and the ability to approach things from first principles and have a long-term outlook.

Our goal is to discover new ideas and distribute them as widely as possible. None of the research done at RC will be patented, and we will have a permanent license to distribute the results as widely as possible (researchers will retain copyright to their work). This makes it easy for us to collaborate with researchers elsewhere and does the most good for the world.

While we can’t know if this experiment will work in the long run, we’re planning for success and we want to make sure we don’t end up starting from scratch when Michael’s fellowship is over. Assuming we can afford it, our plan is to hire 1-2 more researchers to join Michael before he leaves.

A useful way to figure out what we should try next is imagining a version of RC that is the size of a large university and asking yourself what it would look like. It seems inevitable that research would be a big part of that future version of RC, and there’s no better time to start than now.

Notes from Michael’s seminar on Douglas Engelbart and Augmenting Human Intellect are available on GitHub.↩


My cofounders and I adopted the no well-actually rule before we even started the Recurse Center. Almost immediately, it made working together more pleasant because the rule made us aware of an annoying tic we all had: Making pedantic “corrections” that were usually more about serving our own egos than contributing to the conversation at hand.

Having a friendly, named social rule made it easy for us to catch ourselves and avoid derailing our conversations or building resentment. Even better, it was straightforward to give and receive this feedback because it was inside a framework we’d already agreed to. Pointing out a well-actually became a genuinely lightweight piece of feedback, akin to pointing out a style guide violation like inconsistent indentation or a missing semicolon.

When we started the Recurse Center, it was obvious we should incorporate no well-actually’s, since the rule had worked so well for us internally. It worked for RC as well, and over the first few batches, we noticed other unpleasant and educationally destructive behavior and added three corresponding rules. This included acting surprised when someone doesn’t know something (no feigned surprise), interrupting conversations or pairing sessions with unsolicited advice (no backseat-driving), and minor and usually unacknowledged sexism and racism (no subtle -isms).

Throughout this process, we’ve come up with some guidelines for when social rules are helpful, and what makes a good one. Specifically, a good social rule should target behavior that is:

Relatively common. There’s little value in a social rule about things most people never do.

Done unwittingly. Much of the value of our social rules is that they let people recognize annoying things they didn’t realize they were doing. Most people don’t intend to be annoying. This means the behavior shouldn’t be overtly malicious, and this is why “don’t call people idiots” isn’t a good social rule but “no subtle -isms” is.

Fairly minor. The behavior should be more like a pinprick than a punch. Our social rules are meant to provide a means for frequent, friendly, and lightweight peer-to-peer feedback, to provide a release valve so pressure doesn’t slowly build over time.

Specific and easy to correct. This is why “don’t be a jerk” isn’t a useful social rule but “no feigned surprise” is.

Our social rules have helped make RC a better educational environment, and a remarkably pleasant place. We introduced our fourth and most recent social rule in the summer of 2012. We’ve considered others since, but we’re reluctant to add more, because we think it’s more effective to keep things simple and have a few, easy to understand rules.

Unfortunately, not all annoying behavior meets the criteria above. So what do you do if you want to further reduce bothersome behavior in your community and yourself, but you can’t even pinpoint what it is that makes certain things annoying?

Early this year, I came up with a way for spotting my own annoying behavior. I call it, Why Am I Saying This, or WAIST for short.

The idea is simple: Before I say something, I ask myself, “Why am I saying this?”1 I’ve found this to be especially helpful when writing online, for instance, in chat channels or on mailing lists. But I’ve also found it useful for in-person conversations, including meetings and group discussions, and it’s even been helpful when thinking back on past conversations: Why did I say that? If I’m responding to someone’s question, am I trying to answer it (or better understand what they’re asking), or just boost my ego? Am I trying to be helpful or just look clever? Am I trying to contribute to a conversation or just make sure people know I Have Opinions? Why did I make that bad joke that disturbed the flow of the meeting?

Since adopting this approach, I’ve found myself revising or even deleting chat messages and occasionally holding my tongue in meetings2, because I realized after reflection that I had unhelpful motivations. I’ve also found that WAIST is like a macro you can use to discover potential social rules. In fact, I think you can derive all our social rules from it.3

There are two pitfalls to consider if you try this yourself. First, you have to be willing to honestly question your motives. It’s easy to trick yourself into believing your motives are pure when they’re not, especially when there are plausible good ones (for instance, convincing yourself that you’re making a joke just to make others laugh, and not primarily because you want to appear clever). But doing so doesn’t get you anything: The goal of WAIST is to realize when you’re doing things that annoy other people, and fooling yourself here just robs you of an opportunity for growth.

The second pitfall is self-censorship. Clearly, you could take this too far, and become paralyzed questioning every little thing you do. Thankfully, this pitfall is easy to avoid: Just try WAIST for a week or two. All you have to do is reflect occasionally on why you’re about to say (or previously said) something.

I was pleasantly surprised by what I discovered.

If anyone’s curious, I’m writing this post for two reasons: First to advertise RC (and hopefully encourage people to apply), and second because I hope it will further curb annoying behavior inside our community.↩

As anyone who works with me knows, I should probably learn to talk less and listen more in meetings. I’m working on it!↩

The connections between feigning surprise, well-actually’s, and backseat-driving and WAIST are relatively clear. For subtle -isms, the answer is, unsurprisingly, usually more subtle. But the reason typically boils down to an unexamined stereotype or belief about a group of people (for example, consider the riddle about the father and son in a car crash).↩


The Recurse Center operates on a schedule of overlapping batches, which means that when a new batch starts, half of the people in the space are entering their second six-week rotation at RC. On the first day of each batch we give welcome talks to help give the new batch a sense of what to expect from their next twelve weeks at RC. 

We’ve recently started inviting the people starting their second half of RC to stand up during the welcome talks and share some advice with the new folks. They always have really wonderful things to say, and so last week we started an advice stream on Zulip, our internal chat system, to allow alumni to chime in.

We realized that some of the advice people have shared could be helpful for programmers everywhere, not just Recursers. We’ve included some of it below – we hope you find it useful!


“Don’t try to do all the things, unless that’s really what you want to do. Set a goal or two and get feedback from your peers about whether your goals are clear and attainable.” 
- Andrea Fey, Winter 2014

“It is okay to change your goals. I wanted to dive deep into Node.js when I got to RC, but after a week I decided to spend the 3 months learning Haskell just for the sake of it. And it was glorious.” 
- Gonçalo Morais, Spring 1, 2015


“If a project makes you uncomfortable, question why that is. If it’s like: ‘Ah! I can’t do this, it’s too hard!’ then it’s probably worth doing since RC is such a good environment for that. If it’s more like: ‘Eh, am I even into this?’, try to get to the bottom of why you feel that way before immediately turning away. My biggest and best project at RC made me so uncomfortable because of how hard I thought it would be that I also thought I wasn’t interested in it. Turned out I was just afraid, which made it all the better of a project!”
- Ilona Brand, Fall 1, 2015

“It’s fine to ask people if they might want to pair program with you. Sometimes you will be rejected. That is fine. If you never get rejected maybe you’re not taking enough risks!” 
- Sumana Harihareswara, Fall 2, 2014

“Write a lot. When you feel tired, go to sleep. RC will still be there when you wake up. Burn out isn’t any fun.” 
- Nat Welch, Spring 2, 2015


“We’re all coming from different places/types of experience, and people are really aware that certain things (outside stuff, inside stuff, just learning so much so fast) can be hard and affect different people differently… if you can deal with your stress right away, you can get back to doing what will make you happiest in the end: building stuff.” 
- Veronica Hanus, Fall 2, 2015

“If you have a really bad day or two days, or week… just make sure you come into the office anyway. Sometimes turning up is the most important thing.” 
- Tim Sell, Summer 1, 2015

“It’s nice to have one or two big projects to focus on, but don’t worry about getting sidetracked for a day or three. I spent a few days learning Prolog and, although I still can barely write a basic program in it, I learned so much.” 
- Liz Sander, Summer 2, 2015

“One day, I didn’t have my laptop. I decided to spend the day pairing with people and reorienting myself and my goals… and it turned out to be one of my most productive days at RC. I recommend to anyone who feels even slightly lost to forget about your projects for a day - talk to people, pair with people, ask for advice, float around.” 
- David Hargat, Fall 2, 2015

“It’s totally okay to spend time learning something and not focusing on a project. I always got scared by the ‘What are you working on?’ question, when really a perfectly reasonable answer is ‘Learning more about how x works.’” 
- Lindsey Jacks, Fall 1, 2015

“Take walks during lunch. As Javier Ernesto Olaechea (S'13) told me during my batch, Friedrich Nietzsche said you should never trust any thought you have when you’re sitting down. I wouldn’t go quite that far – I’d say you can have them while sitting down, but make sure to confirm them while on a long walk.” 
- Richard Harrington, Summer 2013

“There’s so much to be done while at RC, but make sure to take care of your health. Eat well, sleep well, and try to get a little exercise each day, even if it’s a walk around the block.” 
- Andrew Drozdov, Spring 1, 2015

“Get a journal and be honest in it! When you’re done, you’ll have an amazing souvenir of all the personal growth you’ve accomplished!” 
- Michelle Steigerwalt, Spring 1, 2015


“Keep this handy at all times.” 
- Pablo Torres, Winter 2014

 



RC faculty waggle our fingers to show agreement in meetings, and occasionally in one-on-one discussions. This was introduced by Mary Rose Cook who originally encountered it in an activist community in Leeds, England. We’ve been using the Finger Waggle for a couple of years and the results have been both positive and surprising.



The Finger Waggle solves the problem of people repeating each other in meetings. This can be merely annoying, but it can also have more serious consequences: it can keep the meeting from moving forward even though everyone agrees; it can focus attention on unimportant issues (see bikeshedding); and it can minimize contributions, when others appear to pass off someone’s original work as their own.

People repeat each other for many reasons: because they agree, because they see the same idea differently, to hear their own voice, or just because they’re not thinking about it. I’m as guilty of this as anyone. In the moment, it’s hard to remember that you’re in a meeting to solve a problem as a group, not to make yourself heard.

One interesting aspect of the Finger Waggle is that it solves this problem in a systematic way. Instead of relying on everyone to think constantly about whether they’re repeating each other, it gives them something else that’s natural and easy to do in the moment.

In addition to solving the problem of people repeating each other, there are a few other nice things about the Finger Waggle. Conversations generally move faster because waggling your fingers doesn’t take long. Multiple people can show their agreement at once, increasing the bandwidth of the meeting. Personally, waggling my fingers forces me to take a step back and remember why I’m in a meeting in the first place: not to be right, or to be heard, but to do my part to solve a problem.


Update on January 4th, 2016: All of the pieces from Issue Five are now live! Check out Lauren Long’s explanation of what RESTful means and Julia Evans’ work on fooling neural networks.

The first piece from Issue Five of Code Words, our quarterly publication about programming, is now online!

As with Issue Four, we’re publishing Issue Five piece-by-piece. You can read more about the reasons why in our Issue Four announcement blog post from October.

The first piece is a guide to writing web applications in Elixir with Plug by Robert Lord (RC Winter 2014).

The issue will also include writing from Lauren Long (RC Fall 2, 2015) and Julia Evans (RC Fall 2013). In addition to all of the writers, we’d like to thank Aditya Mukerjee (RC Spring 1, 2015), Oskar Thorén (RC Fall 2012), Stephen Tu (former RC resident), Anjana Vakil (RC Fall 2, 2015) and Alex Wilson (RC Summer 2013) for all their careful editing and help. Special thanks to Dan Luu, Leah Hanson, and Victor Felder for their feedback. New pieces from Issue Five will be published throughout next week, so make sure to check back often!

Code Words is written and edited by the Recurse Center community. Like the Recurse Center itself, we aim to make Code Words accessible and useful to both new and seasoned programmers, and to share the joyful approach to programming and learning that typifies Recursers. Code Words contributors retain the copyrights to their work, and provide their essays under the terms of the Creative Commons BY-NC-SA 4.0 license.

If you’d like to receive updates about new issues and news about the Recurse Center, sign up for our mailing list.


We’re excited to announce that Evan Czaplicki and Yan Zhu will be joining us as Recurse Center residents this year! Evan will be in residence (again!) from February 22nd through 25th, and Yan will be in residence from July 18th though 22nd.

If you’d like to work with Evan, there’s still time to apply to the Spring 1 batch. If you’d like to work with Yan, you should apply for our Summer 1 or Summer 2 batch. Keep an eye on our blog for more 2016 resident announcements!


Evan is the designer and developer of Elm, a purely functional programming language for web programming. He currently works at NoRedInk as an Open Source Engineer. Evan loves functional programming, Haskell, OCaml, Elm, compilers, type systems, library design, front-end programming, JavaScript, and reactive programming. He previously worked at Google and Microsoft.


Yan is currently a Technology Fellow at the Electronic Frontier Foundation and a Software Engineer at Brave, a start-up in San Francisco. Since 2012, she’s been a developer on various open-source security projects like the Tor Browser, SecureDrop, Privacy Badger, and Let’s Encrypt; she was also previously a member of the W3C Technical Architecture Group. Lately she’s been working on new browser privacy attacks and building new communal warehouse art spaces in her spare time. In a past life, she dropped out of high school, did her B.S. in Physics at MIT, and dropped out of a PhD in Physics at Stanford. You can read about her security research projects and more on her blog.


Today we’re launching a new experiment called RC Start: You can now apply to get free, one-on-one programming advice and help from members of the Recurse Center community.

Learning to program is hard. Not in the sense that you need to be exceptional to do it, but in that most of us struggle with it, especially when we’re just getting started.

For nearly five years we’ve been running a full-time programming retreat designed to help people become better programmers. Our retreat is great for professional programmers, long-time hobbyists, recent computer science grads, and people who have been programming intensely for several months. RC has helped hundreds of people become dramatically better programmers, and many Recursers have said that their time here was the most educational period of their lives.

But our retreat is not meant for brand new programmers. Folks who attend a batch of RC need to be able to at a minimum write short programs from scratch for our retreat to be useful. Up until now, we haven’t had a good way to support people who can’t do that yet.

We hope to change that. With RC Start, if you’re a new programmer, you can now get advice, pair program, have your code reviewed, and receive other support in becoming a better programmer – all without having to quit your job or pay thousands of dollars.

If you’re selected for RC Start you’ll get:

Three 45-minute one-on-one sessions with an RC alum. These will be either in-person or over video chat, depending on you and your mentor’s locations and preferences.

The opportunity to use these sessions however you and your mentor see fit. We expect most folks will do some combination of asking questions, pair programming, code review, discussing project ideas and learning resources, and goal setting.

Access to a private forum and mailing list so you can get help from (and help!) other RC Start participants and RC alumni.

Your mentor will be an RC alum. RC Start mentors are all friendly, thoughtful, and generous people who are excited to help new programmers grow. They are also a diverse group, and include engineers at major tech companies like Dropbox, Etsy, Google, and Mozilla; long-time hobbyists; open source contributors; and people who were very new to programming not long ago.

RC Start mentors are diverse in other ways, too: more than 40% are women, and they are distributed across more than a dozen cities, including New York, San Francisco, Boston, Seattle, Chicago, and Portland in the US, and globally in the UK, Canada, Brazil, Malaysia, Switzerland, Peru, and the Netherlands. While we expect many RC Start sessions will take place over video chat, we hope there will also be lots of in-person meetings.

RC Start is intended for people who are in the early stages of teaching themselves to program. Perhaps you’re working through online tutorials or an introductory programming book and you’d like advice on what to tackle next.

Or perhaps you’ve been learning alone and are overwhelmed by the limitless number of things you could focus on, and want to talk with a more experienced programmer who can help you cut through the buzzwords and figure out a path for yourself.

We expect that most of the folks who participate will already be taking advantage of the many great resources available for free online. The Internet has brought us countless high-quality educational resources, from books like Marijn Haverbeke’s Eloquent JavaScript to Zed Shaw’s Learn Python the Hard Way, to thousands of tutorials, online courses, and open source projects to study and learn from.

For people fortunate enough to have access to a computer and a reliable Internet connection, a lack of tools or learning materials is unlikely to be the bottleneck for their growth as programmers. Rather, we think it’s more likely a lack of access to individualized advice and a supportive community of learners will hinder someone’s development as a new programmer.

In fact, many Recursers have said a friend answering their questions or giving them personalized advice early on was instrumental to their becoming programmers. We hope RC Start can provide this kind of support to people who don’t currently have it.

We are especially excited to receive applications from people with limited financial resources and from groups that are traditionally underrepresented in programming.

While everyone is welcome to apply, RC Start is not intended for people who have recently paid to attend (or who are currently attending) programming “bootcamps.”

We’re doing this for two reasons, besides the fact that we think it’s a good thing to do. First, it’s something we are particularly well-positioned to coordinate given our alumni network of nearly 700 programmers.

Second, we hope some of the people who participate in RC Start will eventually come to our retreat. We also hope that people who don’t participate in RC Start are inspired to apply to RC Retreat. In both cases, we hope RC Start helps us continue to grow our community of thoughtful and curious people dedicated to becoming better programmers.

This is a time-limited experiment: We’ll decide in a couple of months if RC Start is worth continuing based on how much demand there is and the feedback we get from mentors and participants.

This experiment would not be possible without our amazing alumni, so many of whom enthusiastically volunteered to be mentors the moment we floated this idea. We are forever grateful for our community, who both make the Recurse Center what it is and inspire us to keep working on building the best place to become a better programmer.

Curious? Learn more about applying to RC Start or RC Retreat.

